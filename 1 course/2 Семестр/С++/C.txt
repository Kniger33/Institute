Лекция 2

Стили программирования
Технологии программирования - совокупность методов и средств, разработки программ и правило применения этих методов и средств
1)Процедурная - (Дейкстра)
	-Сходящий(+) 
	-Восходящий
2)Функциональное - здесь программа разрабатывается с использованием функционального(аппликативного) стиля, состоит из совокупности определений функций. Функции в свою очередь представляют собой вызовы других функций и предложений, управляющих последовательностью вызовов. Вычисления начинаются с вызова некоторой функции которая в свою очередь вызывает функции, входящие в ее определение и тд в соответствии с иерархией определений и структурой условных предложений. Здесь функции часто либо, прямо либо опосредованно вызывают сами себя. Каждый вызов фунции возвращает некоторое значение в вызывающую его функцию, вычисление которой после этого продолжается. Этот процесс повторяется до тех пор, пока не вычислится значение нужной функции. Первым языком является Lisp, современный - Haskell. 

Д/з-программа на haskell(пример)

//Код - main = putStrLn "Hello World!"
//Запуск runhaskell ./hello.hs

Логическое програмирование(реляционное) - программа должна уметь работать по логическим построениям, программа в таких языках состовляет собой совокупность правил и целей. Процесс выполнения программы трактуется как процесс установления общезначимости логичекой формулы по правилам, установленным семантикой того или иного языка(Prolog) 

Д/з-Пример - программа на Prolog

//Задание prolog 2_1: Запустите компилятор Tprolog. Создайте новый файл и наберите код программы, выводящий ответ на вопрос «Любит ли Мэри яблоки?» (ответ true или false). Код представлен ниже:
domains
 	a=symbol
predicates
 	likes (a,a)
clauses 
 	likes (mary,apples).
Перейдите в окно Dialog (меню Run) и введите запрос:

likes(mary,apples)
В результате в окне должен появиться ответ true

ООП 
4 принципа ООП
	Абстрагирование
	Наследование
	Инкапсуляция
	Полиморфизм(переопределяет метод класса родителя)

Они полиморфизились. Я инкапсулировался. Саня абстрагировал всю ситуацию. Все это наследовано от предков. (с)Конфуций 228 год до н.э.

																Введение в С++
Пример программы на С++:
Пространство имен помогают избегать конфликтов имен(функций, переменных (Пример, две разные библиотеки функций содержат функции с одинаковыми названиями, то следует объявить уникально простанство имен для функций и классов отдельной библиотеки, тогда можно либо при вызове определенных функций использовать префикс просртанства имен, либо объявить, что все функции по умолчанию будут вызываться из определнного пространства имен. Эта строка using namespace std - что все определенные ниже имена в программе будут относиться к пространству имен с именем std)).
Манипуляторы ввода-вывода управляют форматом вводимого и выводимого значений. Это функции, которые вставляются между вводимыми и выводимыми значениями и тем самым изменяют состояние потока  - #include <iomanip> - 
Таблица со значениями манипуляторов:
Манипулятор | Описание
dec - ввод-вывод в десятичной форме
endl - перевод строки
ends - вывод нулевого символа
flush - перевод в поток содержимого буфера
hex - ввод-вывод в шестнадцатиричной форме
oct - ввод-вывод в восьмеричной форме
resetioflags(long f) - сбрасывает флаги, указанные в f
setbase(int base) - Устанавливает базу счисле­ния равной параметру base
setfill(int ch) - Устанавливает символ заполнения равным ch
setiosflags(long f) - Устанавливает флаги, указанные в f
setprecision(int p) - Устанавливает число цифр после запятой
setw(int w) - Устанавливает ширину поля равной w
ws - Пропускает начальный символ-разделитель


Объявление переменных: тип_переменной имя_переменной; wchar_t - символы Unicode
Циклы и ветвления
Существует три способа передачи параметра в ф-ф:
1)передача по значению
2)передача оп указателю
3)передача по ссылке
Перегруженные функции - функции с одним именем, но с разным кол-ом аргументов. Их используют Когда несколько функций выполняют одинаковые действия и имеют одинаковый тип, но над разными типами.
Пример:
int summ(int &a, int &b){
	return a + b;
}
int summ(int &a, int &b, int &c){
	return a + b + c;
}
int summ(float &a, float &b){
	return floor(a + b);
}

Область видимости и классы памяти
Д.з/ Рекурсия на спуске/на подъеме (факториал)
#include <iostream>
using namespace std;

int fact(int n){
	if (n == 0 || n == 1)
		return 1;
	else
		return n * fact(n - 1);
}

Лекция 3

Объекты и классы
Опеределение класса
Для того чтобы определить объект, нужно сначала определить его форму с помощью ключевого слова class 
class name
{
	private:
		//скрытые функции и данные
	public:
		//общедоступные функции
};
Объект является экземпляром класса. Поле класса это - данные, содержащиеся внутри класса. Методы класса - функции, входящие в состав класса

class Animal
{
	int height;
	public: void voice(){
		cout << "Голос подан" << endl;
	}
};

Animal dog;
dog.voice();
Определение методов в классе и вне класса
Доступ к метеодом класса возможен только через конкретный объект этого класса. Для этого используют операцию точки(операция доступа к членам класса). Метод класса необязательно определять внутри самого класса. Для этого определение класса должно содержать прототип функции, а форма записи, которая устанавливает взаимосвязь функций и класса имеет следующий вид:
type class_name::method_name() :: - операция разрешения
class MyClass
{
	void myF();	
};

void MyClass::myF(){
	.....
}
Имя класса, операция разрешения и имя функции вместе называются квалификационным именем функции

class Animal
{
	int name, weight, areal;
	public: 
	void voice(){
		cout << "Голос подан" << endl;
	}
	setA(int w, int a, int n){
		weight = w;
		areal = a;
		name = n;
	}
	void show(){
		cout << weight << endl << areal << endl << name << endl;
	}
};

Лекция 4
Конструкторы и деструкторы
Необходимость инициализации объекта является общим требованием, поэтому в языке С++ есть возможность делать это автоматически при объявлении объекта. Это автотматическая инициализация реализуется с помощью использования функции, называемой коструктором. Конструктор - это специальная функция, являющаяся членом класса и имеющая тоже имя, что и класс. Инициализация не проводится в теле конструктора. Инициилизирующее значение расположено в скобках после имени поля, если необходимо инициализировать сразу несколько полей, то значение разделяются запятыми и образуют списко инициализации.
class Product
{
	int id;
	string name;
	int cost;
	public:
	Product():id(3), name("Banana"), cost(100){}	
	Product(int i, string n, int c):id(i), name(n), cost(c){};
	~Product(){
	cout << "Деструктор" << endl;	
	}
};
Нельзя вызывать конструктор в явном виде. Конструктор может быть перегруженным. Если в классе не объявлен ни один конструктор, то компилятор сам создает конструктор класса. Для освобождения памяти из-под объекта, т.е. при прекращении действия объекта выполняется деструктор. Деструктор имеет такое же имя как и класс, только перед ним ставится значок "~". Деструктор не имеет параметров и не возвращает значений.
int main()
{
	Product P(1, "Milk", "50");
	cout << "Hello, World!" << endl;
	Product P1(3, "Banana", "100");
}
Объекты, как аргументы методов
Объекты можно передовать в функцию в качестве аргументов точно так же, как передаются данные других типов. Можно передавать объект по ссылке, тогда все имзменения объекта в функции, являются изменениями этого объекта.
Констркутор копирования по умолчанию
Так же есть способ инициализации объекта, использующий значение полей уже существующего объекта. Такой конструктор представляется компилятором для каждого создаваемого класса и называется копирующим коструктором по умолчанию. Этот конструктор имеет единственный аргумент, являющийся объектом того же класса, что и конструктор. Конструктор копирования по умолчанию создается всякий раз, когда создается новый объект и в качестве его значений выбирается существующий объект того же типа. Тогда создали такой Product P еще два объекта можно инициилизировать следующим образом:
Product P1(P);
Product P3 = P;
В обоих случаях вызывается конструктор копирования по умолчанию, действия которого заключаются в копировании значнеий полей объекта P в P1 и P3

Лекция 5

Размещение в памяти членов объектов одного класса и способ создания общих полей(свойств)
Если поле данных класса описано с ключевым словом static, то значение этого поля будет одинаковым для всех объектов этого класса. Статические данные класса применяются тогда, когда необходимо чтобы все объекты включали одинаковые значения. Статические данные видны только внутри класса и время жизни этих данных совпадает со временем выполнения программы. Объявление статического поля находится внутри класса, а определение поля располагается вне класса и представляет собой определение глобальной переменной. Это делается потому что, если бы определение находилось внутри класса, то это бы нарушило принцип, в соответствии с которым определение класса не должно быть связано с выделением памяти. Поместив статическое поле вне класса мы обеспечили однакркатное выделение памяти под это поле до того как программа будет запущена на выполнение и статическое поле станет доступно всему классу.
static int weight;
int Person::weight = 10;

Лекция 6

Константные методы

Константные методы отличаются тем, что не изменяют значения полей своего класса. Для того чтобы функцию сделать костантной, необходимо указать ключевое слово const после прототипа, но до начала тела функции. Если объявление и тело функции разделены, то ключевое слово const указывается дважды: и в классе, и за пределами. Константными следует делать методы, у которых нет необходимости изменять значения полей объектов класса. Если объект класса объявлен с модификатором const, то он становится недоступным для изменения.
const type name;
Это означает, что для такого константного объекта можно вызвать только константные методы. Поскольку они гарантируют, что объект не будет изменен.

Массивы и строки

Лекция 7

Наследование 

Базовые и производные классы

Наследование - это процесс создания новых классов называемых наследниками или производными из уже существующих базовых классов. Производный класс - пролучает все возможности базового класса, но может быть усовершенствован. Основная форма наследования 
class name_child_class:режим_доступа name_base_class
Существует три режима доступа: public, private, protected. Послдений позволяет членам быть доступными методам своего и производного класса, при этом ограничивает доступ из функций, не принадлежащих этим классам. Если режим доступа отсутствует, то у производного класса подразумевается private. Использование спецификаторов в различных ситуациях:
к элементу 		режим   к элементу 
в базовом  классе доступа в производном классе
private					недоступно
protected	public 		protected
public					public

private					недоступно
protected	pritected	protected
public					protected

private					недоступно
protected	private		private
public  				private

Для объектов производного класса могут быть использованы методы базового класса. Это называется правами доступа. Если в производном классе не определен конструктор, то будет использоваться подходящий конструктор базового класса. Так же есть возможность использовать доступный метод взамен отсутствующего. Наследование не работает в обратном направлении и базовому классу недоступны производные методы.

Конструкторы производного класса 

Для инициализации объекта производного класса нельзя воспользовать конструктором базового класса. Компилятор будет использовать только конструктор базового класса без аргументов. Для производного класса нужно писать новые конструкторы.	
class C{
	protected:
		int a;
		char c;
	public:
		C(int A1, char C1):a(A1), c(C1){}
		C(){}
};

class A:public C{
	protected:
		int B;
	public:
		A(int A1, char C1):C(int A1, char C1){}
		A():C(){}
};

В примере конструктор A(int A1, char C1) вызывает конструктор родителя С(int A1, char C1) записанный через ":".

Лекция 8

Базовые методы класса 

Для производного класса можно определять методы, имеющие такие же имена, что и у методов базового класса. В этом случае имеет место перегрузка функции. В случае, если метод с одним и тем же названием есть и в базовом, и в производном классе, то будет выполнен метод производного класса. Методы производного класса получают доступ к методам базового класса используя операцию разрешения(::). 

Множественное наследование

Класс может быть проивзодным от нескольких базовых классов. Форма описания: class name_son : base_class_names{};
Список базовых классов содержит перечисленные через запятую классы с соответствующими режимами доступа к каждому базовому классу. Пока конструкторы базовых классов не имеют аргументов, то производный класс может не иметь функцию конструктор. Если конструктор базового класса имеет один или несколько аргументов, то каждый производный класс обязан иметь конструктор. Чтобы передать аргуметы в базовый класс нужно определить их после объявления конструктора базового класса. Форма записи: имя_производного_класса(args) : базовый_класс_1(args)...базовый_класс_n(args). Здесь базовый_класс1...., имена конструкторов базового класса, которые наследуются базовым классом. Двоеточие отделяет имя контсруктора производного класса от списка аргументов базового класса. Список аргументов ассоциируемый с базовым классом может состоять из const иил переменных. Неопределнность при множественном наследовании: 
1-Допустим, что в обоих базовых классах A и B и производном от них С. Пусть и в А, и в B существуют методы с одинаковыми именами, а в производном классе метода с таким именем нет. Проблема решается путем использования оператора разрешения, определяющего класс, в котором находится метод. Процесс направления версии метода конкретного класса называется устранением неоднозначности.
class C : public A, public B{};

int main()
{
С objC;

objC.A::show();
objC.B::show();
}

2-Мы создаем производный класс от двух базовых классов, которые в свою очередь являются производными одного класса. Это создает дерево наследования в форме ромба. Классы B и C являются производными классами класса А, а класс D производным классов B и C. Объект класса D пытается воспользоваться методом класса А. Пусть объекту класса D необходимо воспользовать методом show(). Классы B и C содержат копии метода show(), унаследованные от класса А. Тогда компилятор не понимает какой из методов show() использовать.

class A{...void show();};

class B : public A{};
class C : public A{};

class D : public B, public C{};

int main()
{
D objD;
objD.A::show();
}

Перегрузка операций и преобразование типов

Перегрузка операций

Синтаксис перегрузки операторов похож на определние функции с именем operator_операция_(+, - , и тд). Следующие операции не могут быть перегружены: операция доступа к членам структуры или класса(. или ->), операция разрешения(::) и операция условия(? :). Нельзя создавать новые операции и пытаться их перегрузить. Перегружать можно только существующие операции. Операторы ->, [], (), = можно переопределить только как методы класса. Для прегрузки <<, >> нужны подключить #include <iostream>
Различные способы передачи аргументов в функцию и возвращения значений операторов: 
1-Если аргумент не изменяется оператором, например, в случае арифметических операций то его следует передавать как ссылку на const.
2-Тип возвращаемого значения зависит от сути оператора. Если оператор должен возвращать новое значение, то необходимо создавать новый объект.
3-Для операторов присваивания необходимо возвращать ссылку на изменненый элемент. 
4-Логические операторы должны возвращать в худшем случае int, а в лучшем - bool.

Перегрузка унарных операций

Синтатксис перегрузки унарных операций

тип_имя_класса operator$(тип параметра операции).

Переопределение префиксных и постфиксных операторов выглядит так: тип_имя_класса operator--();		/префиксное
																  тип_имя_класса operator--(int);	/постфиксное
int - это не аргумент. Это слово говорит о том, что перегружается постфиксная операция.																  
class Counter{
private:
	int cnt;
public:
	Counter(){cnt = 0;}
	Counter(int c){cnt = c;}

	int getCnt(){return cnt;}

	Counter operator++(){return Counter(++cnt);}//создаем временный безымянный объект с конструктором

	Counter operator++(int){return Counter(cnt++);}
};

int main()
{
	Counter c1, c2;
	cout << c1.getCnt() << endl << c2.getCnt() << endl;
	c2 = ++c1;
	cout << c1.getCnt() << endl << c2.getCnt();
	c2 = c1++;
	cout << c1.getCnt() << endl << c2.getCnt();
}

Перегрузка бинарных операций

Синтасис для бинарных операций: тип_имя_класса operator операция(список аргументов){
	...
}

В перегруженных бинарных операциях всегда вызывается метод левого операнда. Объект, стоящий справа от знака операции, должен быть передан в функцию в качестве объекта.

Сложение, комбинированное сложение и знак меньше.

class RusSM{
	int arshin;
	int vershok;
public:
	RusSM(){
		arshin = 0;
		vershok = 0;
	}
	RusSM(int a, int v){
		if ( v >= 16){
			v -= 16;
			a++;
		}
		arshin = a;
		vershok = v;
	}

	void RusSM(){
		cin >> arshin;
		cin >> vershok;
	}

	void showInfo(){
		cout << arshin << endl << vershok << endl;
	}

	RusSM operator+(RusSM&);
	bool operator<(RusSM&);
	void operator+=(RusSM&);
};

RusSM RusSM::operator+(const RusSM& d2){
	int a = arshin + d2.arshin;
	int v = vershok + d2.vershok;

	return RusSM(a, v);
}

Преобразование типов от основного к польз. и от польз. к основному

Для перехода от основного к пользовательскому используется коструктор с одним аргументом. Его называют конструктором преобразования.
Для преобразования от определенного пользователем типа к основному создается операция преобразования.
Синтаксис: operator тип_в_который_приводим(){
	...
	return переменная_нового_типа;
}

Операция может быть вызвана явно: переменная = static_cast<тип_в_котороый_переводим>(объект)$

Или в неявном: переменная = объект;

class RusSM{
	const float artm = 0.7112;
	int arshin;
	int vershok;
public:
	RusSM()....

	RusSM(float meters){							//переводит метры в аршины и в вершки(конструктор преобразования)
		float f_arshin = meters / artm;
		arshin = int(f_arshin);
		vershok = 16 * (f_arshin - arshin);
	}

	RusSM(int a, int v){...}

	operator float(){									//оператор преобразования аршинов в метры
		float f_arshin = vershok / 16;						
		f_arshin += static_cast<float>(arshin);

		return f_arshin * artm; 
	}
};

int main()
{
	float mtrs;
	RusSM r1 = 2.55;          						//конструктор, переводящий метры в аршиы и вершки
	cout << r1.showInfo();
	mtrs = static_cast<float>(r1);
}

Лекция 9

Шаблоны 

Определение функций шаблонов 

Функция шаблона определяет общий набор операций, который будет применен к различным типам данных. Шаблоны используются для создания каркаса функции, оставляя компилятору реализацию подробностей. 

template <class тип>
type name_function(args){}

Пользовательский тип является "Держателем места" для имени типа данных, которое используется функциями. Он(тип) будет автоматически заменен компилятором на фактический тип данных во время создания конкретной версии функции. Можно определить несколько типов шаблонов данных, используя список с запятыми в качестве разделителя.

template <class type1, class type2>

void myF(type1 X, type2 Y){
	cout << X << " - " << Y << endl;
}

/*/

int main(){
	myF(10, "Hello");
	myF(-12.5 , 10);
}

Явная перегрузка функций шаблонов

Функция шаблон перегружает себя по мере необходимости. Так же можно ее перегрузить и явным образом. Если перегружается функция шаблон, то перегруженная функция переорпеделяет функцию шаблон для того конкретоного набора типа параметров, для которого создается перегруженная функция.

/*/void myF(int& X, int& Y){
	cout << X << " - " << Y << endl;
}

myF(10, 20);

Класс шаблона 

Классы шаблоны полезны тогда, когда класс содержит логику, допускающую значительные обобщения. Используя классы шаблоны можно создавать классы, поддерживающие очереди, связанные списки и тд для произвольных типов данных. Компилятор автоматически создает корректный код, основываясь на типе данных, указанном перед компиляцией.

template <class тип>
class class_name{};

При необходимости можно опеределить несколько пользовательских типов, указывая их через запятую. При создании класса шаблона можно создать конкретный экземпляр этого объекта. 

имя класса<тип> имя_объекта

template <class MyT>
class stack{
	MyT stck[100];
	int n;
public:
	stack(){}

	~stack(){}

	void push(MyT i);

	MyT pop(){};

}

template<class MyT>
stack<MyT>::stack(){
	n = 0;
}

template<class MyT>
stack<MyT>::~stack(){cout << "Пусто";}

template<class MyT>
stack<MyT>::push(MyT i){
	if (n == 100){
		cout << "Нельзя добавить";
		return;
	}
	stck[n] = i;
	n++;
} 

template<class MyT>
stack<MyT>::pop(){
	if (n == 0){
		cout << "Стэк пуст";
		return 0;
	}
	n--;
	return stck[n];
}

int main(){
	stack<int> a;
	stack<double> b;
	stack<char> c;


	a.push(10);
	b.push(8.5);
	a.push(20);
	b.push(12.3);	
	
	cout << a.pop() << ";" << a.pop() << endl;
}

Лекция 10 

Исключения 

Используя обработку исключений программа может автоматически вызывать функцию-обработчик ошибок тогда, когда такая ошибка возникает. Обработка использует 3 ключевых слова try, catch, throw. Те инструкции, в которых ожидается появление исключительных ситуаций содержатся в блоке try. Если в блоке try возникает исключение, т.е. ошибка, то генерируется исключение, которое перехватывается, используя catch.

try {
	...
}

catch(тип1 аргумент1) {
	...
}

catch(тип2 аргумент2){
	...
}

Одному блоку try может отвечать несколько инструкций catch. Какая именно инструкция catch исполняется зависит от типа исключения. Перехваченным может быть любой тип данных, включая созданные программистом классы. Если никакого исключения не сгенерировано, т.е. никакой ошибки не возникло в блоке try, то инструкции catch выполняться не будут. Исключение может быть сгенерировано из функции, вызванной внутри блока try. throw должна выполняться внутри try, либо в функции, вызванной из try.

throw исключение

int num1, num2;

cout << "num1 = ";
cin >> num1;
cout << "num2 = ";
cin >> num2;

cout << "num1 + num2 = " << num1 + num2 << endl;
cout << "num1 / num2 = ";

set_terminate(f){
	cout << "Exit" << endl;
}

try {
	if (num == 2)
		throw 100;
	cout << num1  / num2 << endl;
}
catch (int i){
	cout << "Divide by zero!" << i << endl;
	cout << num1 - num2 << endl;
}

Если сгенерируется исключение, для которого нет catch, то произойдет аварийное завершение программы. При генерации необработанного исключнения вызывается функция terminate(), то, по умолчанию, функция terminate() вызвает функцию abort(), завершающуюю выполнение программы. Однако, используя функцию set_terminate можно.

Использование нескольких инструкций catch

Если используется несколько инструкций catch, то они должны перехватывать разные типы исключений. Инструкции catch проверяются на соотвествие типа в порядке их расположения в программе. Каждая инструкция catch отвечает только за свой тип данных. 

 int test;
 cin >> test;

 try {
 	if (test)
 		throw test;
 	else
 		throw "Введен 0";

 	catch(int i){cout << i;}

 	catch(char *str){cout << str;}
}

Перехват всех исключений 

Если требуется перехватить все исключения, а не какой-то конкретный тип.

catch(...){...}

int i;
cin >> test;

try {
	if (test == 0)
		throw test;
	if (test == 1)
		throw "a";
	if (test == 2)
		throw 120.5;
	catch (...){
		cout << "Перехвачено исключение" << endl;
	}
} 

Задание ограничений на исключение

Когда функция вызывается из блока try, можно ограничить тип исключений, который эта функция может сгенерировать. Кроме того, можно вообще запретить ей генерировать исключения. 
тип_ф имя_ф(аргумент)
throw (список типов){
	...
}

Здесь только типы данных, содержащиеся в списке типов, которые могут быть сгенерированы. Если будет сгенерировано исключение какого-либо другого типа, то произойдет аварийное завершение программы. Если необходимо, чтобы функция не могла сгенерировать никакого исключения, то следует оставить список пустым. Попытка генерации исключения, не поддерживающегося функцией будет иметь своим результатом вызов функции unexpected(). Эта функция в свою очередь вызывает функцию terminate(). Можно задать свой собственный порядок обработки непредвиденных исключений с помощью функции set_expected(). 

void F(int test) throw (int, char, double){
	if (test == 1) throw test;
	if (test == 2) throw 'a';
	if (test == 3) throw 120.5;
}

int main()
{
	int x;
	cin >> x;

	try {F(x)};
	catch(int i){cout << "Integer";}
	catch(char c){cout << "Char";}
	catch(double){cout << "Double";}
	return 0;
}

Повторная генерация исключений 

Если возникает необходимость снова сгенерировать исключение из try, можно сделать это путем вызова без указания исключения throw. В результате текущее исключение будет передано во внешнюю последовательность try / catch обработки исключений.

void f(){
	try{throw "Hello";}
	catch(char *){
		cout << "Исключение2" << endl;
		throw;
	}
}

int main(){
	try{f();}

	catch(char *){
		cout << "Исключение1" << endl;
	}
}

