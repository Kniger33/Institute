//////////////////////////////////////////ЛЕКЦИЯ 4 - Константные методы////////////////////////////

Константные методы отличаются тем, что не изменяют значений полей своего класса.Для того чтобы сделать функцию константной, необходимо указать
ключевое слово  const после прототипа, но до начала 
тела функции :

тип ИмяФункции() const {}

если объявление и определение функции разделены, то ключевое слово const указывается 2 раза, и в классе и за пределами класса
Константными  следует делать методы, у которых нет необходимости изменять значения полей объектов класса.

Если объект класса объявлен с модификатором const, то он становится недоступным для изменения

const тип имя();
Это означает, что для такого константного объекта можно вызвать только константные методы.Поскольку они гарантируют, что объект не будет изменен

Конструктор запишет туда значения

////////////////////////////////////////////////////ЛЕКЦИЯ 5 МАССИВЫ И СТРОКИ///////////////////////////

указатель, ссылка, копия по значению
Func(int a[10])
Func(int a[])
Func(int *a)

Конструкторы классы string
string() - создает пустой объект класса
string(const char *str) -создает string объект из строки с завершающим 0.Эта форма конструктора обеспечивает преобразование из строки с завершающим 0 
в объект типа string
string(const string &str) - создает string объект из другого string объекта(конструктор копирования по умолчанию)

Для объектов класса string определены следующие операторы:
1)присвоение =
2)конкатинация(сложение) +
3)комбинированное 
4)равенство ==
5)неравенство !
6)>, <
7)>=, <=
8)индексация []
9) >>, <<

Класс string имеет след методы:

Метод|Описание (ДЗ)


/////////////////////////////////////////////ЛЕКЦИЯ 6  НАСЛЕДОВАНИЕ ////////////////////////////////////////////////

//////////////////Базовые и производные классы
Наследование — это процесс создания новых классов, называемых наследниками или производными из уже существующих базовых классов.
Производный класс — получает все возможности базового класса, но может быть усовершенствован.

Основная форма наследования

class имя_производного_класса : режим доступа имя_базового_класс

Существует 3 режима доступа:
1)public
2)private
3)protected

Последний позволяет членам быть доступными методам своего и производного класса, при этом ограничивает доступ из функций, не принадлежащих этим классам.
Если ржим доступа отсутствует, то у производного класса подразумевается private режим.

////////////////Использование спецификатора в различных ситуациях:
 __________________________________________________
 |К элементу в       |Режим    |К элементу в       |
 |базовом классе     |доступа  |производном классе |
 |_________________________________________________|
 |       private     |         |недоступен         |
 |       protected   |public   |protected          |
 |       public      |         |public             |
 |_________________________________________________|
 |       private     |         |недоступен         |
 |       protected   |protected|protected          |
 |       public      |         |public             |
 |_________________________________________________|
 |       private     |         |недоступен         |
 |       protected   |private  |private            |
 |       public      |         |private            |
 |_________________________________________________|

Для объектов производного класса могут быть использованы методы базового класса.Это называется правами доступа. Если в производном классе не определен конструктор,
то будет использоваться подходящий конструктор базового класса. Также, есть возможность использовать доступный метод взамен отсутствующего.Наследование не работает
 в обратном направлении и базовому классу не доступны производные методы.
    
////////////////Конструкторы производного класса
Для инициализации объекта производного класса нельзя воспользоваться конструктором базового класса. Компилятор будет использовать только конструктор базового класса 
без аргументов. Для производного класса нужно писать новые конструкторы. 

class C{
    protected:
    int a;
    char c;
    public:
    > C(int A1, char C1):a(A1), c(C1)();
    > C():A1(10), c("a"){}
}
class A: public C{
    public C;
    int B;
    public:
    set B(int B){cin >> B;}
    A(int A1, char C1):C(int A1, char C1) {}
    A():C(){}
}

В примере конструктор А(int A1, char C1) вызывет конструктор базового класса C(int A1, char C1) {}, записанный через двоеточие'


Базовый класс People
Наследники Manager, Cashier

People *mas[5]
mas[0] = new Manager();
mas[1] = new Cashier();

for(i;.;.)
(*mas[i]).Show(); --вызывается соответствующий метод

/////Базовые методы класса

Для производного класса можно определять методы, имеющие такие же имена, что и у методах базового класса.В этом случае имеет место перегрузка функций.
В случае, если метод с одним и тем же названием есть и в базовом, и в производном классе, то будет выполнен метод производного класса.Методы производного класса
получаеют доступ к методам базового класса, используя операцию разрешения(::). 

/////////Множественное наследование
Класс может быть производным от нескольких базовых классов. Форма описания следующаяя: class имя производного класса: список базовых классов{...}.
Список базовых классов содержит перечисленные через запятую классы с соответствующими режимами доступа каждому базовому классу. Пока конструкторы базовых классов не
имеют аргументов, то производный класс может не иметь функцию конструктора. Если конструктор базового класса имеет 1 или неск аргументов, то каждый производный класс
обязан иметь конструктор.Чтобы передать аргументы в базовый класс нужно определить их после объявления конструктора базового класса.

Форма записи: имя производного класса(список аргументов: базовыйКласс1(список аргументов)...базовыйКлассN(...)).

Здесь базовыйКласс1(список аргументов)...базовыйКлассN(...) 
Имена конструкторов базового класса, которые наследуются в производном классе. : отделяет имя конструктора производного класса от списка аргументов базвого класса.
Список аргументов, ассоциированный с базовым классом, может состоять из констант и переменных

//////Неопределенность при множественном наследовании
Допустим, что в обоих классах A и B с-ют методы с одинаковыми именами, а в производном классе метода с таким именем нет.Здесь проблема решается путем использования 
оператора разрешения, определяющего класс, в котором находится метод.Процесс направления в версии метода конкретного класса называется устранением неоднозначности.  
class A{...};
class B{...};
class C: public A, public B{...};

Мы создаем производный класс от двух базовых классов, которые в свою очередь являются производными одного класса.Это создает дерево наследования в форме ромба.
class A{...};
class B{...};
class C: public A, public B{...};
class D: public B, public C{...};
Трудности начинаются, когда объект класса D пытается воспользоваться методом класса А. Пусть объекту класса D необходимо воспользоваться методом Show() класса А. 
Классы B и С содержат копии метода Show(), унаследованные от класса А. Тогда компилятор не может решить какой из методов Show() использовать.

//////////////////////ЛЕКЦИЯ 7  Перегрузка операций и преобразование типов///////////////////////////////////////////

///////Перегрузка операций

Синтаксис перегрузки операторов поход на определение функции с именем operator (значок новый), где значок - это идентификатор оператора(операции).
След операции не могу быть перегружены: операции доступа к членам структуры или класса(.), операция разрешения(::), и операция условия.
Нельзя создавать новые операции и пытаться их перегрузить.Перегружать можно только существующие операции.Можно переопределить только как методы класса.
При перегрузке оператора << >> нужно отключить заголовочный файл.

//////Различные способы передачи аргументов в функцию и возвращения значений операторов:
1)Если аргумент не изменяется оператором, например, В случае арифметических операций, то его следует передавать как ссылку на константу.
2)Тип возвращаемого значения зависит от сути оператора.Если оператор должен возвращать новое значение, то необходимо создавать новый объект.
3)Для операторов присваивания(+=, -=  и тд) необходимо возвращать ссылку на измененный элемент.Логические операторы должны в худшем случае int, в лучшем bool

//////Перегрузка унарных операций
Синтаксис перегрузки унарных операций
тип_имя_класса operator #(тип_параметра операнд)
{...}

Переопределение пре- и постфиксных операторов:
имя_класса operator --()    - префиксный 
имя_класса operator --(int) - постфиксный

int это не аргумент. Это слово говорит о том, что перегружается постфиксная операция.

class Counter 
{
    private:
    unsigned int count;
    public:
    Counter():count(0){}
    *Counter(int c):count(c){}
    unsigned int getCount(){return count;}
    Counter operator++()    {return Counter(++count);} //создаем временный безымянный объект для которого требуется конструктор с одним параметром.СТрока с * обязательна
                                                        //для этой строки
    Counter operator++(int)    {return Counter(count++);}
};

int main ()
{
    Counter c1, c2;
    cout << "c1 = " << c1 << endl;
    cout << "c2 = " << c2 << endl;

    c2 = ++c1;
    cout << "c1 = " << c1.getCount << endl;
    cout << "c2 = " << c2.getCount << endl;

    c2 = c1++;
    cout << "c1 = " << c1.getCount << endl;
    cout << "c2 = " << c2.getCount << endl;

    return 0;
}

////////////////Перегрузка бинарных операций /////

Синтаксис :
тип_имя_класса operator $(Список аргументов){...}

В перегруженных бинарных операциях всегда вызывается метод левого операнда. Объект, стоящий справа от знака операции, должен быть передан в функцию в качестве аргумента

Пример перегрузки оперции сложения, комбинированного сложения
class RusSM //Русские меры длинны
{
    int arshin;
    int vershok;
    
    public:
    RusSM(): arshin(0), vershok(0){};
    RusSM(int ar, int ver)
    {
        if (ver >= 16){ver == 16; ar++;} // в одном аршине 16 вершков
        arshin = ar;
        vershok = ver;
    }
    
    void setRusSM()
    {
        cout << "Vvedite arshin: ";
        cin >> arshin;
        cout << "Vvedite vershok: ";
        cin >> vershok;
    }

    void ShowRusSM()
    {
        cout << "ar = " << arshin << "ver = " << vershok ;
    }

    RusSM operator +(RusSM d2);
    RusSM operator <(RusSM d2);
    RusSM operator +=(RusSM d2);
;}

RusSM RusSM::operator+(RusSM d2)
{
    int a = arshin + d2.arshin;
    int v = vershok + d2.vershok;
    return RusSM(a, v);
}
bool RusSM ::operator < (RusSM d2)
{
    float t1 = arshin + vershok/16;
    float t2 = d2.arshin + d2.vershok/16;
    return (t1<t2)?true:false;
}
void RusSM::operator +=(RusSM d2)
{
    arshin += d2.arshin;
    vershok += d2.vershok;
}

int main ()
{
    RusSM r1, r3, r4;
    r1.setRusSM();
    RusSM r2(3,4);
    r3 = r1 + r2;
    r1 = r1 + r2 + r4;
}

////////Преобразование типов от основного к пользовательскому и от пользовательского к основному///////

Для перехода от основного к определенному пользователем типу используется конструктор с одним аргументом(в качестве аргумента будет использоваться базовый тип)
Его называют конструктором преобразования.
Для преобразования от определенного пользователем типа к основному создается операция преобразования.

operator тип_в_который_преобразуем()
{...;return переменная нового типа;}

Операция мб вызвана явно
переменная = static_cast<тип_в_который_преобразуем>(объект);
переменная = объект; // Неявно

Унарная операция приведения типов( static_cast) 

class RusSM
{
    const float artm - 0,7112; // коэф перевода 
    int arshin; int vershok;
    RusSM()...;
    RusSM(float meters)                 // конструктор преобразования
    {
        float f_arshin = meters/artm;
        arshin = int(f_arshin);
        vershok = 16 *(f_arshin - arshin);
    }
    
    RusSM(int ar, int ver){...}
    void get(который set)RusSM(){}
    void ShowRusSM(){}
    operator float ()                   //Оператор для преобразования аршинов в метры
    {
        float f_arshin = vershok / 16;
        f_arshin = static_cast<float>(arshin);
        return f_arshin;
    }
};
int main()
{
    float meters;
    RusSM r1 = 2,55;                //вызывается конструктор переводящий метры в аршины и вершки, т.е. RusSM(float meters)
    cout << "r1 = ";
    r1.ShowRusSM();
    meters = static_cast<float>(r1);    //обратное явное преобразование
    cout << "r1 = " << meters << "metrov";
    RusSM r2(5,3);
    meters = r2;
    cout << "r2 = " << meters;
}

////////////////////////////////////////////ШАБЛОНЫ///////////////////////////////////

Определение структуры шаблона

Функция шаблона определяет общий набор операций, который будет применен к различным типам данных.Шаблоны используются для создания каркасной функции
оставляя компилятору реализацию подробностей
 
 Форма функций шаблона
 template <class тип>
 возвращаемый_тип имя_функции(список аргументов){Тело функции}
 Пользовательский тип является "держателем места"для имени типа данных, которое используется в функции. Он будет автоматически заменен компилятором на фактический 
 тип данных во время создания конкретной версии функции. Можно определить несколько типов шаблонов данных, используя список с запятыми в качестве разделителя

 template <class type1, class type2>
 void myF(type1 x, type2 y){cout << x << "-" << y<< endl;}
 void myF(int &x, int &y){cout << x << "-" << y<< endl;}
 int main()
 {
     myF(10, "asd");
     myF(-12.5, 12);
 }

/////////////Явная перегрузка функций шаблонов////////
функция шаблон перегружает себя по мере необходимости. Также можно перегрузить ее и явно.Если перегружается функция шаблон, то перегруженная функция переопределяет
функцию-шаблон для того конкретного набора типов параметров, для которого создается перегруженная функция
void myF(int &x, int &y){cout << x << "-" << y<< endl;}

////////////////////Классы шаблонов////
полезны тогда, когда класс содержит логику допускающую значительные обобщения используя классы шаблона, можно создавать классы, поддерживающие очереди, связные списки
и тд для произвольных типов данных. Компилятор автоматически создаёт корректный код, основываясь на типе данных, указанном перед компиляцией
общая форма записи класса-шаблона
template <class тип>
class имя_класса{}

при необходимости можно определить неск пользовательских типов, указывая их через запятую. При создании класса-шаблона можно создать конкретный экземпляр этого класса
используя след форму записи:
имя_класса <тип> имя_объекта

template <class MyT>
class stack
{
    MyT stck[100];
    int n;
    public:
    stack();
    ~stack();
    void push(MyT i);
    MyT pop();
};

template <class MyT>
stack <MyT>:: stack(){n = 0}

template <class MyT>
stack <MyT>:: push(Myt i)
{
    if (n == 100)
    {
        cout << "NO" << endl;
        return n;
    }
    else stck[n] = i;
    n++;
}
template <class MyT>
stack <MyT>:: pop()
{
    if(n == 0)
    {
        cout<<"NO"<<endl;
        return 0;
    }
    n--;
    return stck[n];
}

int main()
{
    stack <int> a;
    stack <double> b;
    stack <char> c;
    a.push(10);
    b.push(8.5);
    a.push(20);
    b.push(12.3)
    cout << a.pop << " " < a.pop << endl;
}


////////////////////////////ИСКЛЮЧЕНИЯ///////////////
1.Обработка исключений

Используя обработку исключений, программа может автоматически вызывать функцию-обработчик ошибок тогда, когда такая ошибка возникает.Обработка исключений использует 
3 ключевых слова: try, catch, throw(Передать); Те инструкции, в которых ожидается появление исключительных ситуаций, содержится в блоке try. Если в блоке try возникает
исключение, т.е. ошибка, то генерируется исключение, которое перехватывается используя catch.
Синтаксис:
try{...}
catch(тип1 аргумент1){...}
catch(тип2 аргумент2){...}
Одному блоку try может отвечать неск. инструкций блока catch. Какая именно инструкция catch исполняется, зависит от типа исключения.Перехваченным может быть любой 
тип данных, включая созданные программистом классы.Если никакого исключения не сгенерировано(т.е. никакой ошибки не возникло в блоке try), то инструкции catch 
выполняться не будут.Исключение мб сгенерировано из функции вызванной изнутри блока try

throw должна выполняться либо внутри блока try, либо в функции, вызванной из блока try.

Общая форма записи:
throw исключение;
Пример:
int num1, num2;
cout <<"num1 = ";cin >> num1;
cout <<"num2 = ";cin >> num2;
cout <<"num1 + num2 = " << num1 + num2 << endl;
cout <<"num1 / num2 =" ;
try{
    if(num2 == 0){throw 100;} если num2 = 0, то в num2 перейдет 100
    cout << num1/num2 << endl; 
} 
catch (int i){cout << "Нельзя делить на 0.Ошибка " << i << endl;}
cout << "num1 - num2 = " << num1 - num2 << endl;



