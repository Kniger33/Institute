{\rtf1\ansi\ansicpg\deff0\deflang1049\deflangfe1049\deftab708{\fonttbl{\f0\fswiss\fprq2\fcharset204{\*\fname Arial CYR;}Arial;}{\f1\froman\fprq2\fcharset204{\*\fname Times New Roman CYR;}Times New Roman;}{\f2\fmodern\fprq1\fcharset204{\*\fname Courier New CYR;}Courier New;}}{\info
{\title Программирование на языке Пролог для искусственного интеллекта}
{\author Иван Братко }
}{\fet0 \ftnbj \ftnrstpg \ftnnar}{\stylesheet
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Normal;}
{\s1 \qc\snext0\b\f0\fs32\fi0\li0\ri0  heading 1;}
{\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0  heading 2;}
{\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0  heading 3;}
{\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0  heading 4;}
{\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0  heading 5;}
{\s6 \qc\snext0\s6\f1\b\fs24\fi0  heading 6;}
{\s10 \qj\snext\f1\fs22\b0\i1\li3000\fi400\ri0  Epigraph;}
{\s11 \qj\snext0\f1\fs22\b1\i0\li3000\fi400\ri0  Epigraph Author;}
{\s12 \qj\snext0\f1\fs24\b0\i1\fi567\li0\ri0  Annotation;}
{\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600  Cite;}
{\s14 \qj\snext0\f1\fs22\b1\i1\li1701\ri600  Cite Author;}
{\s15 \ql\snext0\f1\fs24\b1\i0\li2000\ri600\sb12  Poem Title;}
{\s16 \ql\snext0\f1\fs24\b0\i0\li2000\ri600  Stanza;}
{\s17 \qj\snext0\f1\fs20\b0\i0\fi200\li0\ri0  FootNote;}
{\s18 \qj\snext\f1\fs18\b0\i1\li1500\fi400\ri0  FootNote Epigraph;}
{\s18 \qj\snext0\f1\fs18\b1\i0\li1500\fi400\ri0  FootNote Epigraph Author;}
{\s19 \ql\snext0\f1\fs18\b0\i0\li500\ri600  FootNote Stanza;}
{\s20 \qj\snext0\f1\fs18\b0\i0\li300\ri600  FootNote Cite;}
{\s21 \qj\snext0\f1\fs18\b1\i1\li350\ri600  FootNote Cite Author;}
{\s22 \ql\snext0\f1\fs20\b1\i0\li2000\ri600\sb12  FootNote Poem Title;}

}\paperw11906\paperh16838\margl1417\margr850\margt1134\margb1134


\s0 \f0\qc\fi0\li0\ri0 Спасибо, что скачали книгу в 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru" }}{\fldrslt \ul бесплатной электронной библиотеке Royallib.ru}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru/author/bratko_ivan.html" }}{\fldrslt \ul Все книги автора}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru/book/bratko_ivan/programmirovanie_na_yazike_prolog_dlya_iskusstvennogo_intellekta.html" }}{\fldrslt \ul Эта же книга в других форматах}}
\par
\par

\s0 \f0\qc\fi0\li0\ri0 Приятного чтения!\par
\par
\par
\par
\s1 \qc\snext0\b\f0\fs32\fi0\li0\ri0 Иван Братко \par
Программирование на языке Пролог для искусственного интеллекта\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s10 \qj\snext\f1\fs22\b0\i1\li3000\fi400\ri0 \s10 \qj\snext\f1\fs22\b0\i1\li3000\fi400\ri0 Посвящается Бранке, Андрею и Тадею\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 От редактора перевода\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По существующей традиции предисловие редактора перевода — это своего рода рецензия, в которой обычно излагается история вопроса, а затем дается обзор содержания книги и оценка ее качества (как правило, рекламного характера). В данном случае моя задача несколько упрощается, так как все это читатель, перевернув страницу, найдет в предисловии известного американского ученого, специалиста по искусственному интеллекту П. Уинстона, а затем — в предисловии автора. Мне остается только присоединиться к авторитетному мнению П. Уинстона, что перед нами прекрасно написанный учебник до Прологу, ориентированный на практическое использование в области искусственного интеллекта. Добавлю также, что для советского читателя потребность в такой книге особенно велика, поскольку в нашей стране Пролог пока еще не получил того распространения, которого он заслуживает.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Несколько замечаний относительно особенностей перевода. Кроме обычных терминологических трудностей, как правило возникающих при переводе книг по программированию, переводчикам пришлось преодолевать одну дополнительную сложность. Дело в том, что в Прологе идентификаторы (имена переменных, процедур и атомов) несут на себе значительно большую смысловую нагрузку, чем в традиционных языках программирования. Поэтому программные примеры пришлось излагать на некоей условной русской версии Пролога — в противном случае, для читателей, не владеющих английским языком, эти примеры стали бы значительно менее понятными. Мы оставили без перевода все имена встроенных операторов и процедур, все же остальные имена переводились на русский язык. Следует признать, что в ряде случаев русская версия этих имен оказалась менее эстетически привлекательной, чем исходный английский вариант. Пытаясь наиболее точно передать смысл того или иного имени, переводчик нередко оказывался перед нелегким выбором между громоздким идентификатором (иногда из нескольких слов) и неблагозвучной аббревиатурой. Впрочем, все эти проблемы хорошо известны любому "русскоязычному" программисту.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Главы 1-8 перевел А.И. Лупенко, а предисловия и главы 9-16 — А.М. Степанов. Подготовку оригинала-макета книги на ЭВМ выполнили А.H. Черных и H.Г. Черных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эту книгу можно рекомендовать как тем читателям, которые впервые приступают к изучению Пролога и искусственного интеллекта, так и программистам, уже имеющим опыт составления пролог-программ.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s14 \qj\snext0\f1\fs22\b1\i1\li1701\ri600 А. М. Степанов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Предисловие\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В средние века знание латинского и греческого языков являлось существенной частью образования любого ученого. Ученый, владеющий только одним языком, неизбежно чувствовал себя неполноценным, поскольку он был лишен той полноты восприятия, которая возникает благодаря возможности посмотреть на мир сразу с двух точек зрения. Таким же неполноценным ощущает себя сегодняшний исследователь в области искусственного интеллекта, если он не обладает основательным знакомством как с Лиспом, так и с Прологом — с этими двумя основополагающими языками искусственного интеллекта, без знания которых невозможен более широкий взгляд на предмет исследования.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сам я приверженец Лиспа, так как воспитывался в Массачусетском технологическом институте, где этот язык был изобретен. Тем не менее, я никогда не забуду того волнения, которое я испытал, увидев в действии свою первую программу, написанную в прологовском стиле. Эта программа была частью знаменитой системы Shrdlu Терри Винограда. Решатель задач, встроенный в систему, работал в "мире кубиков" и заставлял руку робота (точнее, ее модель) перемещать кубики на экране дисплея, решая при этом хитроумные задачи, поставленные оператором.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решатель задач Винограда был написан на Микропленнере, языке, который, как мы теперь понимаем, был своего рода Прологом в миниатюре. Любой прологоподобный язык заставляет программиста мыслить в терминах целей, поэтому, несмотря на все недостатки Микропленнера, достоинством этой программы было то, что в ее структуре содержались многочисленные явные указания на те или иные цели. Процедуры-цели "схватить", "освободить", "избавиться", "переместить", "отпустить" и т.п. делали программу простой и компактной, а поведение ее казалось поразительно разумным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решатель задач Винограда навсегда изменил мое программистское мышление. Я даже переписал его на Лиспе и привел в своем учебнике по Лиспу в качестве примера — настолько эта программа всегда поражала меня мощью заложенной в ней философии "целевого" программирования, да и само программирование в терминах целей всегда доставляло мне удовольствие.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако учиться целевому программированию на примерах лисповских программ — это все равно, что читать Шекспира на языке, отличном от английского. Какое-то впечатление вы получите, но сила эстетического воздействия будет меньшей, чем при чтении оригинала. Аналогично этому, лучший способ научиться целевому программированию — это читать и писать программы на Прологе, поскольку сама сущность Пролога как раз и состоит в программировании в терминах целей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В самом широком смысле слова эволюция языков программирования — это движение от языков низкого уровня, пользуясь которыми, программист описывает, \i как\i0   что-либо следует делать, к языкам высокого уровня, на которых просто указывается, \i что\i0   необходимо сделать. Так, например, появление Фортрана освободило программистов от необходимости разговаривать с машиной на прокрустовом языке адресов и регистров. Теперь они уже могли говорить на своем (или почти на своем) языке, только изредка делая уступки примитивному миру 80-колонных перфокарт.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако Фортран и почти все другие языки программирования все еще остаются языками типа "как". И чемпионом среди этих языков является, пожалуй, современный модернизированный Лисп. Так, скажем, Common Lisp, имея богатейшие выразительные возможности, разрешает программисту описывать наиболее "выразительно" именно то, \i как\i0   что-либо следует делать. В то же время очевидно, что Пролог порывает с традициями языков типа "как", поскольку он определенным образом направляет программистское мышление, заставляя программиста давать определения ситуаций и формулировать задачи вместо того, чтобы во всех деталях описывать способ решения этих задач.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отсюда следует, насколько важен вводный курс по Прологу для всех студентов, изучающих вычислительную технику и программирование — просто не существует лучшего способа понять, что из себя представляет программирование типа "что".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Многие страницы этой книги могут служить хорошей иллюстрацией того различия, которое существует между этими двумя стилями программистского мышления. Например, в первой главе это различие иллюстрируется на задачах, относящихся к семейным отношениям. Прологовский программист дает простое и естественное описание понятия "дедушка": дедушка — это отец родителя. На Прологе это выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дедушка( X, Z) :- отец( X, Y), родитель( Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как только пролог-система узнала, что такое дедушка, ей можно задать вопрос, например: кто является дедушкой Патрика? В обозначениях Пролога этот вопрос и типичный ответ имеют вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  дедушка( X, патрик).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = джеймс;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = карл.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каким образом решать эту задачу, как "прочесывать" базу данных, в которой записаны все известные отношения "отец" и "родитель", — это уже забота самой пролог-системы. Программист только сообщает системе то, что ему известно, и задает вопросы. Его в большей степени интересуют знания и в меньшей — алгоритмы, при помощи которых из этих знаний извлекается нужная информация.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поняв, что очень важно научиться Прологу, естественно задать себе следующий вопрос — как это сделать. Я убежден, что изучение языка программирования во многом сходно с изучением естественного языка. Так, например, в первом случае может пригодиться инструкция по программированию точно так же, как во втором — словарь. Но никто не изучает язык при помощи словаря, так как слова — это только часть знаний, необходимых для овладения языком. Изучающий язык должен кроме того узнать те соглашения, следуя которым, можно получать осмысленные сочетания слов, а затем научиться у мастеров слова искусству литературного стиля.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Точно так же, никто не изучает язык программирования, пользуясь только инструкцией по программированию, так как в инструкциях очень мало или вообще ничего не говорится о том, как хорошие программисты используют элементарные конструкции языка. Поэтому необходим учебник, причем лучшие учебники обычно предлагают читателю богатый набор примеров. Ведь в хороших примерах сконцентрирован опыт лучших программистов, а именно на опыте мы, в основном, и учимся.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой книге первый пример появляется уже на первой странице, а далее на читателя как из рога изобилия обрушивается поток примеров прологовских программ, написанных программистом-энтузиастом, горячим приверженцем прологовской идеологии программирования. После тщательного изучения этих примеров читатель не только узнает, как "работает" Пролог, но и станет обладателем личной коллекции программ-прецедентов, готовых к употреблению: он может разбирать эти программы на части, приспосабливать каждую часть к своей задаче, а затем снова собирать их вместе, получая при этом новые программы. Такое усвоение предшествующего опыта можно считать первым шагом на пути от новичка к программисту-мастеру.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Изучение хороших программных примеров дает, как правило, один полезный побочный эффект: мы узнаем из них не только очень многое о самом программировании, но и кое-что - о какой-нибудь интересной научной области. В данной книге такой научной областью, стоящей за большинством примеров, является искусственный интеллект. Читатель узнает о таких идеях в области автоматического решения задач, как сведение задач к подзадачам, прямое и обратное построение цепочки рассуждений, ответы на вопросы "как" и "почему", а также разнообразные методы поиска.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одним из замечательных свойств Пролога является то, что это достаточно простой язык, и студенты могли бы использовать его непосредственно в процессе изучения вводного курса по искусственному интеллекту. Я не сомневаюсь, что многие преподаватели включат эту книгу в свои курсы искусственного интеллекта с тем, чтобы студенты смогли увидеть, как при помощи Пролога абстрактные идеи приобретают конкретные и действенные формы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Полагаю, что среди учебников по Прологу эта книга окажется особенно популярной, и не только из-за своих хороших примеров, но также из-за целого ряда других своих привлекательных черт:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • тщательно составленные резюме появляются на всем протяжении книги;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • все вводимые понятия подкрепляются многочисленными упражнениями;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • процедуры выборки элементов структур подводят нас к понятию абстракции данных;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • обсуждение вопросов стиля и методологии программирования занимает целую главу;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • автор не только показывает приятные свойства языка, но и со всей откровенностью обращает наше внимание на трудные проблемы, возникающие при программировании на Прологе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все это говорит о том, что перед нами прекрасно написанная, увлекательная и полезная книга.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s14 \qj\snext0\f1\fs22\b1\i1\li1701\ri600 Патрик Г. Уинстон\par
\s14 \qj\snext0\f1\fs22\b1\i1\li1701\ri600 Кеймбридж, Массачусетс \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Предисловие автора \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Язык программирования Пролог базируется на ограниченном наборе механизмов, включающих в себя сопоставление образцов, древовидное представление структур данных и автоматический возврат. Этот небольшой набор образует удивительно мощный и гибкий программный аппарат. Пролог особенно хорошо приспособлен для решения задач, в которых фигурируют объекты (в частности, структуры) и отношения между ними. Например, в качестве легкого упражнения, можно попробовать выразить на Прологе пространственные отношения между объектами, изображенными на обложке этой книги. Пример такого отношения: верхний шар расположен дальше, чем левый шар. Нетрудно также сформулировать и более общее положение в виде следующего правила: если X ближе к наблюдателю, чем Y, a Y — ближе, чем Z, то объект X находится ближе, чем Z. Пользуясь правилами и фактами, пролог-система может проводить рассуждения относительно имеющихся пространственных отношений и, в частности, проверить, насколько они согласуются с вышеуказанным общим правилом. Все эти возможности придают Прологу черты мощного языка для решения задач искусственного интеллекта, а также любых задач, требующих нечислового программирования.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Само название \i Пролог\i0   есть сокращение, означающее \i программирование в терминах логики\i0  . Идея использовать логику в качестве языка программирования возникла впервые в начале 70-x годов. Первыми исследователями, разрабатывавшими эту идею, были Роберт Ковальский из Эдинбурга (теоретические аспекты), Маартен ван Эмден из Эдинбурга (экспериментальная демонстрационная система) и Ален Колмероэ из Марселя (реализация). Сегодняшней своей популярности Пролог во многом обязан эффективной реализации этого языка, полученной в Эдинбурге Дэвидом Уорреном в середине 70-x годов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поскольку Пролог уходит своими корнями в математическую логику, его преподавание часто начинают с изложения логики. Однако такое введение в Пролог, насыщенное математическими понятиями, приносит мало пользы в том случае, когда Пролог изучается в качестве практического инструмента программирования. Поэтому в данной книге мы не будем заниматься математическими аспектами этого языка, вместо этого мы сосредоточим свое внимание на навыках использования базовых механизмов Пролога, для решения целого ряда содержательных задач. В то время, как традиционные языки программирования являются процедурно-ориентированными, Пролог основан на описательной или \i декларативной\i0   точке зрения на программирование. Это свойство Пролога коренным образом меняет программистское мышление и делает обучение программированию на Прологе увлекательным занятием, требующим определенных интеллектуальных усилий.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В первой части книги содержится введение в Пролог, в ней показано, как составлять программы на Прологе. Во второй части демонстрируется, как мощные средства языка применяются в некоторых областях искусственного интеллекта, таких как, например, решение задач, эвристический поиск, экспертные системы, машинные игры и системы, управляемые образцами. В этой части излагаются фундаментальные методы в области искусственного интеллекта. Далее они прорабатываются достаточно глубоко для того, чтобы реализовать их на Прологе и получить готовые программы. Эти программы можно использовать в качестве "кирпичиков" для построения сложных прикладных систем. В книге рассматриваются также вопросы обработки таких сложных структур данных, как графы и деревья, хотя эти вопросы, строго говоря, и не имеют прямого отношения к искусственному интеллекту. В программах искусственного интеллекта методы обработки структур применяются довольно часто, и, реализуя их, читатель приобретет самые общие навыки программирования на Прологе. В книге особое внимание уделяется простоте и ясности составляемых программ. Повсеместно мы стремились избегать программистских "хитростей", повышающих эффективность за счет учета особенностей конкретной реализации Пролога.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта книга предназначена для тех, кто изучает Пролог и искусственный интеллект. Материал книги можно использовать в курсе лекций по искусственному интеллекту, ориентированном на прологовскую реализацию. Предполагается, что читатель имеет общее представление о вычислительных машинах, но предварительные знания в области искусственного интеллекта необязательны. От читателя не требуется также какого-либо программистского опыта. Дело в том, что богатый программистский опыт вместе с приверженностью к традиционному процедурному программированию (например, на Паскале) может стать помехой при изучении Пролога, требующего свежего программистского мышления.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Среди различных диалектов Пролога наиболее широко распространен так называемый эдинбургский синтаксис (или синтаксис DEC-10), который мы я принимаем в данной книге. Для того, чтобы обеспечить совместимость с различными реализациями Пролога, мы используем в книге сравнительно небольшое подмножество встроенных средств, имеющихся во многих вариантах Пролога.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как читать эту книгу? В первой части порядок чтения естественным образом совпадает с порядком изложения, принятым в книге. Впрочем, часть разд. 2.4, в которой дается более формальное описание процедурной семантики Пролога, можно опустить. В главе 4 приводятся примеры программ, которые можно читать только выборочно. Вторая часть книги допускает более гибкий порядок чтения, поскольку различные главы этой части предполагаются взаимно независимыми. Однако некоторые из тем было бы естественным прочесть раньше других - это относится к основным понятиям, связанным со структурами данных (гл. 9), и к базовым стратегиям поиска (гл. 11 и 13). В приведенной ниже диаграмме показана наиболее естественная последовательность чтения глав.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \qc\par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует целый ряд исторически сложившихся и противоречащих друг другу взглядов на Пролог. Пролог быстро завоевал популярность в Европе как практический инструмент программирования. В Японии Пролог оказался в центре разработки компьютеров пятого поколения. С другой стороны, в связи с определенными историческими факторами, в США Пролог получил признание несколько позднее. Один из этих факторов был связан с предварительным знакомством с Микропленнером, языком, близким к логическому программированию, но реализованным не эффективно. Этот отрицательный опыт, относящийся к Микропленнеру, был неоправданно распространен и на Пролог, но позднее, после появления эффективной реализации, предложенной Дэвидом Уорреном, это предубеждение было убедительно снято. Определенная сдержанность по отношению к Прологу объяснялась также существованием "ортодоксальной школы" логического программирования, сторонники которой настаивали на использовании чистой логики, не запятнанной добавлением практически полезных внелогических средств. Практикам в области применения Пролога удалось изменить эту бескомпромиссную позицию и принять более прагматический подход, позволивший удачно сочетать декларативный принцип с традиционным - процедурным. И наконец, третьим фактором, приведшим к задержке признания Пролога, явилось то обстоятельство, что в США в течение долгого времени Лисп не имел серьезных конкурентов среди языков искусственного интеллекта. Понятно поэтому, что в исследовательских центрах с сильными лисповскими традициями возникало естественное противодействие Прологу. Но со временем соперничество между Прологом и Лиспом потеряло свою остроту, и в настоящее время многие считают, что оптимальный подход состоит в сочетании идей, лежащих в основе этих двух языков.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Благодарности\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Интерес к Прологу впервые возник у меня под влиянием Дональда Мики. Я благодарен также Лоренсу Берду, Фернандо Перейра и Дэвиду Г. Уоррену, входившим в свое время в эдинбургскую группу разработчиков Пролога, за их советы по составлению программ и многочисленные дискуссии. Чрезвычайно полезными были замечания и предложения, высказанные Эндрью Макгеттриком и Патриком Уинстоном. Среди прочитавших рукопись книги и сделавших ценные замечания были также Игорь Кононенко, Таня Маярон, Игорь Мозетик, Тимоти Ниблетт и Фрэнк Зердин. Мне бы хотелось также поблагодарить Дебру Майсон-Этерингтон и Саймона Пламтри из издательства Эддисон-Уэсли за труд, вложенный в издание этой книги. И наконец, эта книга не могла бы появиться на свет без стимулирующего влияния творческой деятельности всего международного сообщества специалистов по логическому программированию.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s14 \qj\snext0\f1\fs22\b1\i1\li1701\ri600 Иван Братко\par
\s14 \qj\snext0\f1\fs22\b1\i1\li1701\ri600 Институт Тьюринга, Глазго\par
\s14 \qj\snext0\f1\fs22\b1\i1\li1701\ri600 Январь 1986 \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Часть 1\par
Язык Пролог\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\qc\par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 1\par
Общий обзор языка Пролог\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой главе на примере конкретной программы рассматриваются основные механизмы Пролога. Несмотря на то, что материал излагается в основном неформально, здесь вводятся многие важные понятия.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 1.1. Пример программы: родственные отношения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пролог — это язык программирования, предназначенный для обработки символьной нечисловой информации. Особенно хорошо он приспособлен для решения задач, в которых фигурируют объекты и отношения между ними. На рис. 1.1 представлен пример — родственные отношения. Тот факт, что Том является родителем Боба, можно записать на Прологе так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( том, боб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь мы выбрали родитель в качестве имени отношения, том и боб — в качестве аргументов этого отношения. По причинам, которые станут понятны позднее, мы записываем такие имена, как том, начиная со строчной буквы. Все дерево родственных отношений рис. 1.1 описывается следующей пролог-программой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( пам, боб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( том, боб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( том, лиз).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( боб, энн).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( боб, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( пам, джим).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 1.1.\b0    Дерево родственных отношений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта программа содержит шесть \i предложений\i0  . Каждое предложение объявляет об одном факте наличия отношения родитель.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После ввода такой программы в пролог-систему последней можно будет задавать вопросы, касающиеся отношения \b \b родитель\b0  \b0  . Например, является ли Боб родителем Пат? Этот вопрос можно передать пролог-системе, набрав на клавиатуре терминала:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  родитель( боб, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Найдя этот факт в программе, система ответит\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes         (да)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другим вопросом мог бы быть такой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  родитель( лиз, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Система ответит\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no             (нет),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 поскольку в программе ничего не говорится о том, является ли Лиз родителем Пат. Программа ответит "нет" и на вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  родитель( том, бен).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 потому, что имя Бен в программе даже не упоминается.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно задавать и более интересные вопросы. Например:"Кто является родителем Лиз?"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  родитель( X, лиз).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На этот раз система ответит не просто "да" или "нет". Она скажет нам, каким должно быть значение X (ранее неизвестное), чтобы вышеприведенное утверждение было истинным. Поэтому мы получим ответ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  том\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вопрос "Кто дети Боба?" можно передать пролог-системе в такой форме:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  родитель( боб, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом случае возможно несколько ответов. Сначала система сообщит первое решение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  энн\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возможно, мы захотим увидеть и другие решения. О нашем желании мы можем сообщить системе (во многих реализациях для этого надо набрать точку с запятой), и она найдет другой ответ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  пат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы потребуем дальнейших решений, система ответит "нет", поскольку все решения исчерпаны.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нашей программе можно задавать и более общие вопросы: "Кто чей родитель?" Приведем другую формулировку этого вопроса:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Найти X и Y такие, что X — родитель Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На Прологе это записывается так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Система будет по очереди находить все пары вида "родитель-ребенок". По мере того, как мы будем требовать от системы новых решений, они будут выводиться на экран одно за другим до тех пор, пока все они не будут найдены. Ответы выводятся следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  пам\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y  =  боб;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  том\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y  =  боб;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  том\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y  =  лиз;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем остановить поток решений, набрав, например, точку вместо точки с запятой (выбор конкретного символа зависит от реализации).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нашей программе можно задавать и еще более сложные вопросы, скажем, кто является родителем родителя Джима? Поскольку в нашей программе прямо не сказано, что представляет собой отношение родительродителя, такой вопрос следует задавать в два этапа, как это показано на рис. 1.2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1)    Кто родитель Джима?   Предположим, что это некоторый Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2)    Кто родитель Y?   Предположим, что это некоторый X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такой составной вопрос на Прологе записывается в виде последовательности двух простых вопросов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  родитель( Y, джим), родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответ будет:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  боб\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y  =  пат\par
\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 1.2.\b0   Отношение родительродителя, выраженное через композицию двух отношений родитель.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наш составной вопрос можно интерпретировать и так: "Найти X и Y, удовлетворяющие следующим двум требованиям":\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( Y, джим) и родитель( X, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы поменяем порядок этих двух требований, то логический смысл останется прежним:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( X, Y) и родитель( Y, джим)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот вопрос можно задать нашей пролог-системе и в такой форме:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  родитель( X, Y), родитель( Y, джим).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При этом результат будет тем же. Таким же образом можно спросить: "Кто внуки Тома?"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  родитель( том, X), родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Система ответит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  боб\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y  =  энн;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  боб\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y  =  пат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующим вопросом мог бы быть такой: "Есть ли у Энн и Пат общий родитель?" Его тоже можно выразить в два этапа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1)    Какой X является родителем Энн?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2)    Является ли (тот же) X родителем Пат?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Соответствующий запрос к пролог-системе будет тогда выглядеть так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  родитель( X, энн), родитель( X, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  боб\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша программа-пример помогла проиллюстрировать некоторые важные моменты:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • На Прологе легко определить отношение, подобное отношению родитель, указав \i n\i0  -ку объектов, для которых это отношение выполняется.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Пользователь может легко задавать пролог-системе вопросы, касающиеся отношений, определенных в программе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Пролог-программа состоит из предложений. Каждое предложение заканчивается точкой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Аргументы отношения могут быть (среди прочего): конкретными объектами, или константами (такими, как том и энн), или абстрактными объектами, такими, как X и Y. Объекты первого типа называются \i атомами\i0  . Объекты второго типа — \i переменными\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Вопросы к системе состоят из одного или более целевых утверждений (или кратко \i целей\i0  ). Последовательность целей, такая как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( X, энн), родитель( X, пат)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает конъюнкцию этих целевых утверждений:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  —  родитель Энн \i   и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  —  родитель Пат.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пролог-система рассматривает вопросы как цели, к достижению которых нужно стремиться.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Ответ на вопрос может оказаться или положительным или отрицательным в зависимости от того, может ли быть соответствующая цель достигнута или нет. В случае положительного ответа мы говорим, что соответствующая цель \i достижима\i0   и \i успешна\i0  . В противном случае цель \i   недостижима\i0  , \i   имеет неуспех\i0     или   \i терпит неудачу\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Если на вопрос существует несколько ответов, пролог-система найдет столько из них, сколько пожелает пользователь.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.1.\b0   Считая, что отношение родитель определено так же, как и раньше в данном разделе (см. рис. 1.1), найдите, какими будут ответы пролог-системы на следующие вопросы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a)  ?-  родитель( джим, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b)  ?-  родитель( X, джим).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c)  ?-  родитель( пам,X), родитель( X, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d)  ?-  родитель( пам, X), родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        родитель( Y, джим).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.2.\b0    Сформулируйте на Прологе следующие вопросы об отношении родитель:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a)  Кто родитель Пат?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b)  Есть ли у Лиз ребенок?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c)  Кто является родителем родителя Пат? \par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 1.2. Расширение программы-примера с помощью правил\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нашу программу-пример можно легко расширить многими интересными способами. Давайте сперва добавим информацию о том, каков пол людей, участвующих в отношении родитель. Это можно сделать, просто добавив в нее следующие факты:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 женщина( пам).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мужчина( том).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мужчина( боб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 женщина( лиз).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 женщина( пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 женщина( энн).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мужчина( джим).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы ввели здесь два новых отношения — мужчина и женщина. Эти отношения — унарные (или одноместные). Бинарное отношение, такое как родитель, определяет отношение между \i двумя\i0   объектами; унарные же можно использовать для объявления наличия (отсутствия) простых свойств у объектов. Первое из приведенных выше предложений читается так: Пам — женщина. Можно было бы выразить информацию, представляемую этими двумя унарными отношениями (мужчина и женщина), по-другому - с помощью одного бинарного отношения пол. Тогда новый фрагмент нашей программы выглядел бы так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пол( пам, женский).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пол( том, мужской).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пол( боб, мужской).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве дальнейшего расширения нашей программы-примера давайте введем отношение отпрыск, которое обратно отношению родитель. Можно было бы определить отпрыск тем же способом, что и родитель, т.е. представив список простых фактов наличия этого отношения для конкретных пар объектов, таких, что один является отпрыском другого. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отпрыск( лиз, том).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако это отношение можно определить значительно элегантнее, использовав тот факт, что оно обратно отношению родитель, которое уже определено. Такой альтернативный способ основывается на следующем логическом утверждении:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для всех X и Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Y является отпрыском X, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X является родителем Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта формулировка уже близка к формализму, принятому в Прологе. Вот соответствующее прологовское предложение, имеющее тот же смысл:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отпрыск( Y, X) :- родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это предложение можно прочитать еще и так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для всех X и Y,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   если X — родитель Y, то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   Y — отпрыск X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такие предложения Пролога, как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отпрыск( Y, X) :- родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 называются \i правилами\i0  . Есть существенное различие между фактами и правилами. Факт, подобный факту\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( том, лиз).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 это нечто такое, что всегда, безусловно истинно. Напротив, правила описывают утверждения, которые могут быть истинными, только если выполнено некоторое условие. Поэтому можно сказать, что правила имеют\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • условную часть (правая половина правила) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • часть вывода (левая половина правила).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вывод называют также \i головой\i0   предложения, а условную часть — его \i телом\i0  . Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отпрыск( Y, X) :- родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i голова            тело\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если условие родитель( X, Y) выполняется (оно истинно), то логическим следствием из него является утверждение отпрыск( Y, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На приведенном ниже примере проследим, как в действительности правила используются Прологом. Спросим нашу программу, является ли Лиз отпрыском Тома:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- отпрыск( лиз, том).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В программе нет фактов об отпрысках, поэтому единственный способ ответить на такой вопрос — это применить правило о них. Правило универсально в том смысле, что оно применимо к любым объектам X и Y, следовательно, его можно применить и к таким конкретным объектам, как лиз и том. Чтобы это сделать, нужно вместо Y подставить в него лиз, а вместо X — том. В этом случае мы будем говорить, что переменные X и Y конкретизируются:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = том и Y = лиз\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После конкретизации мы получаем частный случай нашего общего правила. Вот он:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отпрыск( лиз, том) :- родитель( том, лиз).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Условная часть приняла вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( том, лиз)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь пролог-система попытается выяснить, выполняется ли это условие (является ли оно истинным). Для этого исходная цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отпрыск( лиз, том)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 заменяется подцелью\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( том, лиз)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта (новая) цель достигается тривиально, поскольку такой факт можно найти в нашей программе. Это означает, что утверждение, содержащееся в выводе правила, также истинно, и система ответит на вопрос yes (да).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Добавим теперь в нашу программу-пример еще несколько родственных отношений. Определение отношения мать может быть основано на следующем логическом утверждении:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для всех X и Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   X является матерью Y, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   X является родителем Y и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   X — женщина.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На Пролог это переводится в виде такого правила:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мать( X, Y) :- родитель( X, Y), женщина( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Запятая между двумя условиями указывает на конъюнкцию условий. Это означает, что они должны быть выполнены оба одновременно.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 1.3.\b0    Графы отношений родительродителя, мать и отпрыск, определенных через другие отношения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такие отношения как родитель, отпрыск и мать можно изобразить в виде диаграмм, приведенных на рис. 1.3. Они нарисованы с учетом следующих соглашений. Вершины графа соответствуют объектам, т.е. аргументам отношений. Дуги между вершинами соответствуют бинарным (двуместным) отношениям. Дуги направлены от первого аргумента к второму. Унарные отношения на диаграмме изображаются просто пометкой соответствующих объектов именем отношения. Отношения, определяемые через другие отношения, представлены штриховыми дугами. Таким образом, любую диаграмму следует понимать так: если выполнены отношения, изображенные сплошными дугами, тогда и отношение, изображенное штриховой дугой, тоже выполнено. В соответствии с рис. 1.3, отношение родительродителя можно сразу записать на Прологе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родительродителя( X, Z) :- родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                            родитель( Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь уместно сделать несколько замечаний о внешнем виде нашей программы. Пролог дает почти полную свободу расположения текста на листе. Так что можно вставлять пробелы и переходить к новой строке в любом месте текста по вкусу. Вообще мы хотим сделать так, чтобы наша программа имела красивый и аккуратный вид, а самое главное, легко читалась. Для этого мы часто будем помещать голову предложения и каждую цель на отдельной строке. При этом цели мы будем писать с отступом, чтобы сделать разницу между головой и целями более заметной. Например, правило родительродителя в соответствии с этими соглашениями запишется так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родительродителя( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 1.4 показано отношение сестра:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для любых X и Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   X является сестрой Y, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   (1)  у X и Y есть общий родитель, и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   (2)  X — женщина.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 1.4.\b0   Определение отношения сестра.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Граф на рис. 1.4 можно перевести на Пролог так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сестра( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Z, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Z, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  женщина( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание на способ, с помощью которого выражается требование "у X и Y есть общий родитель". Была использована следующая логическая формулировка: "некоторый Z должен быть родителем X и \i этот же самый\i0   Z должен быть родителем Y". По-другому, менее красиво, можно было бы сказать так: "Z1 - родитель X, Z2 - родитель Y и Z1 равен Z2".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь можно спросить:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- сестра( энн, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как и ожидается, ответ будет "yes" (да) (см. рис. 1.1). Мы могли бы заключить отсюда, что определенное нами отношение сестра работает правильно. Тем не менее в нашей программе есть маленькое упущение, которое обнаружится, если задать вопрос: "Кто является сестрой Пат?"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  сестра( X, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Система найдет два ответа, один из которых может показаться неожиданным:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = энн;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = пат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Получается, что Пат — сестра себе самой?! Наверное, когда мы определяли отношение сестра, мы не имели этого ввиду. Однако ответ Пролога совершенно логичен, поскольку он руководствовался нашим правилом, а это правило ничего не говорит о том, что, если X — сестра Y, то X и Y не должны совпадать. Пролог (с полным правом) считает, что X и Y могут быть одним и тем же объектом и в качестве следствия из этого делает вывод, что любая женщина, имеющая родителя, является сестрой самой себе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы исправить наше правило о сестрах, его нужно дополнить утверждением, что X и Y должны различаться. В следующих главах мы увидим, как это можно сделать, в данный же момент мы предположим, что отношение различны уже известно пролог-системе и что цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 различны( X, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 достигается тогда и только тогда, когда X и Y не равны. Усовершенствованное правило для отношения сестра примет тогда следующий вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сестра( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Z, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родители( Z, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  женщина( X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  различны( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Некоторые важные моменты этого раздела:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Пролог-программы можно расширять, добавляя в них новые предложения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Прологовские предложения бывают трех типов: \i факты\i0  , \i правила \i0  и \i вопросы\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Факты\i0   содержат утверждения, которые являются всегда, безусловно верными.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Правила\i0   содержат утверждения, истинность которых зависит от некоторых условий.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • С помощью \i вопросов\i0   пользователь может спрашивать систему о том, какие утверждения являются истинными.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Предложения Пролога состоят из \i головы \i0  и \i тела\i0  . Тело — это список \i целей\i0  , разделенных запятыми. Запятая понимается как конъюнкция.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Факты — это предложения, имеющие пустое тело. Вопросы имеют только тело. Правила имеют голову и (непустое) тело.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • По ходу вычислений вместо переменной может быть подставлен другой объект. Мы говорим в этом случае, что переменная \i конкретизирована\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предполагается, что на переменные действует квантор всеобщности, читаемый как "для всех…". Однако для переменных, появляющихся только в теле, возможны и другие формулировки. Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеетребенка( X) :- родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно прочитать двумя способами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (а) \i Для всех\i0   X и Y,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      если X — отец Y, то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      X имеет ребенка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (б) \i Для всех\i0   X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      X имеет ребенка, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      существует \i некоторый\i0   Y, такой, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      X — родитель Y.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.3.\b0   Оттранслируйте следующие утверждения в правила на Прологе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) Всякий, кто имеет ребенка, — счастлив (введите одноаргументное отношение счастлив).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) Всякий X, имеющий ребенка, у которого есть сестра, имеет двух детей (введите новое отношение иметьдвухдетей).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.4.\b0   Определите отношение внук, используя отношение родитель. Указание: оно будет похоже на отношение родительродителя (см. рис. 1.3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.5.\b0   Определите отношение тетя( X, Y) через отношение родитель и сестра. Для облегчения работы можно сначала изобразить отношение тетя в виде диаграммы по типу тех, что изображены на рис. 1.3. \par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 1.3. Рекурсивное определение правил\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте добавим к нашей программе о родственных связях еще одно отношение — \b предок\b0  . Определим его через отношение родитель. Все отношение можно выразить с помощью двух правил. Первое правило будет определять непосредственных (ближайших) предков, а второе — отдаленных. Будем говорить, что некоторый является отдаленным предком некоторого Z, если между X и Z существует цепочка людей, связанных между собой отношением родитель-ребенок, как показано на рис.1.5. В нашем примере на рис. 1.1 Том — ближайший предок Лиз и отдаленный предок Пат.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 1.5.\b0   Пример отношения предок: (а) X — \i ближайший\i0   предок Z; (b) X — отдаленный предок Z.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первое правило простое и его можно сформулировать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для всех X и Z,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   X — предок Z, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   X — родитель Z.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это непосредственно переводится на Пролог как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Второе правило сложнее, поскольку построение цепочки отношений родитель может вызвать некоторые трудности. Один из способов определения отдаленных родственников мог бы быть таким, как показано на рис. 1.6. В соответствии с ним отношение предок определялось бы следующим множеством предложений:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Z).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Y, Z).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Yl, Y2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Y2, Z).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Y1, Y2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Y2, Y3),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Y3, Z).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 1.6.\b0   Пары предок-потомок, разделенных разным числом поколений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта программа длинна и, что более важно, работает только в определенных пределах. Она будет обнаруживать предков лишь до определенной глубины фамильного дерева, поскольку длина цепочки людей между предком и потомком ограничена длиной наших предложений в определении отношения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует, однако, корректная и элегантная формулировка отношения предок — корректная в том смысле, что будет работать для предков произвольной отдаленности. Ключевая идея здесь — определить отношение предок через него самого. Рис 1.7 иллюстрирует эту идею:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для всех X и Z,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   X — предок Z, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  существует Y, такой, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (1)  X — родитель Y и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (2)  Y — предок Z.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предложение Пролога, имеющее тот же смысл, записывается так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы построили полную программу для отношения предок, содержащую два правила: одно для ближайших предков и другое для отдаленных предков. Здесь приводятся они оба вместе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Z).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Y, Z).\par
\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 1.7.\b0    Рекурсивная формулировка отношения предок.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ключевым моментом в данной формулировке было использование самого отношения предок в его определении. Такое определение может озадачить - допустимо ли при определении какого-либо понятия использовать его же, ведь оно определено еще не полностью. Такие определения называются \i рекурсивными\i0  . Логически они совершенно корректны и понятны; интуитивно это ясно, если посмотреть на рис. 1.7. Но будет ли в состоянии пролог-система использовать рекурсивные правила? Оказывается, что пролог-система очень легко может обрабатывать рекурсивные определения. На самом деле, рекурсия — один из фундаментальных приемов программирования на Прологе. Без рекурсии с его помощью невозможно решать задачи сколько-нибудь ощутимой сложности.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возвращаясь к нашей программе, можно теперь задать системе вопрос: "Кто потомки Пам?" То есть: "Кто тот человек, чьим предком является Пам?"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  предок( пам, X).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  боб;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  энн;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  пат;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  джим\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответы системы, конечно, правильны, и они логически вытекают из наших определений отношений предок и родитель. Возникает, однако, довольно важный вопрос: "\i Как\i0   в действительности система использует программу для отыскания этих ответов?"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Неформальное объяснение того, как система это делает, приведено в следующем разделе. Но сначала давайте объединим все фрагменты нашей программы о родственных отношениях, которая постепенно расширялась по мере того, как мы вводили в нее новые факты и правила. Окончательный вид программы показан на рис. 1.8.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При рассмотрении рис. 1.8 следует учесть два новых момента: первый касается понятия "процедура", второй — комментариев в программах. Программа, приведенная на рис. 1.8, определяет несколько отношений — родитель, мужчина, женщина, предок и т.д. Отношение предок, например, определено с помощью двух предложений. Будем говорить, что эти два предложения входят в состав отношения предок. Иногда бывает удобно рассматривать в целом все множество предложений, входящих в состав одного отношения. Такое множество называется \i процедурой\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( пам, боб). % Пам - родитель Боба\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( том, боб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( том, лиз).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( бoб, энн).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( боб, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( пат, джим).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 женщина( пам).       % Пам - женщина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мужчина( том).       % Том - мужчина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мужчина( боб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 женщина( лиз).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 женщина( энн).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 женщина( пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мужчина( джим).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отпрыск( Y, X) :-    % Y - отпрыск X, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y).    % X - родитель Y\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мать( X, Y) :-       % X - мать Y, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y),    % X - родитель Y и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  женщина( X).        % X - женщина\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родительродителя( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % X - родитель родителя Z, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y),    % X - родитель Y и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Y, Z).    % Y - родитель Z\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сестра( X, Y) :-     % X - сестра Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Z, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Z, Y)     % X и Y имеют общего родителя\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  женщина( X, Y),     % X - женщина и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  различны( X, Y).    % X отличается от Y\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-     % Правило пр1:  X - предок Z\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-     % Правило пр2:  X - предок Z\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 1.8.\b0   Программа о родственных отношениях.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 1.8 два предложения, входящие в состав отношения предок, выделены именами "пр1" и "пр2", добавленными в программу в виде \i комментариев\i0  . Эти имена будут использоваться в дальнейшем для ссылок на соответствующие правила. Вообще говоря, комментарии пролог-системой игнорируются. Они нужны лишь человеку, который читает программу. В Прологе комментарии отделяются от остального текста программы специальными скобками "/*" и "*/". Таким образом, прологовский комментарий выглядит так\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* Это комментарий */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другой способ, более практичный для коротких комментариев, использует символ процента %. Все, что находится между % и концом строки, расценивается как комментарии:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Это тоже комментарий\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.6.\b0   Рассмотрим другой вариант отношения предок:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Y, Z),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Верно ли и такое определение? Сможете ли Вы изменить диаграмму на рис. 1.7 таким образом, чтобы она соответствовала новому определению?\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 1.4. Как пролог-система отвечает на вопросы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В данном разделе приводится неформальное объяснение того, \i как\i0   пролог-система отвечает на вопросы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вопрос к системе — это всегда последовательность, состоящая из одной или нескольких целей. Для того, чтобы ответить на вопрос, система пытается достичь всех целей. Что значит достичь цели? Достичь цели — это значит показать, что утверждения, содержащиеся в вопросе, истинны в предположении, что все отношения программы истинны. Другими словами, достичь цели - это значит показать, что она \i логически\i0   следует из фактов и правил программы. Если вопрос содержит переменные, система должна к тому же найти конкретные объекты, которые (будучи подставленными вместо переменных) обеспечивают достижение цели. Найденные конкретизации сообщаются пользователю. Если для некоторой конкретизации система не в состоянии вывести цель из остальных предложений программы, то ее ответом на вопрос будет "нет".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом, подходящей интерпретацией пролог-программы в математических терминах будет следующая: пролог-система рассматривает факты и правила в качестве множества аксиом, а вопрос пользователя — как \i теорему\i0  ; затем она пытается доказать эту теорему, т.е. показать, что ее можно логически вывести из аксиом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проиллюстрируем этот подход на классическом примере. Пусть имеются следующие аксиомы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Все люди смертны.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Сократ — человек.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теорема, логически вытекающая из этих двух аксиом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Сократ смертен.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первую из вышеуказанных аксиом можно переписать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Для всех X, если X — человек, то X смертен.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Соответственно наш пример можно перевести на Пролог следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 смертен( X) :- человек( X). % Все люди смертны\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 человек( сократ).           % Сократ - человек\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  смертен( сократ).       % Сократ смертен?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes                   (да)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Более сложный пример из программы о родственных отношениях, приведенной на рис. 1.8:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- предок( том, пат)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы знаем, что родитель( боб, пат) — это факт. Используя этот факт и правило \i пр1\i0  , мы можем сделать вывод, что утверждение предок( боб, пат) истинно. Этот факт получен в результате \i вывода\i0   — его нельзя найти непосредственно в программе, но можно вывести, пользуясь содержащимися в ней фактами и правилами. Подобный шаг вывода можно коротко записать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( боб, пат) ==> предок( боб, пат)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эту запись можно прочитать так: из родитель( боб, пат) следует предок( боб, пат) на основании правила \i пр1\i0  . Далее, нам известен факт родитель( том, боб). На основании этого факта и выведенного факта предок( боб, пат) можно заключить, что, в силу правила \i пр2\i0  , наше целевое утверждение предок( том, пат) истинно. Весь процесс вывода, состоящий из двух шагов, можно записать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель(боб, пат) ==> предок( боб, пат)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель(том, боб)\i и\i0     предок( боб, пат) ==>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( том, пат)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом, мы показали, \i какой\i0   может быть последовательность шагов для достижения цели, т.е. для демонстрации истинности целевого утверждения. Назовем такую последовательность цепочкой доказательства. Однако мы еще не показали как пролог-система в действительности строит такую цепочку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пролог-система строит цепочку доказательства в порядке, обратном по отношению к тому, которым мы только что воспользовались. Вместо того, чтобы начинать с простых фактов, приведенных в программе, система начинает с целей и, применяя правила, подменяет текущие цели новыми, до тех пор, пока эти новые цели не окажутся простыми фактами. Если задан вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  предок( том, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 система попытается достичь этой цели. Для того, чтобы это сделать, она пробует найти такое предложение в программе, из которого немедленно следует упомянутая цель. Очевидно, единственными подходящими для этого предложениями являются \i пр1\i0   и \i пр2\i0  .\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 1.9.\b0    Первый шаг вычислений. Верхняя цель истинна, если истинна нижняя.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это правила, входящие в отношение предок. Будем говорить, что головы этих правил сопоставимы с целью.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Два предложения \i пр1\i0   и \i пр2\i0   описывают два варианта продолжения рассуждений для пролог-системы. Вначале система пробует предложение, стоящее в программе первым:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :- родитель( X, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поскольку цель — предок( том, пат), значения переменным должны быть приписаны следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = том, Z = пат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда исходная цель предок( том, пат) заменяется новой целью:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( том, пат)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такое действие по замене одной цели на другую на основании некоторого правила показано на рис. 1.9. В программе нет правила, голова которого была бы сопоставима с целью родитель(том, пат), поэтому такая цель оказывается неуспешной. Теперь система делает \i возврат\i0   к исходной цели, чтобы попробовать второй вариант вывода цели верхнего уровня предок( том, пат). То есть, пробуется правило \i пр2\i0  :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как и раньше, переменным X и Z приписываются значения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = том, Z = пат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этот момент переменной Y еще не приписано никакого значения. Верхняя цель предок( том, пат) заменяется двумя целями:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( том, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( Y, пат)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот шаг вычислений показан на рис. 1.10, который представляет развитие ситуации, изображенной на рис. 1.9.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 1.10.\b0   Продолжение процесса вычислений, показанного на рис. 1.9.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имея теперь перед собой \i две \i0  цели, система пытается достичь их в том порядке, каком они записаны. Достичь первой из них легко, поскольку она соответствует факту из программы. Процесс установления соответствия — сопоставление (унификация) вызывает приписывание переменной Y значения боб. Тем самым достигается первая цель, а оставшаяся превращается в\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( боб, пат)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для достижения этой цели вновь применяется правило \i пр1\i0  . Заметим, — что это (второе) применение правила никак не связано с его первым применением. Поэтому система использует новое множество переменных правила всякий раз, как оно применяется. Чтобы указать это, мы переименуем переменные правила \i пр1\i0   для нового его применения следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X', Z') :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X', Z').\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Голова этого правила должна соответствовать нашей текущей цели предок( боб, пат). Поэтому\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X' = боб, Z' = пат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Текущая цель заменяется на\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родитель( боб, пат)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такая цель немедленно достигается, поскольку встречается в программе в качестве факта. Этот шаг завершает вычисление, что графически показано на рис. 1.11.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 1.11.\b0    Все шаги достижения цели предок( том, пат). Правая ветвь демонстрирует, что цель достижима.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Графическое представление шагов вычисления на рис. 1.11 имеет форму дерева. Вершины дерева соответствуют целям или спискам целей, которые требуется достичь. Дуги между вершинами соответствуют применению (альтернативных) предложений программы, которые преобразуют цель, соответствующую одной вершине, в цель, соответствующую другой вершине. Корневая (верхняя) цель достигается тогда, когда находится путь от корня дерева (верхней вершины) к его листу, помеченному меткой "да". Лист помечается меткой "да", если он представляет собой простой факт. Выполнение пролог-программы состоит в поиске таких путей. В процессе такого поиска система может входить и в ветви, приводящие к неуспеху. В тот момент, когда она обнаруживает, что ветвь не приводит к успеху, происходит автоматический \i возврат\i0   к предыдущей вершине, и далее следует попытка применить к ней альтернативное предложение.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.7.\b0   Постарайтесь понять, как пролог-система, используя программу, приведенную на рис. 1.8, выводит ответы на указанные ниже вопросы. Попытайтесь нарисовать соответствующие диаграммы вывода по типу тех, что изображены на рис.1.9–1.11. Будут ли встречаться возвраты при выводе ответов на какие-либо из этих вопросов?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a)  ?- родитель( пам, боб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b)  ?- мать( пам, боб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (с)  ?- родительродителя( пам, энн).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d)  ?- родительродителя( боб, джим). \par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 1.5. Декларативный и процедурный смысл программ\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 До сих пор во всех наших примерах всегда можно было понять результаты работы программы, точно не зная, \i как\i0   система в действительности их нашла. Поэтому стоит различать два уровня смысла программы на Прологе, а именно:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i декларативный смысл\i0   и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i процедурный смысл\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Декларативный смысл касается только \i отношений\i0  , определенных в программе. Таким образом, декларативный смысл определяет, \i что\i0   должно быть результатом работы программы. С другой стороны, процедурный смысл определяет еще и \i как\i0   этот результат был получен, т.е. как отношения реально обрабатываются пролог-системой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Способность пролог-системы прорабатывать многие процедурные детали самостоятельно считается одним из специфических преимуществ Пролога. Это свойство побуждает программиста рассматривать декларативный смысл программы относительно независимо от ее процедурного смысла. Поскольку результаты работы программы в принципе определяются ее декларативным смыслом, последнего (Опять же в принципе) достаточно для написания программ. Этот факт имеет практическое значение, поскольку декларативные аспекты программы являются, обычно, более легкими для понимания, нежели процедурные детали. Чтобы извлечь из этого обстоятельства наибольшую пользу, программисту следует сосредоточиться главным образом на декларативном смысле и по возможности не отвлекаться на детали процесса вычислений. Последние следует в возможно большей мере предоставить самой пролог-системе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такой декларативный подход и в самом деле часто делает программирование на Прологе более легким, чем на таких типичных процедурно-ориентированных языках, как Паскаль. К сожалению, однако, декларативного подхода не всегда оказывается, достаточно. Далее станет ясно, что, особенно в больших программах, программист не может полностью игнорировать процедурные аспекты по соображениям эффективности вычислений. Тем не менее следует поощрять декларативный стиль мышления при написании пролог-программ, а процедурные аспекты игнорировать в тех пределах, которые устанавливаются практическими ограничениями.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Программирование на Прологе состоит в определении отношений и в постановке вопросов, касающихся этих отношений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Программа состоит из предложений. Предложения бывают трех типов: \i факты\i0  , \i правила\i0   и \i вопросы.\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Отношение может определяться \i фактами\i0  , перечисляющими \i n\i0  -ки объектов, для которых это отношение выполняется, или же оно может определяться \i правилами\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Процедура\i0   — это множество предложений об одном и том же отношении.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Вопросы\i0   напоминают запросы к некоторой базе данных. Ответ системы на вопрос представляет собой множество объектов, которые удовлетворяют запросу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Процесс, в результате которого пролог-система устанавливает, удовлетворяет ли объект запросу, часто довольно сложен и включает в себя логический вывод, исследование различных вариантов и, возможно, \i возвраты\i0  . Все это делается автоматически самой пролог-системой и по большей части скрыто от пользователя.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Различают два типа смысла пролог-программ: декларативный и процедурный. Декларативный подход предпочтительнее с точки зрения программирования. Тем не менее, программист должен часто учитывать также и процедурные детали.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В данной главе были введены следующие понятия:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   предложение, факт, правило, вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   голова предложения, тело предложения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   рекурсивное правило\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   рекурсивное определение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   атом, переменная\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   конкретизация переменной\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   цель достижима, цель успешна\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   цель недостижима,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   цель имеет неуспех, цель терпит неудачу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   возврат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   декларативный смысл, процедурный смысл.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Различные реализации Пролога используют разные синтаксические соглашения. В данной книге мы применяем так называемый Эдинбургский синтаксис (его называют также синтаксисом DEC-10, поскольку он принят в известной реализации Пролога для машины DEC-10; см. Pereira и др. 1978), он используется во многих популярных пролог-системах, таких как Quintus Prolog, Poplog, CProlog, Arity/Prolog, Prolog-2 и т.д.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bowen D. L. (1981). \i DECsystem-10 Prolog User's Manual.\i0   University of Edinburgh: Department of Artificial Intelligence.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Mellish С. and Hardy S. (1984). \i Integrating Prolog in the POPLOG environment. Implementations of Prolog (J. A. Campbell, ed.).\i0   Ellis Horwood.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Pereira F. (1982). \i C-Prolog User's Manual.\i0   University of Edinburgh: Department of Computer-Aided Architectural Design.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Pereira L. M., Pereira F., Warren D. H. D. (1978). \i User's Guide to DECsystem-10 Prolog.\i0   University of Edinburgh: Department of Artificial Intelligence.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Quintus Prolog User's Guide and Reference Manual.\i0   Palo Alto: Quintus Computer System Inc. (1985).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i The Arity/Prolog Programming Language.\i0   Concord, Massachusetts: Arity Corporation (1986). \par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 2\par
Синтаксис и семантика Пролог-программ\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В данной главе дается систематическое изложение синтаксиса и семантики основных понятий Пролога, а также вводятся структурные объекты данных. Рассматриваются следующие темы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • простые объекты данных (атомы, числа, переменные)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • структурные объекты\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • сопоставление как основная операция над объектами\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • декларативная (или непроцедурная) семантика программ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • взаимосвязь между декларативным и процедурным смыслами программ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • изменение процедурного смысла путем изменения порядка следования предложений и целей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Большая часть этих тем уже была затронута в гл. 1. Теперь их изложение будет более формальным и детализированным.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 2.1.  Объекты данных\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 2.1 приведена классификация объектов данных Пролога. Пролог-система распознает тип объекта по его синтаксической форме в тексте программы. Это возможно благодаря тому, что синтаксис Пролога предписывает различные формы записи для различных типов объектов данных. В гл. 1 мы уже видели способ, с помощью которого можно отличить атомы от переменных: переменные начинаются с прописной буквы, тогда как атомы — со строчной. Для того, чтобы пролог-система распознала тип объекта, ей не требуется сообщать больше никакой дополнительной информации (такой, например, как объявление типа данных).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.1.\b0   Обьекты данных Пролога.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 2.1.1. Атомы и числа\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В гл. 1 мы уже видели несколько простых примеров атомов и переменных. Вообще же они могут принимать более сложные формы, а именно представлять собой цепочки следующих символов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • прописные буквы А, В, …, Z\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • строчные буквы а, b, …, z\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • цифры 0, 1, 2, …, 9\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • специальные символы, такие как \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    +  -  *  /   =  :  .  &  _  ~\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Атомы можно создавать тремя способами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) из цепочки букв, цифр и символа подчеркивания _, начиная такую цепочку со строчной буквы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 анна\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nil\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 х25\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x_25\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x_25AB\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x_\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 x__y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 альфа_бета_процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мисс_Джонс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сара_джонс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) из специальных символов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 <--->\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ======>\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .:.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ::=\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пользуясь атомами такой формы, следует соблюдать некоторую осторожность, поскольку часть цепочек специальных символов имеют в Прологе заранее определенный смысл. Примером может служить :- .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) из цепочки символов, заключенной в одинарные кавычки. Это удобно, если мы хотим, например, иметь атом, начинающийся с прописной буквы. Заключая его в кавычки, мы делаем его отличным от переменной:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 'Том'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 'Южная_Америка'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 'Сара Джонс'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Числа в Прологе бывают целыми и вещественными. Синтаксис целых чисел прост, как это видно из следующих примеров: 1, 1313, 0, -97. Не все целые числа могут быть представлены в машине, поэтому диапазон целых чисел ограничен интервалом между некоторыми минимальным и максимальным числами, определяемыми конкретной реализацией Пролога. Обычно реализация допускает диапазон хотя бы от -16 383 до 16 383, а часто, и значительно более широкий.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис вещественных чисел зависит от реализации. Мы будем придерживаться простых правил, видных из следующих примеров: 3.14, -0.0035, 100.2. При обычном программировании на Прологе вещественные числа используются редко. Причина этого кроется в том, что Пролог — это язык, предназначенный в первую очередь для обработки символьной, а не числовой информации, в противоположность языкам типа Фортрана, ориентированным на числовую обработку. При символьной обработке часто используются целые числа, например, для подсчета количества элементов списка; нужда же в вещественных числах невелика.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме отсутствия необходимости в использовании вещественных чисел в обычных применениях Пролога, существует и другая причина избегать их. Мы всегда стремимся поддерживать наши программы в таком виде, чтобы их смысл был предельно ясен. Введение вещественных чисел в некоторой степени нарушает эту ясность из-за ошибок вычислений, связанных с округлением во время выполнения арифметических действий. Например, результатом вычисления выражения 10000 + 0.0001 - 10000 может оказаться 0 вместо правильного значения 0.0001.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 2.1.2. Переменные\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменные — это цепочки, состоящие из букв, цифр и символов подчеркивания. Они начинаются с прописной буквы или с символа подчеркивания:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Результат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Объект2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список_участников\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 СписокПокупок\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 _x23\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 _23\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если переменная встречается в предложения только один раз, то нет необходимости изобретать ей имя. Можно использовать так называемую "анонимную" переменную, которая записывается в виде одного символа подчеркивания. Рассмотрим, например, следующее правило:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеетребенка( X) :- родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это правило гласит: "Для всех X,  X имеет ребенка, если X является родителем некоторого Y". Здесь мы определяем свойство имеетребенка таким образом, что оно не зависит от имени ребенка. Следовательно, это как раз тот случай, когда уместно использовать анонимную переменную. Поэтому вышеприведенное правило можно переписать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеетребенка( X) :- родитель( X, _).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Всякий раз, когда в предложения появляется одиночный символ подчеркивания, он обозначает новую анонимную переменную. Например, можно сказать, что существует некто, кто имеет ребенка, если существуют два объекта, такие, что один из них является родителем другого:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 некто_имеет_ребенка :- родитель( _, _).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это предложение эквивалентно следующему:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 некто_имеет_ребенка :- родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако оно имеет совершенно другой смысл, нежели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 некто_имеет_ребенка :- родитель( X, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если анонимная переменная встречается в вопросе, то ее значение не выводится при ответе системы на этот вопрос. Если нас интересуют люди, имеющие детей, но не имена этих детей, мы можем просто спросить:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  родитель( X, _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Лексический диапазон имени — одно предложение. Это значит, что если, например, имя X15 встречается в двух предложениях, то оно обозначает две разные переменные. Однако внутри одного предложения каждое его появлений обозначает одну и ту же переменную. Для констант ситуация другая: один и тот же атом обозначает один и тот же объект в любом предложении, иначе говоря, — во всей программе.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 2.1.3. Структуры\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Структурные объекты (или просто структуры) — это объекты, которые состоят из нескольких компонент. Эти компоненты, в свою очередь, могут быть структурами. Например, дату можно рассматривать как структуру, состоящую из трех компонент: день, месяц, год. Хотя они и составлены из нескольких компонент, структуры в программе ведут себя как единые объекты. Для того, чтобы объединить компоненты в структуру, требуется выбрать \i функтор\i0  . Для нашего примера подойдет функтор дата. Тогда дату 1-e мая 1983 г. можно записать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дата( 1, май, 1983)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (см. рис. 2.2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все компоненты в данном примере являются константами (две компоненты — целые числа и одна — атом). Компоненты могут быть также переменными или структурами. Произвольный день в мае можно представить структурой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дата( День, май, 1983)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что День является переменной и ей можно приписать произвольное значение на некотором более позднем этапе вычислений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такой метод структурирования данных прост и эффективен. Это является одной из причин того, почему Пролог естественно использовать для решения задач обработки символьной информации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксически все объекты данных в Прологе представляют собой \i термы\i0  . Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 май\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дата( 1, май, 1983)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 суть термы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все структурные объекты можно изображать в виде деревьев (пример см. на рис. 2.2). Корнем дерева служит функтор, ветвями, выходящими из него, — компоненты. Если некоторая компонента тоже является структурой, тогда ей соответствует поддерево в дереве, изображающем весь структурный объект.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наш следующий пример показывает, как можно использовать структуры для представления геометрических объектов (см. рис. 2.3). Точка в двумерном пространстве определяется двумя координатами; отрезок определяется двумя точками, а треугольник можно задать тремя точками. Введем следующие функторы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 точка        для точек\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отрезок      для отрезков и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 треугольник  для треугольников.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.2.\b0   Дата — пример структурного объекта: (а) его представление в виде дерева; (б) запись на Прологе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда объекты, приведенные на рис. 2.3, можно представить следующими прологовскими термами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P1 = точка( 1, 1)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P2 = точка( 2, 3)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = отрезок( P1, P2) =\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отрезок( точка( 1, 1), точка( 2, 3) )\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 T = треугольник( точка( 4, 2), точка( 6, 4),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  точка( 7, 1) )\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.3.\b0   Простые геометрические объекты.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Соответствующее представление этих объектов в виде деревьев приводится на рис. 2.4. Функтор, служащий корнем дерева, называется \i главным функтором\i0   терма.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2. 4.\b0    Представление объектов с рис. 2.3  в виде деревьев.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если бы в такой же программе фигурировали точки трехмерного пространства, то можно было бы для их представления использовать другой функтор, скажем точка3:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 точка3( X, Y, Z)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно, однако, воспользоваться одним и тем же именем точка одновременно и для точек двумерного и трехмерного пространств и написать, например, так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 точка( XI, Y1) и точка( X, Y, Z)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если одно и то же имя появляется в программе в двух различных смыслах, как в вышеупомянутом примере с точкой, то пролог-система будет различать их по числу аргументов и интерпретировать это имя как два функтора: один — двухаргументный; второй — трех. Это возможно потому, что каждый функтор определяется двумя параметрами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) именем, синтаксис которого совпадает с синтаксисом атомов;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) \i арностью\i0   — т.е. числом аргументов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как уже объяснялось, все структурные объекты в Прологе — это деревья, представленные в программе термами. Рассмотрим еще два примера, чтобы показать, насколько удобно сложные объекты данных представляются с помощью прологовских термов. На рис. 2.5 показана древовидная структура, соответствующая арифметическому выражению\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  (a + b)*(c - 5)\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В соответствии с введенным к настоящему моменту синтаксисом, такое выражение, используя символы *,  +  и  -  в качестве функторов, можно записать следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 *( +( a, b), -( c, 5))\par
\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.5.\b0   Древовидная структура, соответствующая арифметическому выражению \i (a + b)*(c - 5)\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это, конечно, совершенно правильный прологовский терм, однако это не та форма, которую нам хотелось бы иметь, при записи арифметических выражений. Хотелось бы применять обычную инфиксную запись, принятую в математике. На самом деле Пролог допускает использование инфиксной нотации, при которой символы *,  +   и  -  записываются как инфиксные операторы. Детали того, как программист может определять свои собственные операторы, мы приведем в гл. 3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве последнего примера рассмотрим некоторые простые электрические цепи, изображенные на рис. 2.6. В правой части рисунка помещены древовидные представления этих цепей. Атомы r1, r2, r3 и r4 — имена резисторов. Функторы пар и посл обозначают соответственно параллельное и последовательное соединение резисторов. Вот соответствующие прологовские термы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 посл( r1, r2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пар( r1, r2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 паp( rl, пap( r2, r3))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пар( r1, посл( пар( r2, r3), r4))\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.6.\b0   Некоторые простые электрические цепи и их представление: (а) последовательное соединение резисторов r1 и r2; (b) параллельное соединение двух резисторов; (с) параллельное соединение трех резисторов; (d) параллельное соединение r1 и еще одной цепи.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.1.\b0   Какие из следующих выражений представляют собой правильные объекты в смысле Пролога? Что это за объекты (атомы, числа, переменные, структуры)?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (а)  Диана\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b)  диана\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (с)  'Диана'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d)  _диана\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (e)  'Диана едет на юг'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (f)  едет( диана, юг)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (g)  45\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (h)  5( X, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (i)  +( север, запад)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (j)  три( Черные( Кошки))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.2.\b0   Предложите представление для прямоугольников, квадратов и окружностей в виде структурных объектов Пролога. Используйте подход, аналогичный приведенному на рис. 2.4. Например, прямоугольник можно представить четырьмя точками (а может быть, только тремя точками). Напишите несколько термов конкретных объектов такого типа с использованием предложенного вами представления. \par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 2.2. Сопоставление\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В предыдущем разделе мы видели, как используются термы для представления сложных объектов данных. Наиболее важной операцией над термами является \i сопоставление\i0  . Сопоставление само по себе может производить содержательные вычисления.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пусть даны два терма. Будем говорить, что они \i сопоставимы\i0  , если:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) они идентичны или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) переменным в обоих термах можно приписать в качестве значений объекты (т.е. конкретизировать их) таким образом, чтобы после подстановки этих объектов в термы вместо переменных, последние стали идентичными.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, термы дата( Д, М, 1983) и дата( Д1, май, Y1) сопоставимы. Одной из конкретизации, которая делает эти термы идентичными, является следующая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Д  заменяется на Д1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • М  заменяется на май\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b • \b0  Y1 заменяется на 1983\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Более компактно такая подстановка записывается в привычной форме, т.е. в той, в которой пролог-система выводит результаты:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Д = Д1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 М = май\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y1 = 1983\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С другой стороны, дата( Д, М, 1983) и дата( Д1, M1, 1944) не сопоставимы, как и термы дата( X, Y, Z) и точка( X, Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Сопоставление\i0   — это процесс, на вход которого подаются два терма, а он проверяет, соответствуют ли эти термы друг другу. Если термы не сопоставимы, будем говорить, что этот процесс терпит \i неуспех\i0  . Если же они сопоставимы, тогда процесс находит конкретизацию переменных, делающую эти термы тождественными, и завершается \i успешно\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим еще раз сопоставление двух дат. Запрос на проведение такой операции можно передать системе, использовав оператор '=':\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- дата( Д, М, 1983) = дата( Д1, май, Y1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы уже упоминали конкретизацию Д = Д1, М = май, Y1 = 1983, на которой достигается сопоставление. Существуют, однако, и другие конкретизации, делающие оба терма идентичными. Вот две из них:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Д  = 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Д1 = 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 М  = май\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y1 = 1983\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Д  = третий\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Д1 = третий\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 М  = май\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y1 = 1983\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Говорят, что эти конкретизации являются \i менее общими\i0   по сравнению с первой, поскольку они ограничивают значения переменных Д и Д1 в большей степени, чем это необходимо. Для того, чтобы сделать оба терма нашего примера идентичными, важно лишь, чтобы Д и Д1 имели одно и то же значение, однако само это значение может быть произвольным. Сопоставление в Прологе всегда дает \i наиболее общую конкретизацию\i0  . Таковой является конкретизация, которая ограничивает переменные в наименьшей степени, оставляя им, тем самым, наибольшую свободу для дальнейших конкретизаций, если потребуются новые сопоставления. В качестве примера рассмотрим следующий вопрос:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- дата( Д, М, 1983) =  дата( Д1, май, Y1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    дата( Д, М, 1983) = дата( 15, М, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для достижения первой цели система припишет переменным такие значения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Д  = Д1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 М  = май\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y1 = 1983\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После достижения второй цели, значения переменных станут более конкретными, а именно:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Д  = 15\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Д1 = 15\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 М  = май\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y1 = 1983\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y  = 1983\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот пример иллюстрирует также и тот факт, что переменным по мере вычисления последовательности целей приписываются обычно все более и более конкретные значения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Общие правила выяснения, сопоставимы ли два терма S и T, таковы:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (1) Если S и T — константы, то S и T сопоставимы, только если они являются одним и тем же объектом.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (2) Если S — переменная, а T — произвольный объект, то они сопоставимы, и S приписывается значение T. Наоборот, если T —переменная, а S — произвольный объект, то T приписывается значение S.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (3) Если S и T — структуры, то они сопоставимы, только если\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600   (а) S и T имеют одинаковый главный функтор\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600        и\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600   (б) все их соответствующие компоненты сопоставимы.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600        Результирующая конкретизация определяется сопоставлением компонент.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Последнее из этих правил можно наглядно представить себе, рассмотрев древовидное изображение термов, такое, например, как на рис. 2.7. Процесс сопоставления начинается от корня (главных функторов). Поскольку оба функтора сопоставимы, процесс продолжается и сопоставляет соответствующие пары аргументов. Таким образом, можно представить себе, что весь процесс сопоставления состоит из следующей последовательности (более простых) операций сопоставления:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 треугольник = треугольник,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 точка( 1, 1) = X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А = точка( 4, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 точка( 2, 3) = точка( 2, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Весь процесс сопоставления успешен, поскольку все сопоставления в этой последовательности успешны. Результирующая конкретизация такова:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = точка( 1, 1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 A = точка( 4, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Z = 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В приведенном ниже примере показано, как сопоставление само по себе можно использовать для содержательных вычислений. Давайте вернемся к простым геометрическим объектам с рис. 2.4 и напишем фрагмент программы для распознавания горизонтальных и вертикальных отрезков. "Вертикальность" — это свойство отрезка, поэтому его можно формализовать в Прологе в виде унарного отношения. Рис. 2.8 помогает сформулировать это отношение. Отрезок является вертикальным, если \i x\i0  -координаты его точек-концов совпадают; никаких других ограничений на отрезок не накладывается. Свойство "горизонтальности" формулируется аналогично, нужно только в этой формулировке \i x\i0   и \i y\i0   поменять местами. Следующая программа, содержащая два факта, реализует эти формулировки:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 верт( отр( точка( X, Y), точка( X, Y1) ) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 гор( отр( точка( X, Y), точка( X1, Y) ) ).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.7.\b0   Сопоставление треугольник(( точка( 1, 1), А, точка( 2, 3)) = треугольник( X, точка( 4, Y), точка( 2, Z))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С этой программой возможен такой диалог:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- верт( отр( точка( 1, 1), точка( 1, 2) ) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 да\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- верт( отр( точка( 1, 1), точка( 2, Y) ) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нет\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- гор( отр( точка( 1, 1), точка( 2, Y) ) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y = 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На первый вопрос система ответила "да", потому. что цель, поставленная в вопросе, сопоставима с одним из фактов программы. Для второго вопроса сопоставимых фактов не нашлось. Во время ответа на третий вопрос при сопоставлении с фактом о горизонтальных отрезках Y получил значение 1.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.8.\b0   Пример вертикальных и горизонтальных отрезков прямых.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сформулируем более общий вопрос к программе: "Существуют ли какие-либо вертикальные отрезки, начало которых лежит в точке (2,3)?"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- верт( отр( точка( 2, 3), P) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P = точка( 2, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такой ответ означает: "Да, это любой отрезок, с концом в точке (2,Y), т.е. в произвольной точке вертикальной прямой \i x\i0   = 2". Следует заметить, что ответ пролог-системы возможно будет выглядеть не так красиво, как только что описано, а (в зависимости от реализации) приблизительно следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P = точка( 2, _136)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Впрочем, разница здесь чисто внешняя. В данном случае _136 — это неинициализированная переменная. Имя _136 — законное имя прологовской переменной, которое система построила сама во время вычислений. Ей приходится генерировать новые имена, для того чтобы переименовывать введенные пользователем переменные в программе. Это необходимо по двум причинам: первая — одинаковые имена обозначают в разных предложениях разные переменные; и вторая — при последовательном применении одного и того же предложения используется каждый раз его "копия" с новым набором переменных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другим содержательным вопросом к нашей программe является следующий: "Существует ли отрезок, который одновременно и горизонтален в вертикален?"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- верт( S), гор( S).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = отр( точка( X, Y), точка( X, Y) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такой ответ пролог-системы следует, понимать так: "да, любой отрезок, выродившийся в точку, обладает как свойством вертикальности, так и свойством горизонтальности одновременно". Этот ответ снова получен лишь из сопоставления. Как и раньше, в ответе вместо X и Y могут появиться некоторые имена, сгенерированные системой.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.3.\b0   Будут ли следующие операции сопоставления успешными или неуспешными? Если они будут успешными, то какова будет результирующая конкретизация переменных?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (а) точка( А, В) = точка( 1, 2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) точка( А, В) = точка( X, Y, Z)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) плюс( 2, 2) = 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d) +( 2, D)= +( E, 2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (e) треугольник( точка( -1, 0), Р2, Р3) =\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      треугольник( P1, точка( 1, 0), точка( 0, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Результирующая конкретизация определяет семейство треугольников. Как бы Вы описали это семейство?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.4.\b0   Используя представление отрезков, применявшееся в данной разделе, напишите терм, соответствующий любому отрезку на вертикальной прямой \i x = 5\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.5.\b0   Предположим, что прямоугольник представлен термом прямоугольник( P1, P2, P3, Р4), где P — вершины прямоугольника, положительно упорядоченные. Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 регулярный( R)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которое имеет место, если R — прямоугольник с вертикальными и горизонтальными сторонами.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 2.3. Декларативный смысл пролог-программ\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В главе 1 мы уже видели, что пролог-программу можно понимать по-разному: с декларативной и процедурной точек зрения. В этом и следующем разделах мы рассмотрим более формальное определение декларативного и процедурного смыслов программ базисного Пролога. Но сначала давайте еще раз взглянем на различия между этими двумя семантиками.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим предложение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P :- Q, R.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где P, Q и R имеют синтаксис термов. Приведем некоторые способы декларативной интерпретации этого предложения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  P — истинно, если Q и R истинны.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Из Q и R следует  P.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А вот два варианта его "процедурного" прочтения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Чтобы решить задачу P, \i сначала\i0   реши подзадачу Q, а \i затем\i0   — подзадачу R.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Чтобы достичь P, \i сначала\i0   достигни Q, а \i затем\i0   R.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом, различие между "декларативным" и "процедурным" прочтениями заключается в том, что последнее определяет не только логические связи между головой предложения и целями в его теле, но еще и \i порядок\i0  , в котором эти цели обрабатываются.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Формализуем теперь декларативный смысл.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Декларативный смысл программы определяет, является ли данная цель истинной (достижимой) и, если да, при каких значениях переменных она достигается. Для точного определения декларативного смысла нам потребуется понятие \i конкретизации\i0   предложения. Конкретизацией предложения С называется результат подстановки в него на место каждой переменной некоторого терма. \i Вариантом\i0   предложения С называется такая конкретизация С, при которой каждая переменная заменена на другую переменную. Например, рассмотрим предложение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеетребенка( X) :- родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведем два варианта этого предложения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеетребенка( А) :- родитель( А, В).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеетребенка( X1) :- родитель( X1, Х2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Примеры конкретизаций этого же предложения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеетребенка( питер) :- родитель( питер, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеетребенка( барри) :- родитель( барри,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                         маленькая( каролина) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пусть дана некоторая программа и цель G, тогда, в соответствии с декларативной семантикой, можно утверждать, что\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Цель G истинна (т.е. достижима или логически следует из программы) тогда и только тогда, когда\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (1) в программе существует предложение С, такое, что\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (2) существует такая его (С) конкретизация I, что\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600   (a) голова I совпадает с G и\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600   (б) все цели в теле I истинны.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это определение можно распространить на вопросы следующим образом. В общем случае вопрос к пролог-системе представляет собой \i список\i0   целей, разделенных запятыми. Список целей называется \i истинным\i0   (достижимым), если \i все\i0   цели в этом списке истинны (достижимы) при \i одинаковых\i0   конкретизациях переменных. Значения переменных получаются из наиболее общей конкретизации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом, запятая между целями обозначает \i конъюнкцию\i0   целей: они \i все\i0   должны быть истинными. Однако в Прологе возможна и \i дизъюнкция\i0   целей: должна быть истинной, \i по крайней мере одна\i0   из целей. Дизъюнкция обозначается точкой с запятой. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P :- Q; R.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 читается так: P — истинно, если истинно Q \i или\i0   истинно R. То есть смысл такого предложения тот же, что и смысл следующей пары предложений:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P :- Q.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P :- R.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Запятая связывает (цели) сильнее, чем точка с запятой. Таким образом, предложение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P :- Q, R; S, T, U.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 понимается как:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P :- ( Q, R); (S, T, U).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и имеет тот же смысл, что и два предложения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P :- Q, R.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P :- S, T, U.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.6.\b0   Рассмотрим следующую программу:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( 1, один).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( s(1), два).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( s(s(1)), три).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( s(s(s(X))), N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  f(X, N).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как пролог-система ответит на следующие вопросы? Там, где возможны несколько ответов, приведите по крайней мере два.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) ?- f( s( 1), A).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) ?- f( s(s(1)), два). \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) ?- f( s(s(s(s(s(s(1)))))), С). \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d) ?- f( D, три).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.7.\b0   В следующей программе говорится, что два человека являются родственниками, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) один является предком другого, или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) у них есть общий предок, или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) у них есть общий потомок.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родственники( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( X, Y).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родственники( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Y, X).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родственники( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % X и Y имеют общего предка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Z, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Z, Y).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родственники( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % X и Y имеют общего потомка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( X, Z),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сможете ли вы сократить эту программу, используя запись с точками с запятой?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.8.\b0   Перепишите следующую программу, не пользуясь точками с запятой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобразовать( Число, Слово) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Число = 1, Слово = один;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Число = 2, Слово = два;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Число = 3, Слово = три.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 2.4. Процедурная семантика\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедурная семантика определяет, \i как\i0   пролог-система отвечает на вопросы. Ответить на вопрос — это значит удовлетворить список целей. Этого можно добиться, приписав встречающимся переменным значения таким образом, чтобы цели логически следовали из программы. Можно сказать, что процедурная семантика Пролога — это процедура вычисления списка целей с учетом заданной программы. "Вычислить цели" это значит попытаться достичь их.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Назовем эту процедуру вычислить. Как показано на рис. 2.9, входом и выходом этой процедуры являются:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  входом — программа и список целей,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выходом — признак успех/неуспех и подстановка переменных.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.9.\b0   Входы и выходы процедуры вычисления списка целей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Смысл двух составляющих выхода такой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1)  Признак успех/неуспех принимает значение "да", если цели достижимы, и "нет" — в противном случае. Будем говорить, что "да" сигнализирует об \i успешном\i0   завершении и "нет" — о \i неуспехе\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2)  Подстановка переменных порождается только в случае успешного завершения; в случае неуспеха подстановка отсутствует.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 ПРОГРАММА\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 большой( медведь).     % Предложение 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 большой( слон).        % Предложение 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 маленький( кот).       % Предложение 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 коричневый ( медведь). % Предложение 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 черный ( кот).         % Предложение 5\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 серый( слон).          % Предложение 6\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 темный( Z) :-          % Предложение 7:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  черный( Z).           % любой черный\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                        % объект является темным\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 темный( Z) :-          % Предложение 8:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  коричневый( Z).       % Любой коричневый\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                        % объект является темным\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 ВОПРОС\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- темный( X), большой( X) % Кто одновременно темный\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                            % и большой?\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 ШАГИ  ВЫЧИСЛЕНИЯ\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Исходный список целевых утверждений:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 темный( X),  большой( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Просмотр всей программы от начала к концу и поиск предложения, у которого голова сопоставима с первым целевым утверждением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 темный( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Найдена формула 7:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 темный( Z) :- черный( Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Замена первого целевого утверждения конкретизированным телом предложения 7 — порождение нового списка целевых утверждений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 черный( X),  большой( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Просмотр программы для нахождения предложения, сопоставимого с черный( X). Найдено предложение 5: черный ( кот). У этого предложения нет тела, поэтому список целей при соответствующей конкретизации сокращается до\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 большой( кот)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (4) Просмотр программы в поисках цели большой( кот). Ни одно предложение не найдено. Поэтому происходит возврат к шагу (3) и отмена конкретизации X = кот. Список целей теперь снова\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 черный( X),  большой( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Продолжение просмотра программы ниже предложения 5. Ни одно предложение не найдено. Поэтому возврат к шагу (2) и продолжение просмотра ниже предложения 7. Найдено предложение (8):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 темный( Z) :- коричневый( Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Замена первой цели в списке на коричневый( X), что дает\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 коричневый( X), большой( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (5) Просмотр программы для обнаружения предложения, сопоставимого коричневый( X). Найдено предложение коричневый( медведь). У этого предложения нет тела, поэтому список целей уменьшается до\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 большой( медведь)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (6) Просмотр программы и обнаружение предложения большой( медведь). У него нет тела, поэтому список целей становится пустым. Это указывает на успешное завершение, а соответствующая конкретизация переменных такова:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.10.\b0    Пример, иллюстрирующий процедурную семантику Пролога: шаги вычислений, выполняемых процедурой вычислить.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В главе 1 в разд. "Как пролог-система отвечает на вопросы" мы уже фактически рассмотрели, что делает процедура вычислить. В оставшейся части данного раздела приводится несколько более формальное и систематическое описание этого процесса, которое можно пропустить без серьезного ущерба для понимания остального материала книги.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конкретные операции, выполняемые в процессе вычисления целевых утверждений, показаны на рис. 2.10. Возможно, следует изучить этот рисунок прежде, чем знакомиться с последующим общим описанием.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы вычислить список целевых утверждений\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  G1, G2, …, Gm\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 процедура вычислить делает следующее:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • Если список целей пуст - завершает работу \i успешно\i0  .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • Если список целей не пуст, продолжает работу, выполняя (описанную далее) операцию 'ПРОСМОТР'.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • \i ПРОСМОТР\i0  : Просматривает предложения программы от начала к концу до обнаружения первого предложения С, такого, что голова С сопоставима с первой целью G1. Если такого предложения обнаружить не удается, то работа заканчивается \i неуспехом\i0  .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Если С найдено и имеет вид\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 H :- B1, ..., Вn.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 то переменные в С переименовываются, чтобы получить такой вариант С' предложения С, в котором нет общих переменных со списком  G1, …, Gm. Пусть С' — это\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Н' :- B1', ..., Вn'.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Сопоставляется G1 с H'; пусть S — результирующая конкретизация переменных. В списке целей G1, G2, …, Gm, цель G1 заменяется на список В1', …, Вn', что порождает новый список целей:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 В1', …, Вn', G2, …, Gm\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (Заметим, что, если С — факт, тогда n=0, и в этом случае новый список целей оказывается короче, нежели исходный; такое уменьшение списка целей может в определенных случаях превратить его в пустой, а следовательно, — привести к успешному завершению.)\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Переменные в новом списке целей заменяются новыми значениями, как это предписывает конкретизация S, что порождает еще один список целей\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 В1'', …, Вn", G2', …, Gm'\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • Вычисляет (используя рекурсивно ту же самую процедуру) этот новый список целей. Если его вычисление завершается успешно, то и вычисление исходного списка целей тоже завершается успешно. Если же его вычисление порождает неуспех, тогда новый список целей отбрасывается и происходит возврат к просмотру программы. Этот просмотр продолжается, начиная с предложения, непосредственно следующего за предложением С (С — предложение, использовавшееся последним) и делается попытка достичь успешного завершения с помощью другого предложения.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Более компактная запись этой процедуры в обозначениях, близких к Паскалю, приведена на рис. 2.11.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь следует сделать несколько дополнительных замечаний, касающихся процедуры вычислить в том виде, в котором она приводится. Во-первых, в ней явно не указано, как порождается окончательная результирующая конкретизация переменных. Речь идет о конкретизации S, которая приводит к успешному завершению и которая, возможно, уточнялась последующими конкретизациями во время вложенных рекурсивных вызовов вычислить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b procedure\b0  \i вычислить (Прогр, СписокЦелей, Успех)\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Входные параметры: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i Прогр:\i0   список предложений \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i СписокЦелей:\i0   список целей \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Выходной параметр: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i Успех:\i0   истинностное значение; \i Успех\i0   принимает значение \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         истина, если список целевых утверждений \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         (их конъюнкция) истиннен с точки зрения \i Прогр\i0   \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Локальные переменные: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i Цель:\i0   цель \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i ДругиеЦели\i0  : список целей \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i Достигнуты:\i0   истинностное значение \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i Сопоставились:\i0   истинностное значение \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i Конкрет:\i0   конкретизация переменных \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0           \i H, Н', B1, B1', …, В\sub n\nosupersub , В\sub n\nosupersub ':\i0   цели \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вспомогательные функции: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i пycтой( L):\i0   возвращает истину, если L — пустой список \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i голoвa( L):\i0   возвращает первый элемент списка L \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i хвост( L):\i0   возвращает остальную часть списка L \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i конкат( L1, L2):\i0   создает конкатенацию списков — присоединяет \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   список L2 к концу списка L1 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i сопоставление( T1, T2, Сопоставились, Конкрет):\i0   пытается \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   сопоставить термы Т1 и T2; если они сопоставимы, то \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \i Сопоставились\i0   — истина, а \i Конкрет\i0   представляет \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   собой конкретизацию переменных \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i подставить( Конкрет, Цели):\i0   производит подстановку переменных \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   в \i Цели\i0   согласно \i Конкрет\i0   \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b begin\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \b if\b0   \i пустой( СписокЦелей)\i0   \b then\b0   \i Успех \i0  : =\i  истина\i0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \b else\b0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b   begin\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    \i Цель\i0   : = \i голова( СписокЦелей)\i0  ; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    \i ДругиеЦели\i0   : = \i хвост( СписокЦелей)\i0  ; \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    \i Достигнута\i0   : = \i ложь;\i0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    \b while not\b0   \i Достигнута\i0   \b and\b0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     "в программе есть еще предложения" \b do\b0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \b begin\b0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \i Пусть следующее предложение в Прогр есть\i0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i       H :- B1, …, Вn.\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i      Создать вариант этого предложения\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i       Н' :- В1', …, Вn'.\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i      сопоставление( Цель, Н',\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i       Сопоставились, Конкрет)\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      \b if\b0   \i Сопоставились\i0   \b then\b0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       \b begin\b0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        \i НовыеЦели\i0   := \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         \i конкат( \i0  [\i В1', …, Вn'\i0   ]\i , Другие Цели\i0  ); \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        \i НовыеЦели\i0   : = \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         \i подставить( Конкрет, НовыеЦели);\i0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i        вычислить( Прогр, НовыеЦели, Достигнуты)\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       \b end\b0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b     end;\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     \i Успех \i0  : =\i  Достигнуты\i0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \b end\b0   \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b end;\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.11.\b0    Вычисление целевых утверждений Пролога.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Всякий раз, как рекурсивный вызов процедуры вычислить приводят к неуспеху, процесс вычислений возвращается к ПРОСМОТРУ и продолжается с того предложения  С,  которое использовалось последним. Поскольку применение предложения  С  не привело к успешному завершению, пролог-система должна для продолжения вычислений попробовать альтернативное предложение. В действительности система аннулирует результаты части вычислений, приведших к неуспеху, и осуществляет возврат в ту точку (предложение  С),  в которой эта неуспешная ветвь начиналась. Когда процедура осуществляет возврат в некоторую точку, все конкретизации переменных, сделанные после этой точки, аннулируются. Такой порядок обеспечивает систематическую проверку пролог-системой всех возможных альтернативных путей вычисления до тех пор, пока не будет найден путь, ведущий к успеху, или же до тех пор, пока не окажется, что все пути приводят к неуспеху.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы уже знаем, что даже после успешного завершения пользователь может заставить систему совершить возврат для поиска новых решений. В нашем описании процедуры вычислить эта деталь была опущена.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно, в настоящих реализациях Пролога в процедуру вычислить добавлены и еще некоторые усовершенствования. Одно из них — сокращение работы по просмотрам программы с целью повышения эффективности. Поэтому на практике пролог-система не просматривает все предложения программы, а вместо этого рассматривает только те из них, которые касаются текущего целевого утверждения.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.9.\b0   Рассмотрите программу на рис. 2.10 и по типу того, как это сделано на рис. 2.10, проследите процесс вычисления пролог-системой вопроса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- большой( X), темный( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сравните свое описание шагов вычисления с описанием на рис. 2.10, где вычислялся, по существу, тот же вопрос, но с другой последовательностью целей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- темный( X), большой( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В каком из этих двух случаев системе приходится производить б\i о\i0  льшую работу для нахождения ответа?\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 2.5. Пример: обезьяна и банан\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задача об обезьяне и банане часто используется в качестве простого примера задачи из области искусственного интеллекта. Наша пролог-программа, способная ее решить, показывает, как механизмы сопоставления и автоматических возвратов могут применяться для подобных целей. Мы сначала составим программу, не принимая во внимание процедурную семантику, а затем детально изучим ее процедурное поведение. Программа будет компактной и наглядной.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим следующий вариант данной задачи. Возле двери комнаты стоит обезьяна. В середине этой комнаты к потолку подвешен банан. Обезьяна голодна и хочет съесть банан, однако она не может дотянуться до него, находясь на полу. Около окна этой же комнаты на полу лежит ящик, которым обезьяна может воспользоваться. Обезьяна может предпринимать следующие действия: ходить по полу, залезать на ящик, двигать ящик (если она уже находится около него) и схватить банан, если она стоит на ящике прямо под бананом. Может ли обезьяна добраться до банана?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одна из важных проблем при программировании состоит в выборе (адекватного) представления решаемой задачи в терминах понятий используемого языка программирования. В нашем случае мы можем считать, что "обезьяний мир" всегда находится в некотором \i состоянии\i0  , и оно может изменяться со временем. Текущее состояние определяется взаиморасположением объектов. Например, исходное состояние мира определяется так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Обезьяна у двери.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Обезьяна на полу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Ящик у окна.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (4) Обезьяна не имеет банана.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Удобно объединить все эти четыре информационных фрагмента в один структурный объект. Давайте в качестве такого объединяющего функтора выберем слово "состояние". На рис. 2.12 в виде структурного объекта изображено исходное состояние.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нашу задачу можно рассматривать как игру для одного игрока. Давайте, формализуем правила этой игры. Первое, целью игры является ситуация, в которой обезьяна имеет банан, т.е. любое состояние, у которого в качестве четвертой компоненты стоит "имеет":\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 состояние( _, _, _, имеет)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Второе, каковы разрешенные ходы, переводящие мир из одного состояния в другое? Существуют четыре типа ходов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) схватить банан,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) залезть на ящик,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) подвинуть ящик,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (4) перейти в другое место.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.12.\b0   Исходное состояние обезьяньего мира, представленное в виде структурного объекта. Его четыре компоненты суть горизонтальная позиция обезьяны, вертикальная позиция обезьяны, позиция ящика, наличие или отсутствие у обезьяны банана.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Не всякий ход допустим при всех возможных состояниях мира. Например, ход "схватить" допустим, только если обезьяна стоит на ящике прямо под бананом (т.е. в середине комнаты) и еще не имеет банана. Эти правила можно формализовать в Прологе в виде трехместного отношения ход:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( Состояние1, М, Состояние2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Три аргумента этого отношения определяют ход, следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Состояние1 --------> Состояние2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 М\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Состояние1 это состояние до хода, М — выполняемый ход, и Состояние2 — состояние после хода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ход "схватить", вместе с необходимыми ограничениями на состояние перед этим ходом, можно выразить такой формулой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( состояние( середина, наящике, середина, неимеет),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            % Перед ходом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  схватить, % Ход\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  состояние( середина, наящике, середина, имеет) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            % После хода\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом факте говорится о том, что после хода у обезьяны уже есть банан и что она осталась на ящике в середине комнаты.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким же способом можно выразить и тот факт, что обезьяна, находясь на полу, может перейти из любой горизонтальной позиции P1 в любую позицию Р2. Обезьяна может это сделать независимо от позиции ящика, а также независимо от того, есть у нее банан или нет. Все это можно записать в виде следующего прологовского факта:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( состояние( P1, наполу, В, H),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перейти( P1, Р2), % Перейти из P1 в Р2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  состояние( Р2, наполу, В, H) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что в этом предложении делается много утверждений и, в частности:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • выполненный ход состоял в том, чтобы "перейти из некоторой позиции P1 в некоторую позицию Р2";\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • обезьяна находится на полу, как до, так и после хода;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • ящик находится в некоторой точке В, которая осталась неизменной после хода;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • состояние "имеет банан" остается неизменным после хода.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.13.\b0   Рекурсивная формулировка отношения можетзавладеть.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Данное предложение на самом деле определяет все множество возможных ходов указанного типа, так как оно применимо к любой ситуации, сопоставимой с состоянием, имеющим место перед входом. Поэтому такое предложение иногда называют \i схемой\i0   хода. Благодаря понятию переменной, имеющемуся в Прологе, такие схемы легко на нем запрограммировать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Два других типа ходов: "подвинуть" и "залезть" — легко определить аналогичным способом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Главный вопрос, на который должна ответить наша программа, это вопрос: "Может ли обезьяна, находясь в некотором начальном состоянии S, завладеть бананом?" Его можно сформулировать в виде предиката\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можетзавладеть( S)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где аргумент S — состояние обезьяньего мира. Программа для можетзавладеть может основываться на двух наблюдениях:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Для любого состояния S, в которой обезьяна уже имеет банан, предикат можетзавладеть должен, конечно, быть истинным; в этом случае никаких ходов не требуется. Вот соответствующий прологовский факт:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можетзавладеть( состояние( _, _, _, имеет) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) В остальных случаях требуется один или более ходов. Обезьяна может завладеть бананом в любом состоянии S1, если для него существует ход из состояния P1 в некоторое состояние S2, такое, что, попав в него, обезьяна уже сможет завладеть бананом (за нуль или более ходов). Этот принцип показан на рис. 2.13. Прологовская формула, соответствующая этому правилу, такова:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можетзавладеть( S1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход( S1, М, S2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  можетзавладеть( S2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы полностью завершили нашу программу, показанную на рис. 2.14.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Формулировка можетзавладеть рекурсивна и совершенно аналогична формулировке отношения предок из гл. 1 (ср. рис. 2.13 и 1.7). Этот принцип используется в Прологе повсеместно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы создали нашу программу "непроцедурным" способом. Давайте теперь изучим ее \i процедурное\i0   поведение, рассмотрев следующий вопрос к программе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- можетзавладеть( состояние( удвери, наполу, уокна, неимеет) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответом пролог-системы будет "да". Процесс, выполняемый ею при этом, обрабатывает, в соответствии с процедурной семантикой Пролога, последовательность списков целей. Для этого требуется некоторый перебор ходов, для отыскания верного из нескольких альтернативных. В некоторых точках при таком переборе будет сделан неверный ход, ведущий в тупиковую ветвь процесса вычислений. На этом этапе автоматический возврат позволит исправить положение. На рис. 2.15 изображен процесс перебора.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Разрешенные ходы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( состояние( середина, на ящике, середина, неимеет),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  схватить,           % Схватить банан\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  состояние( середина, наящике, середина, имеет)).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( состояние( P, наполу, P, H),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  залезть,            % Залезть на ящик\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  состояние( P, наящике, P, H) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( состояние( P1, наполу, P1, H),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  подвинуть( P1, Р2), % Подвинуть ящик с P1 на Р2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  состояние( Р2, наполу, Р2, H) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( состояние( P1, наполу, В, H),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перейти( P1, Р2),   % Перейти с P1 на Р2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  состояние( Р2, наполу, В, H) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % можетзавладеть(Состояние): обезьяна может завладеть\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % бананом, находясь в состоянии Состояние\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можетзавладеть( состояние( -, -, -, имеет) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % может 1:  обезьяна уже его имеет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можетзавладеть( Состояние1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % может 2:  Сделать что-нибудь, чтобы завладеть им\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход( Состояние1, Ход, Состояние2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % сделать что-нибудь\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  можетзавладеть( Состояние2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % теперь может завладеть\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.14.\b0    Программа для задачи об обезьяне и банане.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для ответа на наш вопрос системе пришлось сделать лишь один возврат. Верная последовательность ходов была найдена почти сразу. Причина такой эффективности программы кроется в том порядке, в котором в ней расположены предложения, касающиеся отношения ход. В нашем случае этот порядок (к счастью) оказался весьма подходящим. Однако возможен и менее удачный порядок. По правилам игры обезьяна могла бы с легкостью ходить туда-сюда, даже не касаясь ящика, или бесцельно двигать ящик в разные стороны. Как будет видно из следующего раздела, более тщательное исследование обнаруживает, что порядок предложений в нашей программе является, на самом деле, критическим моментом для успешного решения задачи.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.15.\b0    Поиск банана обезьяной. Перебор начинается в верхнем узле и распространяется вниз, как показано. Альтернативные ходы перебираются слева направо. Возврат произошел только один раз.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 2.6. Порядок предложений и целей \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 2.6.1. Опасность бесконечного цикла\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим следующее предложение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 p :- p.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нем говорится: "p истинно, если p истинно". С точки зрения декларативного смысла это совершенно корректно, однако в процедурном смысле оно бесполезно. Более того, для пролог-системы такое предложение может породить серьезную проблему. Рассмотрим вопрос:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  p.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При использовании вышеприведенного предложения цель p будет заменена на ту же самую цель p; она в свою очередь будет заменена снова на p и т.д. В этом случае система войдет в бесконечный цикл, не замечая, что никакого продвижения в вычислениях не происходит.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Данный пример демонстрирует простой способ ввести пролог-систему в бесконечный цикл. Однако подобное зацикливание могло встретиться и в некоторых наших предыдущих программах, если бы мы изменили порядок предложений, или же порядок целей в них. Будет полезно рассмотреть несколько примеров.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В программе об обезьяне и банане предложения, касающиеся отношения ход, были упорядочены следующим образом: схватить, залезть, подвинуть, перейти (возможно, для полноты следует добавить еще "слезть"). В этих предложениях говорится, что можно схватить, можно залезть и т.д. В соответствии с процедурной семантикой Пролога порядок предложений указывает на то, что обезьяна предпочитает схватывание залезанию, залезание — передвиганию и т.д. Такой порядок предпочтений на самом деле помогает обезьяне решить задачу. Но что могло случиться. если бы этот порядок был другим? Предположим, что предложение с "перейти" оказалось бы первым. Процесс вычисления нашей исходной цели из предыдущего раздела\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- можетзавладеть( состояние( удвери, наполу, уокна, неимеет) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 протекал бы на этот раз так. Первые четыре списка целей (с соответствующим образом переименованными переменными) остались бы такими же, как и раньше:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) можетзавладеть( состояние( удвери, наполу, уокна, неимеет) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Применение второго предложения из можетзавладеть ("может2") породило бы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) ход( состояние( удвери, наполу, уокна, неимеет), М', S2'), \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   можетзавладеть( S2')\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью хода перейти( уокна, Р2') получилось бы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) можетзавладеть( состояние( Р2', наполу, уокна, неимеет) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Повторное использование предложения "может2" превратило бы список целей в\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (4) ход( состояние(Р2', наполу, уокна, неимеет), М'', S2''),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   можетзавладеть( S2'')\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С этого момента начались бы отличия. Первым предложением, голова которого сопоставима с первой целью из этого списка, было бы теперь "перейти" (а не "залезть", как раньше). Конкретизация стала бы следующей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S2'' = состояние( Р2'', наполу, уокна, неимеет).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поэтому список целей стал бы таким:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (5) можетзавладеть( состояние( Р2'', наполу, уокна, неимеет) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Применение предложения "может2" дало бы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (6) ход( cocтояниe( P2'', наполу, yoкнa, неимeeт), M''', S2'''),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                 можетзавладеть( S2''')\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Снова первый было бы попробовано "перейти" и получилось бы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (7) можетзавладеть( состояние( Р2''', наполу, уокна, неимеет) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сравним теперь цели (3), (5) и (7). Они похожи и отличаются лишь одной переменной, которая по очереди имела имена Р', Р''  и P'''.  Как мы знаем, успешность цели не зависит от конкретных имен переменных в ней. Это означает, что, начиная со списка целей (3), процесс вычислений никуда не продвинулся. Фактически мы замечаем, что по очереди многократно используются одни и те же два предложения: "может2" и "перейти". Обезьяна перемещается, даже не пытаясь воспользоваться ящиком. Поскольку продвижения нет, такая ситуация продолжалась бы (теоретически) бесконечно: пролог-система не сумела бы осознать, что работать в этой направлении нет смысла.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Данный пример показывает, как пролог-система может пытаться решить задачу таким способом, при котором решение никогда не будет достигнуто, хотя оно существует. Такая ситуация не является редкостью при программировании на Прологе. Да и при программировании на других языках бесконечные циклы не такая уж редкость. Что \i действительно\i0   необычно при сравнении Пролога с другими языками, так это то, что декларативная семантика пролог-программы может быть правильной, но в то же самое время ее процедурная семантика может быть ошибочной в том смысле, что с помощью такой программы нельзя получить правильный ответ на вопрос. В таких случаях система не способна достичь цели потому, что она пытается добраться до ответа, но выбирает при этом неверный путь.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь уместно спросить: "Не можем ли мы внести какое-либо более существенное изменение в нашу программу, так чтобы полностью исключить опасность зацикливания? Или же нам всегда придется рассчитывать на удачный порядок предложений и целей?" Как оказывается, программы, в особенности большие, были бы чересчур ненадежными, если бы можно было рассчитывать лишь на некоторый удачный порядок. Существует несколько других методов, позволяющих избежать зацикливания и являющихся более общими и надежными, чем сам по себе метод упорядочивания. Такие методы будут систематически использоваться дальше в книге, в особенности в тех главах, в которых пойдет речь о нахождении путей (в графах), о решения интеллектуальных задач и о переборе.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 2.6.2. Варианты программы, полученые путем переупорядочивания предложений и целей\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Уже в примерах программ гл. 1 существовала скрытая опасность зацикливания. Определение отношения предок в этой главе было таким:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Z).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проанализируем некоторые варианты этой программы. Ясно, что все варианты будут иметь одинаковую декларативную семантику, но разные процедурные семантики.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В соответствии с декларативной семантикой Пролога мы можем, не меняя декларативного смысла, изменить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) порядок предложений в программе и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) порядок целей в телах предложений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура предок состоит из двух предложений, и одно из них содержит в своем теле две цели. Возможны, поэтому, четыре варианта данной программы, все с одинаковым декларативным смыслом. Эти четыре варианта можно получить, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) поменять местами оба предложения и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) поменять местами цели в каждом из этих двух последовательностей предложений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Соответствующие процедуры, названные пред1, пред2, пред3 и пред4, показаны на рис. 2.16.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Есть существенная разница в поведении этих четырех декларативно эквивалентных процедур. Чтобы это продемонстрировать, будем считать, отношение родитель определенным так, как показано на рис. 1.1 гл. 1. и посмотрим, что произойдет, если мы спросим, является ли Том предком Пат, используя все четыре варианта отношения предок:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- пред1( том, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 да\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- пред2( том, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 да\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- пред3( том, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 да\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- пред4( том, пат).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Четыре версии программы предок\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Исходная версия\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пред1( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пред1( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  пред1( Y, Z).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Вариант  а:  изменение порядка предложений в исходной версии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пред2( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  пред2( Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пред2( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Z).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Вариант  b:  изменение порядка целей во втором предложении\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % исходной версии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пред3( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пред3( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  пред3( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Y, Z).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Вариант  с:  изменение порядка предложений и целей в исходной\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % версии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пред4( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  пред4( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пред4( X, Z):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( X, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.16.\b0    Четыре версии программы предок.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В последнем случае пролог-система не сможет найти ответа. И выведет на терминал сообщение: "Не хватает памяти".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 1.11 гл. 1 были показаны все шаги вычислений по пред1 (в главе 1 она называлась предок), предпринятые для ответа на этот вопрос. На рис 2.17 показаны соответствующие вычисления по пред2, пред3 и пред4. На рис. 2.17 (с) ясно видно, что работа пред4 — бесперспективна, а рис. 2.17(а) показывает, что пред2 довольно неэффективна по сравнению с пред1: пред2 производит значительно больший перебор и делает больше возвратов по фамильному дереву.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такое сравнение должно напомнить нам об общем практическом правиле при решении задач: обычно бывает полезным прежде всего попробовать самое простое соображение. В нашем случае все версии отношения предок основаны на двух соображениях:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • более простое — нужно проверить, не удовлетворяют ли два аргумента отношения предок отношению родитель;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • более сложное — найти кого-либо "между" этими двумя людьми (кого-либо, кто связан с ними отношениями родитель и предок).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Из всех четырех вариантов отношения предок, пред1 использует наиболее простое соображение в первую очередь. В противоположность этому пред4 всегда сначала пробует использовать самое сложное. Пред2 и пред3 находятся между этими двумя крайностями. Даже без детального изучения процессов вычислений ясно, что пред1 следует предпочесть просто на основании правила "самое простое пробуй в первую очередь".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наши четыре варианта процедуры предок можно далее сравнить, рассмотрев вопрос: "На какие типы вопросов может отвечать тот или иной конкретный вариант и на какие не может?" Оказывается, пред1 и пред2 оба способны найти ответ на любой вид вопроса относительно предков; пред4 никогда не находит ответа, а пред3 иногда может найти, иногда нет. Вот пример вопроса, на который пред4 ответить не может:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- пред3( лиз, джим).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такой вопрос тоже вводит систему в бесконечную рекурсию. Следовательно и пред3 нельзя признать верным с точки зрения процедурного смысла.\par
\qc\par\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 2.17.\b0   Поведение трех вариантов формулировки отношения предок при ответе на вопрос, является ли Том предком Пат?\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 2.6.3. Сочетание декларативного и процедурного подходов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В предыдущем разделе было показано, что порядок целей и предложений имеет существенное значение. Более того, существуют программы, которые верны в декларативном смысле, но на практике не работают. Такое противоречие между декларативным и процедурным смыслами может вызвать недовольство. Кто-нибудь спросит: "А почему вообще не забыть о декларативном смысле?" Такое пожелание становится особенно сильным, когда рассматриваются предложения типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предок( X, Z) :- предок( X, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это предложение верно в декларативном смысле, но совершенно бесполезно в качестве рабочей программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Причина, по которой не следует забывать о декларативном смысле, кроется в том, что прогресс, достигнутый в технологии программирования, получен на пути продвижения от учета всех процедурных деталей к концентрации внимания на декларативных аспектах, которые обычно легче формулировать и понимать. Сама система, а не программист, должна нести бремя заботы о процедурных деталях. В этом Пролог оказывает некоторую помощь, хотя, как мы видели в данном разделе, помощь лишь частичную: иногда он правильно прорабатывает эти процедурные детали, иногда — нет. Многие придерживаются мнения, что лучше иметь хоть какую-то декларативную семантику, чем никакой (отсутствие декларативной семантики характерно для многих других языков программирования). Практическим следствием такого взгляда является тот факт, что часто довольно легко получить работающую программу, имея программу декларативно корректную. Поэтому практичным следует признать такой подход: сосредоточиться на декларативных аспектах задачи, затем пропустить на машине полученную программу и, если она окажется процедурно неправильной, попытаться изменить порядок следования предложений и целей. \par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 2.7. Замечания о взаимосвязи между Прологом и логикой\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пролог восходит к математической логике, поэтому его синтаксис и семантику можно наиболее точно описать при помощи логики. Так часто и поступают при обучении этому языку. Однако такой подход к ознакомлению с Прологом предполагает знание читателем определенных понятий математической логики. С другой стороны, знание этих понятий явно необязательно для того, чтобы понять и использовать Пролог в качестве инструмента для практического программирования, а цель данной книги — научить именно этому. Для тех же читателей, которые особенно заинтересуются взаимосвязями между Прологом и логикой, мы сейчас перечислим основные из них, а также приведем некоторые подходящие источники.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Синтаксис Пролога — это синтаксис предложений \i логики предикатов первого порядка\i0  , записанных в так называемой \i форме предложений\i0   (форме, при которой кванторы не выписываются явно), а точнее, в виде частного случая таких предложений — в виде \i формул Хорна \i0  (предложений, имеющих самое большее один положительный литерал). Клоксин и Меллиш (1981 г.) приводят пролог-программу, которая преобразует предложения исчисления предикатов первого порядка в форму предложений. Процедурный смысл Пролога основывается на \i принципе резолюций\i0  , применяющемся для автоматического доказательства теорем, который был предложен Робинсоном в его классической статье (1965 г.). В Прологе используется особая стратегия доказательства теоремы методом резолюций, носящая название SLD. Введение в исчисление предикатов первого порядка и доказательство теорем, основанное на методе резолюций, можно найти у Нильсона (1981 г.). Математические вопросы, касающиеся свойств процедурной семантики Пролога в их связи с логикой, проанализированы Ллойдом (1984 г.).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сопоставление в Прологе соответствует некоторому действию в логике, называемому \i унификацией\i0  . Мы, однако, избегаем слова "унификация", так как по соображениям эффективности внести в большинстве пролог-систем сопоставление реализовано таким образом, что оно не полностью соответствует унификации (см. упражнение 2.10). Тем не менее, с практической точки зрения, такая приближенная унификация вполне допустима.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.10.\b0   Что будет, если пролог-системе задать такой вопрос:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- X = f( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Успешным или неуспешным будет здесь сопоставление? По определению унификации в логике, сопоставление должно быть неуспешным, а что будет в соответствии с нашим определением сопоставления из раздела 2.2? Попробуйте объяснить, почему многие реализации Пролога отвечают на вышеприведенный вопрос так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = f(f(f(f(f(f(f(f(f(f(f(f(f(f(f( ...\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К настоящему моменту мы изучили нечто вроде базового Пролога, который называют еще "чистый Пролог". Он "чист", потому что довольно точно соответствует формальной логике. Расширения, преследующие цель приспособить язык к некоторым практическим нуждам, будут изучены дальше (гл. 3, 5, 6. 7). Важными моментами данной главы являются следующие:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Простые объекты в Прологе — это \i атомы\i0  , \i переменные\i0   и \i числа\i0  . Структурные объекты, или \i структуры\i0  , используются для представления объектов, которые состоят из нескольких компонент.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Структуры строятся посредством \i функторов\i0  . Каждый функтор определяется своими именем и арностью.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Тип объекта распознается исключительно по его синтаксической форме.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Область известности (лексический диапазон)\i0   переменных — одно предложение. Поэтому одно и то же имя в двух предложениях обозначает две разные переменные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Структуры могут быть естественным образом изображены в виде деревьев. Пролог можно рассматривать как язык обработки деревьев.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Операция \i сопоставление\i0   берет два терма и пытается сделать их идентичными, подбирая соответствующую конкретизацию переменных в обоих термах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Сопоставление, если оно завершается успешно, в качестве результата выдает \i наиболее общую\i0   конкретизацию переменных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Декларативная семантика\i0   Пролога определяет, является ли целевое утверждение истинным, исходя из данной программы, и если оно истинно, то для какой конкретизации переменных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Запятая между целями означает их конъюнкцию. Точка с запятой между целями означает их дизъюнкцию.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Процедурная семантика\i0   Пролога — это процедура достижения списка целей в контексте данной программы. Процедура выдает истинность или ложность списка целей и соответствующую конкретизацию переменных. Процедура осуществляет автоматический возврат для перебора различных вариантов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Декларативный смысл программ на "чистом Прологе" не зависит от порядка предложений и от порядка целей в предложениях.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Процедурный смысл существенно зависит от порядка целей и предложений. Поэтому порядок может повлиять на эффективность программы; неудачный порядок может даже привести к бесконечным рекурсивным вызовам.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Имея декларативно правильную программу, можно улучшить ее эффективность путем изменения порядка предложений и целей при сохранении ее декларативной правильности. Переупорядочивание — один из методов предотвращения зацикливания.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Кроме переупорядочивания существуют и другие, более общие методы предотвращения зацикливания, способствующие получению процедурно правильных программ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В данной главе обсуждались следующие понятия:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   объекты данных:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      атом, число, переменная, структура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   терм\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   функтор, арность функтора\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   главный функтор терма\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   сопоставление термов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   наиболее общая конкретизация\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   декларативная семантика\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   конкретизация предложений,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     вариант предложения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   процедурная семантика\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   вычисление целевого утверждения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Clocksin W. F. and Mellish С. S. (1981). \i Programming in Prolog.\i0   Springer-Verlag. [Имеется перевод: Клоксин У., Меллиш К. Программирование на языке Пролог. — М.: Мир, 1987.]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Lloyd J. W. (1984). \i Foundations of Logic Programming.\i0   Springer-Verlag.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Nilsson N. J. (1981). \i Principies of Artificial Intelligence.\i0   Tioga; Springer-Verlag.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Robinson A. J. (1965). \i A machine-oriented logic based on the resolution principle. JACM \i0  \b 12:\b0   23-41. [Имеется перевод: Робинсон Дж. Машинно-ориентированная логика, основанная на принципе резолюции. — В кн. Кибернетический сборник, вып. 7, 1970, с. 194–218.] \par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 3\par
Списки, операторы, арифметика\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой главе мы будем изучать специальные способы представления списков. Список - один из самых простых и полезных типов структур. Мы рассмотрим также некоторые программы для выполнения типовых операций над списками и, кроме того, покажем, как можно просто записывать арифметические выражения и операторы, что во многих случаях позволит улучшить "читабельность" программ. Базовый Пролог (глава 2), расширенный этими тремя добавлениями, станет удобной основой для составления интересных программ.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 3.1. Представление списков\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Список\i0   — это простая структура данных, широко используемая в нечисловом программировании. Список — это последовательность, составленная из произвольного числа элементов, например энн\b , \b0  теннис\b , \b0  том\b , \b0  лыжи. На Прологе это записывается так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ энн, теннис, том, лыжи ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако таково лишь внешнее представление списков. Как мы уже видели в гл. 2, все структурные объекты Пролога — это деревья. Списки не являются исключением из этого правила.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каким образом можно представить список в виде стандартного прологовского объекта? Мы должны рассмотреть два случая: пустой список и не пустой список. В первом случае список записывается как атом  [].  Во втором случае список следует рассматривать как структуру состоящую из двух частей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) первый элемент, называемый \i головой\i0   списка;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) остальная часть списка, называемая \i хвостом\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, для списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ энн, теннис, том, лыжи ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 энн — это голова, а хвостом является список\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ теннис, том, лыжи ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В общем случае, головой может быть что угодно (любой прологовский объект, например, дерево или переменная); хвост же должен быть списком. Голова соединяется с хвостом при помощи специального функтора. Выбор этого функтора зависит от конкретной реализации Пролога; мы будем считать, что это точка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .( Голова, Хвост)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поскольку Хвост — это список, он либо пуст, либо имеет свои собственную голову и хвост. Таким образом, выбранного способа представления списков достаточно для представления списков любой длины. Наш список представляется следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 .( энн, .( теннис, .( том, .( лыжи, [] ) ) ) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 3.1 изображена соответствующая древовидная структура. Заметим, что показанный выше пример содержит пустой список []. Дело в том, что самый последний хвост является одноэлементным списком:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ лыжи ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хвост этого списка пуст\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ лыжи ] = .( лыжи, [] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотренный пример показывает, как общий принцип структуризации объектов данных можно применить к спискам любой длины. Из нашего примера также видно, что такой примитивный способ представления в случае большой глубины вложенности подэлементов в хвостовой части списка может привести к довольно запутанным выражениям. Вот почему в Прологе предусматривается более лаконичный способ изображения списков, при котором они записываются как последовательности элементов, заключенные в квадратные скобки. Программист может использовать оба способа, но представление с квадратными скобками, конечно, в большинстве случаев пользуется предпочтением. Мы, однако, всегда будем помнить, что это всего лишь косметическое улучшение и что во внутреннем представлении наши списки выглядят как деревья. При выводе же они автоматически преобразуются в более лаконичную форму представления. Так, например, возможен следующий диалог:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- Список1 = [а, b, с],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Список2 = (a, .(b, .(c,[]) ) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список1 = [а, b, с]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список2 = [а, b, с]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- Увлечения1 = .( теннис, .(музыка, [] ) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Увлечения2 = [лыжи, еда],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  L = [энн, Увлечения1, том, Увлечения2].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Увлечения1 = [теннис, музыка]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Увлечения2 = [лыжи, еда]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [энн, [теннис, музыка], том, [лыжи, еда]]\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 3.1.\b0   Представление списка [энн, теннис, том, лыжи] в виде дерева.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведенный пример также напоминает вам о том, что элементами списка могут быть любые объекты, в частности тоже списки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На практике часто бывает удобным трактовать хвост списка как самостоятельный объект. Например, пусть\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [а, b, с]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда можно написать:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хвост = [b, с] и L = .(а, Хвост)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы выразить это при помощи квадратных скобок, в Прологе предусмотрено еще одно расширение нотации для представления списка, а именно вертикальная черта, отделяющая голову от хвоста:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [а | Хвост]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На самом деле вертикальная черта имеет более общий смысл: мы можем перечислить любое количество элементов списка, затем поставить символ "|", а после этого — список остальных элементов. Так, только что рассмотренный пример можно представить следующими различными способами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [а, b, с] = [а | [b, с]] = [a, b | [c]] = [a, b, c | [ ]]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подытожим:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Список — это структура данных, которая либо пуста, либо состоит из двух частей: \i головы\i0   и \i хвоста\i0  . Хвост в свою очередь сам является списком.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Список рассматривается в Прологе как специальный частный случай двоичного дерева. Для повышения наглядности программ в Прологе предусматриваются специальные средства для списковой нотации, позволяющие представлять списки в виде\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ Элемент1, Элемент2, ... ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ Голова | Хвост ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ Элемент1, Элемент2, ... | Остальные]\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 3.2. Некоторые операции над списками\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Списки можно применять для представления множеств, хотя и существует некоторое различие между этими понятиями: порядок элементов множества не существенен, в то время как для списка этот порядок имеет значение; кроме того, один н тот же объект может встретиться в списке несколько раз. Однако наиболее часто используемые операции над списками аналогичны операциям над множествами. Среди них\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • проверка, является ли некоторый объект элементом списка, что соответствует проверке объекта на принадлежность множеству;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • конкатенация (сцепление) двух списков, что соответствует объединению множеств;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • добавление нового объекта в список или удаление некоторого объекта из него.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В оставшейся части раздела мы покажем программы, реализующие эти и некоторые другие операции над списками.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 3.2.1. Принадлежность к списку\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы представим отношение принадлежности как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где X — объект, а L — список. Цель принадлежит( X, L) истинна, если элемент X встречается в L. Например, верно что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( b, [а, b, с] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и, наоборот, не верно, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит b, [а, [b, с] ] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 но\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит [b, с], [а, [b, с]] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинно. Составление программы для отношения принадлежности может быть основано на следующих соображениях:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) X есть голова L, либо\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) X принадлежит хвосту L.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это можно записать в виде двух предложений, первое из которых есть простой факт, а второе — правило:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [X | Хвост ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит ( X, [Голова | Хвост ] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, Хвост).\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 3.2.2. Сцепление (конкатенация)\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для сцепления списков мы определим отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( L1, L2, L3)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь L1 и L2 — два списка, a L3 — список, получаемый при их сцеплении. Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [а, b], [c, d], [a, b, c, d] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинно, а\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [а, b], [c, d], [a, b, a, c, d] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ложно. Определение отношения конк, как и раньше, содержит два случая в зависимости от вида первого аргумента L1:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Если первый аргумент пуст, тогда второй и третий аргументы представляют собой один и тот же список (назовем его L), что выражается в виде следующего прологовского факта:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [], L, L ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Если первый аргумент отношения конк не пуст, то он имеет голову и хвост в выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [X | L1]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 3.2 показано, как производится сцепление списка [X | L1] с произвольным списком L2. Результат сцепления — список [X | L3], где L3 получен после сцепления списков L1 и L2. На прологе это можно записать следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [X | L1, L2, [X | L3]):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( L1, L2, L3).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 3.2.\b0   Конкатенация списков.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Составленную программу можно теперь использовать для сцепления заданных списков, например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- конк( [a, b, с], [1, 2, 3], L ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [a, b, c, 1, 2, 3]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- конк( [а, [b, с], d], [а, [], b], L ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [a, [b, c], d, а, [], b]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хотя программа для конк выглядит довольно просто, она обладает большой гибкостью и ее можно использовать многими другими способами. Например, ее можно применять как бы в обратном направлении для \i разбиения\i0   заданного списка на две части:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- конк( L1, L2, [а, b, с] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L1 = []\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L2 = [а, b, c];\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L1 = [а]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L2 = [b, с];\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L1 = [а, b]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L2 = [c];\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L1 = [а, b, с]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L2 = [];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no            (нет)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список [а, b, с] разбивается на два списка четырьмя способами, и все они были обнаружены нашей программой при помощи механизма автоматического перебора.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нашу программу можно также применить для поиска в списке комбинации элементов, отвечающей некоторому условию, задаваемому в виде шаблона или образца. Например, можно найти все месяцы, предшествующие данному, и все месяцы, следующие за ним, сформулировав такую цель:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- конк( До, [май | После ],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [янв, фев, март, апр, май, июнь,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   июль, авг, сент, окт, ноябрь, дек]).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 До = [янв, фев, март, апр]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После = [июнь, июль, авг, сент, окт, ноябрь, дек].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее мы сможем найти месяц, непосредственно предшествующий маю, и месяц, непосредственно следующий за ним, задав вопрос:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- конк( _, [Месяц1, май, Месяц2 | _ ],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [янв, февр, март, апр, май, июнь,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   июль, авг, сент, окт, ноябрь, дек]).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Месяц1 = апр\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Месяц2 = июнь\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Более того, мы сможем, например, удалить из некоторого списка L1 все, что следует за тремя последовательными вхождениями элемента z в L1 вместе с этими тремя z. Например, это можно сделать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- L1 = [a, b, z, z, c, z, z, z, d, e],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( L2, [z, z, z | _ ], L1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L1 = [a, b, z, z, c, z, z, z, d, e]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L2 = [a, b, z, z, c]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы уже запрограммировали отношение принадлежности. Однако, используя конк, можно было бы определить это отношение следующим эквивалентным способом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит1( X, L) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( L1, [X | L2], L).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 3.3.\b0   Процедура принадлежит1 находит элемент в заданном списке, производя по нему последовательный поиск.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом предложении сказано: "X принадлежит L, если список L можно разбить на два списка таким образом, чтобы элемент X являлся головой второго из них. Разумеется, принадлежит1 определяет то же самое отношение, что и принадлежит. Мы использовали другое имя только для того, чтобы различать таким образом две разные реализации этого отношения, Заметим, что, используя анонимную переменную, можно записать вышеприведенное предложение так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит1( X, L) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( _, [X | _ ], L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Интересно сравнить между собой эти две реализации отношения принадлежности. Принадлежит имеет довольно очевидный процедурный смысл:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Для проверки, является ли X элементом списка L, нужно\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (1) сначала проверить, не совпадает ли голова списка L с X, а затем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (2) проверить, не принадлежит ли X хвосту списка L.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С другой стороны, принадлежит1, наоборот, имеет очевидный декларативный смысл, но его процедурный смысл не столь очевиден.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Интересным упражнением было бы следующее: выяснить, как в действительности принадлежит1 что-либо вычисляет. Некоторое представление об этом мы получим, рассмотрев запись всех шагов вычисления ответа на вопрос:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  принадлежит1( b, [а, b, с] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 3.3 приведена эта запись. Из нее можно заключить, что принадлежит1 ведет себя точно так же, как и принадлежит. Он просматривает список элемент за элементом до тех пор, пока не найдет нужный или пока не кончится список.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.1.\b0   (а) Используя отношение конк, напишите цель, соответствующую вычеркиванию трех последних элементов списка L, результат — новый список L1. Указание: L — конкатенация L1 и трехэлементного списка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) Напишите последовательность целей для порождения списка L2, получающегося из списка L вычеркиванием его трех первых и трех последних элементов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.2.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 последний( Элемент, Список)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 так, чтобы Элемент являлся последним элементом списка Список. Напишите два варианта определения: (а) с использованием отношения конк, (b) без использования этого отношения.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 3.2.3. Добавление элемента\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наиболее простой способ добавить элемент в список — это вставить его в самое начало так, чтобы он стал его новой головой. Если X — это новый элемент, а список, в который X добавляется — L, тогда результирующий список — это просто\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [X | L]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом, для того, чтобы добавить новый элемент в начало списка, не надо использовать никакой процедуры. Тем не менее, если мы хотим определить такую процедуру в явном виде, то ее можно представить в форме такого факта:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( X, L, [X | L] ).\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 3.2.4. Удаление элемента\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Удаление элемента X из списка L можно запрограммировать в виде отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( X, L, L1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где L1 совпадает со списком L, у которого удален элемент X. Отношение удалить можно определить аналогично отношению принадлежности. Имеем снова два случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Если X является головой списка, тогда результатом удаления будет хвост этого списка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Если X находится в хвосте списка, тогда его нужно удалить оттуда.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( X, [X | Хвост], Хвост).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( X, [Y | Хвост], [Y | Хвост1] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( X, Хвост, Хвост1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 как и принадлежит, отношение удалить по природе своей недетерминировано. Если в списке встречается несколько вхождений элемента X, то удалить сможет исключить их все при помощи возвратов. Конечно, вычисление по каждой альтернативе будет удалять лишь одно вхождение X, оставляя остальные в неприкосновенности. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- удалить( а, [а, b, а, а], L].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [b, а, а];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [а, b, а];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [а, b, а];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no            (нет)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При попытке исключить элемент, не содержащийся в списке, отношение удалить потерпит неудачу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношение удалить можно использовать в обратном направлении для того, чтобы добавлять элементы в список, вставляя их в произвольные места. Например, если мы хотим во все возможные места списка [1, 2, 3] вставить атом а, то мы можем это сделать, задав вопрос: "Каким должен быть список L, чтобы после удаления из него элемента а получился список [1, 2, 3]?"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- удалить( а, L, [1, 2, 3] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [а, 1, 2, 3];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [1, а, 2, 3];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [1, 2, а, 3];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [1, 2, 3, а];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nо               (нет)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вообще операция по внесению X в произвольное место некоторого списка Список, дающее в результате БольшийСписок, может быть определена предложением:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внести( X, Список, БольшийСписок) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( X, БольшийСписок, Список).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В принадлежит1 мы изящно реализовали отношение принадлежности через конк. Для проверки на принадлежность можно также использовать и удалить. Идея простая: некоторый X принадлежит списку Список, если X можно из него удалить:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит2( X, Список) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( X, Список, _ ).\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 3.2.5. Подсписок\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим теперь отношение подсписок. Это отношение имеет два аргумента — список L и список S, такой, что S содержится в L в качестве подсписка. Так отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подсписок( [c, d, e], [a, b, c, d, e, f] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеет место, а отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подсписок( [c, e], [a, b, c, d, e, f] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нет. Пролог-программа для отношения подсписок может основываться на той же идее, что и принадлежит1, только на этот раз отношение более общо (см. рис. 3.4).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 3.4.\b0   Отношения принадлежит и подсписок.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Его можно сформулировать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  S является подсписком L, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   (1) L можно разбить на два списка L1 и L2 и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   (2) L2 можно разбить на два списка S и L3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как мы видели раньше, отношение конк можно использовать для разбиения списков. Поэтому вышеприведенную формулировку можно выразить на Прологе так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подсписок( S, L) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( L1, L2, L),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( S, L3, L2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ясно, что процедуру подсписок можно гибко использовать различными способами. Хотя она предназначалась для проверки, является ли какой-либо список подсписком другого, ее можно использовать, например, для нахождения всех подсписков данного списка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  подсписок( S, [а, b, с] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [a];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [а, b];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [а, b, с];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [b];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 3.2.6. Перестановки\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иногда бывает полезно построить все перестановки некоторого заданного списка. Для этого мы определим отношение перестановка с двумя аргументами. Аргументы — это два списка, один из которых является перестановкой другого. Мы намереваемся порождать перестановки списка с помощью механизма автоматического перебора, используя процедуру перестановка, подобно тому, как это делается в следующем примере:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- перестановка( [а, b, с], P).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P = [а, b, с];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P = [а, с, b];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P = [b, а, с];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 3.5.\b0   Один из способов построения перестановки списка [X | L].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа для отношения перестановка в свою очередь опять может основываться на рассмотрении двух случаев в зависимости от вида первого списка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Если первый список пуст, то и второй список должен быть пустым.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Если первый список не пуст, тогда он имеет вид [X | L], и перестановку такого списка можно построить так, как это показано на рис. 3.5: вначале получить список L1 — перестановку L, а затем внести X в произвольную позицию L1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Два прологовских предложения, соответствующих этим двум случаям, таковы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перестановка( [], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перестановка( [X | L ], P) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перестановка( L, L1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внести( X, L1, P).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другой вариант этой программы мог бы предусматривать удаление элемента X из первого списка, перестановку оставшейся его части — получение списка P, а затем добавление X в начало списка P. Соответствующая программа такова:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перестановка2( [], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перестановка2( L, [X | P] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( X, L, L1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перестановка2( L1, P).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поучительно проделать несколько экспериментов с нашей программой перестановки. Ее нормальное использование могло бы быть примерно таким:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  перестановка( [красный, голубой, зеленый], P).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как и предполагалось, будут построены все шесть перестановок:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P = [ красный, голубой, зеленый];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P = [ красный, зеленый, голубой];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P = [ голубой, красный, зеленый];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P = [ голубой, зеленый, красный];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P = [ зеленый, красный, голубой];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P = [ зеленый, голубой, красный];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no                               (нет)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведем другой вариант использования процедуры перестановка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  перестановка( L, [а, b, с] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша первая версия, перестановка, произведет успешную конкретизацию L всеми шестью перестановками. Если пользователь потребует новых решений, он никогда не получит ответ "нет", поскольку программа войдет в бесконечный цикл, пытаясь отыскать новые несуществующие перестановки. Вторая версия, перестановка2, в этой ситуации найдет только первую (идентичную) перестановку, а затем сразу зациклится. Следовательно, при использовании этих отношений требуется соблюдать осторожность.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.3.\b0   Определите два предиката\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 четнаядлина( Список) и нечетнаядлина( Список)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 таким образом, чтобы они были истинными, если их аргументом является список четной или нечетной длины соответственно. Например, список [а, b, с, d] имеет четную длину, a [a, b, c] — нечетную.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.4.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обращение( Список, ОбращенныйСписок),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которое обращает списки. Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обращение( [a, b, c, d], [d, c, b, a] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.5.\b0   Определите предикат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 палиндром( Список).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список называется палиндромом, если он читается одинаково, как слева направо, так и справа налево. Например, [м, а, д, а, м].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.6.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сдвиг( Список1, Список2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 таким образом, чтобы Список2 представлял собой Список1, "циклически сдвинутый" влево на один символ. Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- сдвиг( [1, 2, 3, 4, 5], L1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сдвиг1( LI, L2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дает\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L1 = [2, 3, 4, 5, 1]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L2 = [3, 4, 5, 1, 2]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.7.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перевод( Список1, Список2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 для перевода списка чисел от 0 до 9 в список соответствующих слов. Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перевод( [3, 5, 1, 3], [три, пять, один, три] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Используйте в качестве вспомогательных следующие отношения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает( 0, нуль).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает( 1, один).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает( 2, два).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.8.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подмножество( Множество, Подмножество)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Множество и Подмножество — два списка представляющие два множества. Желательно иметь возможность использовать это отношение не только для проверки включения одного множества в другое, но и для порождения всех возможных подмножеств заданного множества. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  подмножество( [а, b, с], S ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [a, b, c];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [b, c];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [c];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [a, c];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [a];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.9.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбиениесписка( Список, Список1, Список2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 так, чтобы оно распределяло элементы списка между двумя списками Список1 и Список2 и чтобы эти списки были примерно одинаковой длины. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбиениесписка( [а, b, с, d, e], [a, с, e], [b, d]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.10.\b0   Перепишите программу об обезьяне и бананах из главы 2 таким образом, чтобы отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можетзавладеть( Состояние, Действия)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 давало не только положительный или отрицательный ответ, но и порождало последовательность действий обезьяны, приводящую ее к успеху. Пусть Действия будет такой последовательностью, представленной в виде списка ходов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Действия = [ перейти( дверь, окно),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              передвинуть( окно, середина),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              залезть, схватить ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.11.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 линеаризация( Список, ЛинейныйСписок)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Список может быть списком списков, а ЛинейныйСписок — это тот же список, но "выровненный" таким образом, что элементы его подсписков составляют один линейный список. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- линеаризация( [а, d, [с, d], [], [[[e]]], f, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [a, b, c, d, e, f]\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 3.3. Операторная запись (нотация)\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В математике мы привыкли записывать выражения в таком виде:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i 2*a + b*с\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где + и * — это операторы, а \i 2\i0  , \i а\i0  , \i b\i0  ,\i  с\i0   — аргументы. В частности, + и * называют \i инфиксными\i0   операторами, поскольку они появляются \i между\i0   своими аргументами. Такие выражения могут быть представлены в виде деревьев, как это сделано на рис. 3.6, и записаны как прологовские термы с + и * в качестве функторов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 +( *( 2, а), *( b, с) )\par
\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 3.6.\b0   Представление выражения \i 2*а+b*с\i0   в виде дерева.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поскольку мы обычно предпочитаем записывать такие выражения в привычной инфиксной форме операторов, Пролог обеспечивает такое удобство. Поэтому наше выражение, записанное просто как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2*а + b*с\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 будет воспринято правильно. Однако это лишь внешнее представление объекта, которое будет автоматически преобразовано в обычную форму прологовских термов. Такой терм выводится пользователю снова в своей внешней инфиксной форме.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Выражения рассматриваются Прологом просто как дополнительный способ записи, при котором не вводятся какие-либо новые принципы структуризации объектов данных. Если мы напишем а + b,  Пролог поймет эту запись, как если бы написали +(а, b). Для того, чтобы Пролог правильно воспринимал выражения типа а + b*с, он должен знать, что * связывает сильнее, чем +. Будем говорить, что + имеет более низкий приоритет, чем *. Поэтому верная интерпретация выражений зависит от приоритетов операторов. Например, выражение а + b*с, в принципе можно понимать и как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 +( а, *( b, с) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 *( +( а, b), с)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Общее правило состоит в том, что оператор с самым низким приоритетом расценивается как главный функтор терма. Если мы хотим, чтобы выражения, содержащие + и *, понимались в соответствии с обычными соглашениями, то + должен иметь более низкий приоритет, чем *. Тогда выражение а + b*с означает то же, что и а + (b*с). Если имеется в виду другая интерпретация, то это надо указать явно с помощью скобок, например (а+b)*с.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программист может вводить свои собственные операторы. Так, например, можно определить атомы имеет и поддерживает в качестве инфиксных операторов, а затем записывать в программе факты вида:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 питер имеет информацию.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пол поддерживает стол.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти факты в точности эквивалентны следующим:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеет( питер, информацию).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 поддерживает( пол, стол).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программист определяет новые операторы, вводя в программу особый вид предложений, которые иногда называют \i директивами\i0  . Такие предложения играют роль определений новых операторов. Определение оператора должно появиться в программе раньше, чем любое выражение, использующее этот оператор. Например, оператор имеет можно определить директивой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 600, xfx, имеет).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такая запись сообщит Прологу, что мы хотим использовать "имеет" в качестве оператора с приоритетом 600 и типом 'xfx', обозначающий одну из разновидностей инфиксного оператора. Форма спецификатора 'xfx' указывает на то, что оператор, обозначенный через 'f', располагается между аргументами, обозначенными через 'х'.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание на то, что определения операторов не содержат описания каких-либо операций или действий. В соответствии с принципами языка \i ни\i0   с \i одним оператором не связывается каких-либо операций над данными\i0   (за исключением особых, редких случаев). Операторы обычно используются так же, как и функторы, только для объединения объектов в структуры и не вызывают действия над данными, хотя само слово "оператор", казалось бы, должно подразумевать какое-то действие.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имена операторов это атомы, а их приоритеты — точнее, номера их приоритетов — должны находиться в некотором диапазоне, зависящем от реализации. Мы будем считать, что этот диапазон располагается в пределах от 1 до 1200.{\up6 \chftn}{\footnote \s17 \qj\snext0\f1\fs20\b0\i0\fi200\li0\ri0 {\s17 \qj\snext0\f1\fs20\b0\i0\fi200\li0\ri0 \up6 \chftn } \s17 \qj\snext0\f1\fs20\b0\i0\fi200\li0\ri0 Чем выше приоритет, тем меньше его номер. — \i Прим. перев\i0  .\par
}
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существуют три группы типов операторов, обозначаемые спецификаторами, похожими на xfx:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) инфиксные операторы трех типов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 xfx xfy yfx\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) префиксные операторы двух типов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 fx fy\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) постфиксные операторы двух типов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 хf yf\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Спецификаторы выбраны с таким расчетом, чтобы нагляднее отразить структуру выражения, в котором 'f' соответствует оператору, а 'x' и 'y' представляют его аргументы. Расположение 'f' между аргументами указывает на то, что оператор инфиксный. Префиксные и постфиксные спецификаторы содержат только один аргумент, который, соответственно, либо следует за оператором, либо предшествует ему.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. op3.7.\b0    Две интерпретации выражения а-b-с в предположении, что '-' имеет приоритет 500. Если тип '-' есть yfx, то интерпретация 2 неверна, так как приоритет b-с не выше, чем приоритет '-'.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Между 'x' и 'y' есть разница. Для ее объяснения нам потребуется ввести понятие \i приоритета аргумента\i0  . Если аргумент заключен в скобки или не имеет структуры (является простым объектом), тогда его приоритет равен 0; если же он структурный, тогда его приоритет равен приоритету его главного функтора. С помощью 'x' обозначается аргумент, чей приоритет должен быть строго выше приоритета оператора (т e. его номер строго меньше номера приоритета оператора); с помощью 'y' обозначается аргумент, чей приоритет выше или равен приоритету оператора.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такие правила помогают избежать неоднозначности при обработке выражений, в которых встречаются операторы с одинаковым приоритетом. Например, выражение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а-b-с\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обычно понимается как (а-b)-с, а не как а-(b-с). Чтобы обеспечить такую обычную интерпретацию, оператор '-' следует определять как yfx. На рис. 3.7 показано, каким образом исключается вторая интерпретация.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве еще одного примера рассмотрим оператор not (логическое отрицание "не"). Если not oпределён как fy, тогда выражение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not not p\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 записано верно; однако, если not определен как fx, оно некорректно, потому что аргументом первого not является структура not p, которая имеет тот же приоритет, что и not. В этом случае выражение следует писать со скобками:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 not (not p)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 1200, xfx, ':-').\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 1200, fx, [:-, ?-] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 1100, xfy, ';').\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 1000, xfy, ',').\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 700, xfx, [=, is, <, >, =<, >=, ==, =\\=, \\==, =:=]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 500, yfx, [+, -] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 500, fx, [+, -, not] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 400, yfx, [*, /, div] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 300, xfx, mod).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 3.8.\b0   Множество предопределенных операторов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для удобства некоторые операторы в пролог-системах определены заранее, чтобы ими можно было пользоваться сразу, без какого-либо определения их в программе. Набор таких операторов и их приоритеты зависят от реализации. Мы будем предполагать, что множество этих "стандартных" операторов ведет себя так, как если бы оно было определено с помощью предложений, приведенных на рис. 3.8. Как видно из того же рисунка, несколько операторов могут быть определены в одном предложении, если только они все имеют одинаковый приоритет и тип. В этом случае имена операторов записываются в виде списка. Использование операторов может значительно повысить наглядность, "читабельность" программы. Для примера предположим, что мы пишем программу для обработки булевских выражений. В такой программе мы, возможно, захотим записать утверждение одной из теорем де Моргана, которое в математических обозначениях записывается так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ~ (А & В) <===> ~А v ~В\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведем один из способов записи этого утверждения в виде прологовского предложения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 эквивалентно( not( и( А, В)), или( not( A, not( B))).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако хорошим стилем программирования было бы попытаться сохранить по возможности больше сходства между видом записи исходной задачи и видом, используемом в программе ее решения. В нашем примере этого можно достичь почти в полной мере, применив операторы. Подходящее множество операторов для наших целей можно определить так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 800, xfx, <===>).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 700, xfy, v).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 600, хfу, &).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 500, fy, ~).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь правило де Моргана можно записать в виде следующего факта:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ~(А & В) <===> ~А v ~В.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В соответствии с нашими определениями операторов этот терм понимается так, как это показано на рис. 3.9.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 3.9.\b0   Интерпретация терма ~(А & В) <===> ~A v ~В\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подытожим:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Наглядность программы часто можно улучшить, использовав операторную нотацию. Операторы бывают инфиксные, префиксные и постфиксные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В принципе, с оператором не связываются никакие действия над данными, за исключением особых случаев. Определение оператора не содержит описания каких-либо действий, оно лишь вводит новый способ записи. Операторы, как и функторы, лишь связывают компоненты в единую структуру.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Программист может вводить свои собственные операторы. Каждый оператор определяется своим именем, приоритетом и типом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Номер приоритета — это целое число из некоторого диапазона, скажем, между 1 и 1200. Оператор с самым больший номером приоритета соответствует главному функтору выражения, в котором этот оператор встретился. Операторы с меньшими номерами приоритетов связывают свои аргументы сильнее других операторов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Тип оператора зависит от двух условий: (1) его расположения относительно своих аргументов, (2) приоритета его аргументов по сравнению с его собственным. В спецификаторах, таких, как xfy, x обозначает аргумент, чей номер приоритета строго меньше номера приоритета оператора; y — аргумент с номером приоритета, меньшим или равным номеру приоритета оператора.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.12.\b0   Если принять такие определения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 300, xfy, играет_в).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 200, xfy, и).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то два следующих терма представляют собой синтаксически правильные объекты:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Tepм1 = джимми играет_в футбол и сквош\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Терм1 = сьюзан играет_в теннис и баскетбол и волейбол\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как эти термы интерпретируются пролог-системой? Каковы их главные функторы и какова их структура?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.13.\b0   Предложите подходящее определение операторов ("работает", "в", "нашем"), чтобы можно было писать предложения типа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 диана работает секретарем в нашем отделе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а затем спрашивать:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- Кто работает секретарем в нашем отделе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кто = диана\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- диана работает Кем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кем = секретарем в нашем отдела\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.14.\b0   Рассмотрим программу:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 t( 0+1, 1+0).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 t( X+0+1, X+1+0).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 t( X+1+1, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  t( X+1, X1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  t( X1+1, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как данная программа будет отвечать на ниже перечисленные вопросы, если '+' — это (как обычно) инфиксный оператор типа yfx?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) ?- t( 0+1, А).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) ?- t( 0+1+1, В).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (с) ?- t( 1+0+1+1+1, С).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d) ?- t( D, 1+1+1+0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.15.\b0   В предыдущем разделе отношения между списка ми мы записывали так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( Элемент, Список),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Список1, Список2, Список3),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( Элемент, Список, НовыйСписок), ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предположим, что более предпочтительной для нас является следующая форма записи:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Элемент входит_в Список,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конкатенация_списков Список1 и Список2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   дает Список3,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удаление_элемента Элемент из_списка Список\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   дает НовыйСписок, ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Определите операторы "входит_в", "конкатенация_списков", "и" и т.д. таким образом, чтобы обеспечить эту возможность. Переопределите также и соответствующие процедуры.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 3.4. Арифметические действия\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пролог рассчитан главным образом на обработку символьной информации, при которой потребность в арифметических вычислениях относительно мала. Поэтому и средства для таких вычислений довольно просты. Для осуществления основных арифметических действий можно воспользоваться несколькими предопределенными операторами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 +   сложение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 -   вычитание\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 *   умножение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /   деление\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mod модуль, остаток от целочисленного деления\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что это как раз тот исключительный случай. когда оператор может и в самом деле произвести некоторую операцию. Но даже и в этом случае требуется дополнительное указание на выполнение действия. Пролог-система знает, как выполнять вычисления, предписываемые такими операторами, но этого недостаточно для их непосредственного использования. Следующий вопрос - наивная попытка произвести арифметическое действие:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- X = 1 + 2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пролог-система "спокойно" ответит\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = 1 + 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а не X = 3, как, возможно, ожидалось. Причина этого проста: выражение 1 + 2 обозначает лишь прологовский терм, в котором + является функтором, а 1 и 2 — его аргументами. В вышеприведенной цели нет ничего, что могло бы заставить систему выполнить операцию сложения. Для этого в Прологе существует специальный оператор is (есть). Этот оператор заставит систему выполнить вычисление. Таким образом, чтобы правильно активизировать арифметическую операцию, надо написать:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- X is 1 + 2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот теперь ответ будет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сложение здесь выполняется специальной процедурой, связанной с оператором +. Мы будем называть такие процедуры \i встроенными\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В Прологе не существует общепринятой нотации для записи арифметических действий, поэтому в разных реализациях она может слегка различаться. Например, оператор '/' может в одних реализациях обозначать целочисленное деление, а в других — вещественное. В данной книге под '/' мы подразумеваем вещественное деление, для целочисленного же будем использовать оператор div. В соответствии с этим, на вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- X is 3/2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Y is 3 div 2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответ должен быть такой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = 1.5\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y = 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Левым аргументом оператора is является простой объект. Правый аргумент — арифметическое выражение, составленное с помощью арифметических операторов, чисел и переменных. Поскольку оператор is запускает арифметические вычисления, к моменту начала вычисления этой цели все ее переменные должны быть уже конкретизированы какими-либо числами. Приоритеты этих предопределенных арифметических операторов (см. рис. 3.8) выбраны с таким расчетом, чтобы операторы применялись к аргументам в том порядке, который принят в математике. Чтобы изменить обычный порядок вычислений, применяются скобки (тоже, как в математике). Заметьте, что +, -, *, / и div определены, как yfx, что определяет порядок их выполнения слева направо. Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X is 5 - 2 - 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 понимается как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X is (5 - 2) - 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Арифметические операции используются также и при \i сравнении\i0   числовых величин. Мы можем, например, проверить, что больше — 10000 или результат умножения 277 на 37, с помощью цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- 277 * 37 > 10000.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes            (да)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что точно так же, как и is, оператор '>' вызывает выполнение вычислений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предположим, у нас есть программа, в которую входит отношение рожд, связывающее имя человека с годом его рождения. Тогда имена людей, родившихся между 1950 и 1960 годами включительно, можно получить при помощи такого вопроса:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- рожд( Имя, Год),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Год >= 1950,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Год <= 1960.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ниже перечислены операторы сравнения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X > Y   X больше Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X < Y   X меньше Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X >= Y  X больше или равен Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X =< Y  X меньше или равен Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X =:= Y величины X и Y совпадают (равны)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X =\\= Y величины X и Y не равны\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание на разницу между операторами сравнения '=' и '=:=', например, в таких целях как X = Y и X =:= Y. Первая цель вызовет сопоставление объектов X и Y, и, если X и Y сопоставимы, возможно, приведет к конкретизации каких-либо переменных в этих объектах. Никаких вычислений при этом производиться не будет. С другой стороны, X =:= Y вызовет арифметическое вычисление и не может привести к конкретизации переменных. Это различие можно проиллюстрировать следующими примерами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- 1 + 2 =:= 2 + 1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- 1 + 2 = 2 + 1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- 1 + А = В + 2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А = 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В = 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте рассмотрим использование арифметических операций на двух простых примерах. В первом примере ищется наибольший общий делитель; во втором — определяется количество элементов в некотором списке.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если заданы два целых числа X и Y, то их наибольший общий делитель Д можно найти, руководствуясь следующими тремя правилами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Если X и Y равны, то Д равен X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Если X > Y, то Д равен наибольшему общему делителю X разности Y – X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Если Y < X, то формулировка аналогична правилу (2), если X и Y поменять в нем местами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На примере легко убедиться, что эти правила действительно позволяют найти наибольший общий делитель. Выбрав, скажем, X = 20 и Y = 25, мы, руководствуясь приведенными выше правилами, после серии вычитаний получим Д = 5.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти правила легко сформулировать в виде прологовской программы, определив трехаргументное отношение, скажем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нод( X , Y, Д)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда наши три правила можно выразить тремя предложениями так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нод( X, X, X).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нод( X, Y, Д) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X < Y,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Y1 is Y - X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  нод( X, Y1, Д).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нод( X, Y, Д) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Y < X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  нод( Y, X, Д).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Разумеется, с таким же успехом можно последнюю цель в третьем предложении заменить двумя:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X1 is X - Y,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нод( X1, Y, Д)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нашем следующем примере требуется произвести некоторый подсчет, для чего, как правило, необходимы арифметические действия. Примером такой задачи может служить вычисление длины какого-либо списка; иначе говоря, подсчет числа его элементов. Определим процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 длина( Список, N)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которая будет подсчитывать элементы списка Список и конкретизировать N полученным числом. Как и раньше, когда речь шла о списках, полезно рассмотреть два случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Если список пуст, то его длина равна 0.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Если он не пуст, то Список = [Голова1 | Хвост] и его длина равна 1 плюс длина хвоста Хвост.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти два случая соответствуют следующей программе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 длина( [], 0).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 длина( [ _ | Хвост], N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  длина( Хвост, N1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N is 1 + N1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Применить процедуру длина можно так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- длина( [a, b, [c, d], e], N).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 N = 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что во втором предложении этой процедуры две цели его тела нельзя поменять местами. Причина этого состоит в том, что переменная N1 должна быть конкретизирована до того, как начнет вычисляться цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 N is 1 + N1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом мы видим, что введение встроенной процедуры is привело нас к примеру отношения, чувствительного к порядку обработки предложений и целей. Очевидно, что процедурные соображения для подобных отношений играют жизненно важную роль.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Интересно посмотреть, что произойдет, если мы попытаемся запрограммировать отношение длина без использования is. Попытка может быть такой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 длина1( [ ], 0).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 длина1( [ _ | Хвост], N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  длина1( Хвост, N1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N = 1 + N1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь уже цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- длина1( [a, b, [c, d], e], N).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 породит ответ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 N = 1+(1+(1+(1+0)))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сложение ни разу в действительности не запускалось и поэтому ни разу не было выполнено. Но в процедуре длина1, в отличие от процедуры длина, мы можем поменять местами цели во втором предложении:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 длина1( _ | Хвост], N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N = 1 + N1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  длина1( Хвост, N1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такая версия длина1 будет давать те же результаты, что и исходная. Ее можно записать короче:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 длина1( [ _ | Хвост], 1 + N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  длина1( Хвост, N).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и она и в этом случае будет давать те же результаты. С помощью длина1, впрочем, тоже можно вычислять количество элементов списка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- длина( [а, b, с], N), Длина is N.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 N = 1+(1+(l+0))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Длина = 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Для выполнения арифметических действий используются встроенные процедуры.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Арифметические операции необходимо явно запускать при помощи встроенной процедуры is. Встроенные процедуры связаны также с предопределенными операторами +, -, *, /, div и mod.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • К моменту выполнения операций все их аргументы должны быть конкретизированы числами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Значения арифметических выражений можно сравнивать с помощью таких операторов, как <, =< и т.д. Эти операторы вычисляют значения своих аргументов.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.16.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mах( X, Y, Мах)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 так, чтобы Мах равнялось наибольшому из двух чисел X и Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.17.\b0   Определите предикат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 максспис( Список, Мах)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 так, чтобы Мах равнялось наибольшему из чисел, входящих в Список.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.18.\b0   Определите предикат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумспис( Список, Сумма)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 так, чтобы Сумма равнялось сумме чисел, входящих в Список.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.19.\b0   Определите предикат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 упорядоченный( Список)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 который принимает значение истина, если Список представляет собой упорядоченный список чисел. Например: упорядоченный [1, 5, 6, 6, 9, 12] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.20.\b0   Определите предикат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подсумма( Множ, Сумма, ПодМнож)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Множ это список чисел, Подмнож подмножество этих чисел, а сумма чисел из ПодМнож равна Сумма. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- подсумма( [1, 2, 5, 3, 2], 5, ПМ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ПМ = [1, 2, 2];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ПМ = [2, 3];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ПМ = [5];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.21.\b0   Определите процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 между( N1, N2, X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которая, с помощью перебора, порождает все целые числа X, отвечающие условию N1&#8804;X&#8804;N2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.22.\b0      Определите операторы 'если', 'то', 'иначе' и ':=" таким образом, чтобы следующее выражение стало правильным термом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если X > Y то Z := X иначе Z := Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Выберите приоритеты так, чтобы  'если' стал главным функтором. Затем определите отношение 'если' так, чтобы оно стало как бы маленьким интерпретатором выражений типа 'если-то-иначе'. Например, такого\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если Вел1 > Вел2 то Перем := Вел3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 иначе Перем := Вел4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Вел1, Вел2, Вел3 и Вел4 — числовые величины (или переменные, конкретизированные числами), а Перем — переменная. Смысл отношения 'если' таков: если значение Вел1 больше значения Вел2, тогда Перем конкретизируется значением Вел3, в противном случае — значением Вел4. Приведем пример использования такого интерпретатора:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- X = 2, Y = 3,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Вел2 is 2*X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Вел4 is 4*X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Если Y > Вел2 то Z := Y иначе Z := Вел4.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Если Z > 5 то W := 1 иначе W :=0.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y = 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Z = 8\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 W = 1\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вел2 = 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вел4 = 8\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Список — часто используемая структура. Он либо пуст, либо состоит из \i головы\i0   и \i хвоста\i0  , который в свою очередь также является списком. Для списков в Прологе имеется специальная нотация.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В данной главе рассмотрены следующие операции над списками: принадлежность к списку, конкатенация, добавление элемента, удаление элемента, удаление подсписка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Операторная запись\i0   позволяет программисту приспособить синтаксис программ к своим конкретным нуждам. С помощью операторов можно значительно повысить наглядность программ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Новые операторы определяются с помощью директивы op, в которой указываются его имя, тип и приоритет.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Как правило, с оператором не связывается никакой операции; оператор это просто синтаксическое удобство, обеспечивающее альтернативный способ записи термов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Арифметические операции выполняются с помощью встроенных процедур. Вычисление арифметических выражений запускается процедурой is, а также предикатами сравнения <, =< и т.д.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Понятия, введенные в данной главе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  список, голова списка, хвост списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  списковая нотация\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  операторы, операторная нотация\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  инфиксные, префиксные и постфиксные операторы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  приоритет операторов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  арифметические встроенные процедуры \par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 4\par
Использование структур: примеры\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Структуры данных вместе с сопоставлением, автоматическими возвратами и арифметикой представляют собой мощный инструмент программирования. В этой главе мы расширим навыки использования этого инструмента при помощи следующих учебных программных примеров: получение структурированной информации из базы данных, моделирование недетерминированного автомата, планирование маршрута поездки и решение задачи о расстановке восьми ферзей на шахматной доске. Мы увидим также, как в Прологе реализуется принцип абстракции данных.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 4.1. Получение структурированной информации из базы данных\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это упражнение развивает навыки представления структурных объектов данных и управления ими. Оно показывает также, что Пролог является естественным языком запросов к базе данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 База данных может быть представлена на Прологе в виде множества фактов. Например, в базе данных о семьях каждая семья может описываться одним предложением. На рис. 4.1 показано, как информацию о каждой семье можно представить в виде структуры. Каждая семья состоит из трех компонент: мужа, жены и детей. Поскольку количество детей в разных семьях может быть разным, то их целесообразно представить в виде списка, состоящего из произвольного числа элементов. Каждого члена семьи в свою очередь можно представить структурой, состоящей из четырех компонент: имени, фамилии, даты рождения и работы. Информация о работе — это либо "не работает", либо указание места работа и оклада (дохода). Информацию о семье, изображенной на рис. 4.1, можно занести в базу данных с помощью предложения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 семья( членсемьи( том, фокс, дата( 7, май, 1950),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  работает( bbс, 15200) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  членсемьи( энн, фокс, дата( 9, май, 1951), неработает),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [членсемьи( пат, фокс, дата( 5, май, 1973), неработает),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  членсемьи( джим, фокс, дата( 5, май, 1973), неработает) ] ).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 4.1.\b0   Структурированная информация о семье.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда база данных будет состоять из последовательности фактов, подобных этому, и описывать все семьи, представляющие интерес для нашей программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В действительности Пролог очень удобен для извлечения необходимой информации из такой базы данных. Здесь хорошо то, что можно ссылаться на объекты, не указывая в деталях всех их компонент. Можно задавать только \i структуру\i0   интересующих нас объектов и оставлять конкретные компоненты без точного описания или лишь с частичным описанием. На рис. 4.2 приведено несколько примеров. Так, а запросах к базе данных можно ссылаться на всех Армстронгов с помощью терма\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 семья( членсемьи( _, армстронг, _, _ ), _, _ )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Символы подчеркивания обозначают различные анонимные переменные, значения которых нас не заботят. Далее можно сослаться на все семьи с тремя детьми при помощи терма:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 семья( _, _, [ _, _, _ ])\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы найти всех замужних женщин, имеющих по крайней мере троих детей, можно задать вопрос:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ?-  семья( _, членсемьи( Имя, Фамилия, _, _ ), [ _, _, _ | _ ]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Главным моментом в этих примерах является то, что указывать интересующие нас объекты можно не только по их содержимому, но и по их структуре. Мы задаем одну структуру и оставляем ее аргументы в виде слотов (пропусков).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 4.2.\b0   Описания объектов по их структурным свойствам: (а) любая семья Армстронгов; (b) любая семья, имеющая ровно трех детей; (с) любая семья, имеющая по крайней мере три ребенка. Структура (с) дает возможность получить имя и фамилию жены конкретизацией переменных Имя и Фамилия.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно создать набор процедур, который служил бы утилитой, делающей взаимодействие с нашей базой данных более удобным. Такие процедуры являлись бы частью пользовательского интерфейса. Вот некоторые полезные процедуры для нашей базы данных:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 муж( X) :-     % X - муж\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  семья( X, _, _ ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 жена( X) :-    % X - жена\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  семья( _, X, _ ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ребенок( X) :- % X - ребенок\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  семья( _, _, Дети),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, Дети).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [X | L ]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [Y | L ]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, L).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 существует( Членсемьи) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Любой член семьи в базе данных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  муж( Членсемьи);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  жена( Членсемьи);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ребенок( Членсемьи).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дата рождения( Членсемьи( _, _, Дата, _ ), Дата).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доход( Членсемьи( _, _, _, работает( _, S) ), S).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Доход работающего\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доход( Членсемьи( _, _, _, неработает), 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Доход неработающего\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этими процедурами можно воспользоваться, например, в следующих запросах к базе данных:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Найти имена всех людей из базы данных:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   ?-  существует( членсемьи( Имя,Фамилия, _, _ )).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Найти всех детей, родившихся в 1981 году:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   ?-  ребенок( X), датарождения( X, дата( _, _, 1981) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Найти всех работающих жен:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   ?-  жена( членсемьи( Имя, Фамилия, _, работает( _, _ ))).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Найти имена и фамилии людей, которые не работают и родились до 1963 года:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   ?- существует членсемьи( Имя, Фамилия, дата( _, _, Год), неработает) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   Год < 1963.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Найти людей, родившихся до 1950 года, чей доход меньше, чем 8000:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   ?- существует( Членсемьи),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   датарождения( Членсемьи, дата( _, _, Год) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   Год < 1950,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   доход( Членсемьи, Доход),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   Доход < 8000.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Найти фамилии людей, имеющих по крайней мере трех детей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   ?-  семья( членсемьи( _, Фамилия, _, _ ), _, [ _, _, _ | _ ]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для подсчета общего дохода семья полезно определить сумму доходов людей из некоторого списка в виде двухаргументного отношения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 общий( Список_Людей, Сумма_их_доходов)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это отношение можно запрограммировать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 общий( [], 0). % Пустой список людей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 общий( [ Человек | Список], Сумма) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  доход( Человек, S),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % S - доход первого человека\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  общий( Список, Остальные),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Остальные - сумма доходов остальных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Сумма is S + Остальные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь общие доходы всех семей могут быть найдены с помощью вопроса:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- семья( Муж, Жена, Дети),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  общий( [Муж, Жена | Дети], Доход).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пусть отношение длина подсчитывает количество элементов списка, как это было определено в разд. 3.4. Тогда мы можем найти все семьи, которые имеют доход на члена семьи, меньший, чем 2000, при помощи вопроса:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- семья( Муж, Жена, Дети),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  общий( [ Муж, Жена | Дети], Доход),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  длина( [ Муж, Жена | Дети], N),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Доход/N < 2000.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.1.\b0   Напишите вопросы для поиска в базе данных о семьях.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (а) семей без детей;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) всех работающих детей;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (с) семей, где жена работает, а муж нет,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d) всех детей, разница в возрасте родителей которых составляет не менее 15 лет.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.2.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 близнецы( Ребенок1, Ребенок2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 для поиска всех близнецов в базе данных о семьях.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 4.2. Абстракция данных\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Абстракцию данных\i0   можно рассматривать как процесс организации различных фрагментов информации в единые логические единицы (возможно, иерархически), придавая ей при этом некоторую концептуально осмысленную форму. Каждая информационная единица должна быть легко доступна в программе. В идеальном случае все детали реализации такой структуры должны быть невидимы пользователю этой структуры. Самое главное в этом процессе - дать программисту возможность использовать информацию, не думая о деталях ее действительного представления.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обсудим один из способов реализации этого принципа на Прологе. Рассмотрим снова пример с семьей из предыдущего раздела. Каждая семья — это набор некоторых фрагментов информации. Все эти фрагменты объединены в естественные информационные единицы, такие, как "член семьи" или "семья", и с ними можно обращаться как с едиными объектами. Предположим опять, что информация о семье структурирована так же, как на рис. 4.1. Определим теперь некоторые отношения, с помощью которых пользователь может получать доступ к конкретным компонентам семьи, не зная деталей рис. 4.1. Такие отношения можно назвать \i селекторами\i0  , поскольку они позволяют выбирать конкретные компоненты. Имя такого отношения-селектора будет совпадать с именем компоненты, которую нужно выбрать. Отношение будет иметь два аргумента: первый — объект, который содержит компоненту, и второй — саму компоненту:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отношение_селектор(Объект, Выбранная_компонента)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот несколько селекторов для структуры семья:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 муж( семья( Муж, _, _ ), Муж).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 жена( семья( _, Жена, _ ), Жена).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дети( семья( _, _, СписокДетей ), СписокДетей).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно также создать селекторы для отдельных детей семьи:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 первыйребенок( Семья, Первый) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  дети( Семья, [Первый | _ ]).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 второйребенок( Семья, Второй) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  дети( Семья, [ _, Второй | _ ]).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно обобщить этот селектор для выбора N-го ребенка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i n\i0  ребенок( N, Семья, Ребенок) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  дети( Семья, СписокДетей),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i n\i0  _элемент( N, СписокДетей, Ребенок)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % N-й элемент списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другим интересным объектом является "член семьи". Вот некоторые связанные с ним селекторы, соответствующие рис. 4.1:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имя( членсемьи( Имя, _, _, _ ), Имя).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фамилия( членсемьи( _, Фамилия, _, _ ), Фамилия).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 датарождения( членсемьи( _, _, Дата), Дата).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Какие преимущества мы можем получить от использования отношений-селекторов? Определив их, мы можем теперь забыть о конкретном виде структуры представления информации. Для пополнения и обработки этой информации нужно знать только имена отношений-селекторов и в оставшейся части программы пользоваться только ими. В случае, если информация представлена сложной структурой, это легче, чем каждый раз обращаться к ней в явном виде. В частности, в нашем примере с семьей пользователь не обязан знать, что дети представлены в виде списка. Например, предположим, мы хотим сказать, что Том Фокс и Джим Фокс принадлежат к одной семье и что Джим — второй ребенок Тома. Используя приведенные выше отношения-селекторы, мы можем определить двух человек, назовем их Человек1 и Человек2, и семью. Следующий список целей приводит к желаемому результату:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имя( Человек1, том), фамилия( Человек1, фокс),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Человек1 - Том Фокс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  имя( Человек2, джим), фамилия( Человек1, фокс),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Человек2 - Джим Фокс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  муж( Семья, Человек1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  второйребенок( Семья, Человек2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Использование отношений-селекторов облегчает также и последующую модификацию программ. Представьте себе, что мы захотели повысить эффективность программы, изменив представление информации. Все, что нужно сделать для этого, — изменить определения отношений-селекторов, и вся остальная программа без изменений будет работать с этим новым представлением.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.3.\b0   Завершите определение отношения \i \i n\i0  ребенок\i0  , определив отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i n\i0  _элемент( N, Список, X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которое выполняется, если X является N-м элементом списка Список.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 4.3. Моделирование недетерминированного автомата\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Данное упражнение показывает, как абстрактную математическую конструкцию можно представить на Прологе. Кроме того, программа, которая получится, окажется значительно более гибкой, чем предполагалось вначале.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Недетерминированный конечный автомат\i0   — это абстрактная машина, которая читает символы из входной цепочки и решает, \i допустить\i0   или \i отвергнуть\i0   эту цепочку. Автомат имеет несколько \i состояний\i0   и всегда находится в одном из них. Он может изменить состояние, перейдя из одного состояния в другое. Внутреннюю структуру такого автомата можно представить графом переходов, как показано на рис. 4.3. В этом примере \i S\sub 1\nosupersub \i0  , \i S\sub 2\nosupersub \i0  , \i S\sub 3\nosupersub \i0   и \i S\sub 4\nosupersub \i0   — \i состояния\i0   автомата. Стартовав из начального состояния (в нашем примере это \i S\sub 1\nosupersub \i0  ), автомат переходит из состояния в состояние по мере чтения входной цепочки. Переход зависит от текущего входного символа, как указывают метки на дугах графа переходов.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 4.3.\b0   Пример недетерминированного конечного автомата.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переход выполняется всякий раз при чтении входного символа. Заметим, что переходы могут быть недетерминированными. На рис. 4.3 видно, что если автомат находится в состоянии \i S\sub 1\nosupersub \i0  , и текущий входной символ равен  \i а\i0  ,  то переход может осуществиться как в \i S\sub 1\nosupersub \i0  , так и в \i S\sub 2\nosupersub \i0  . Некоторые дуги помечены меткой пусто, обозначающей "пустой символ". Эти дуги соответствуют "спонтанным переходам" автомата. Такой переход называется \i спонтанным\i0  , потому что он выполняется без чтения входной цепочки. Наблюдатель, рассматривающий автомат как черный ящик, не сможет обнаружить, что произошел какой-либо переход.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Состояние \i S\sub 3\nosupersub \i0   обведено двойной линией, это означает, что \i S\sub 3\nosupersub \i0   — \i конечное состояние\i0  . Про автомат говорят, что он \i допускает\i0   входную цепочку, если в графе переходов существует путь, такой, что:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) он начинается в начальном состоянии,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) он оканчивается в конечном состоянии, и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) метки дуг, образующих этот путь, соответствуют полной входной цепочке.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решать, какой из возможных переходов делать в каждый момент времени — исключительно внутреннее дело автомата. В частности, автомат сам решает, делать ли спонтанный переход, если он возможен в текущем состоянии. Однако абстрактные недетерминированные машины такого типа обладают волшебным свойством: если существует выбор, они всегда избирают "правильный" переход, т.е. переход, ведущий к допущению входной цепочки при наличии такого перехода. Автомат на рис. 4.3, например, допускает цепочки \i аb \i0  и \i aabaab\i0  , но отвергает цепочки \i abb\i0   и \i abba\i0  . Легко видеть, что этот автомат допускает любые цепочки, оканчивающиеся на \i аb\i0   и отвергает все остальные.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 4.4.\b0   Допущение цепочки: (a) при чтении первого символа X; (b) при совершении спонтанного перехода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Некоторый автомат можно описать на Прологе при помощи трех отношений:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Унарного отношения конечное, которое определяет конечное состояние автомата.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Трехаргументного отношения переход, которое определяет переход из состояния в состояние, при этом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 переход( S1, X, S2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает переход из состояния S1 в S2, если считан входной символ X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Бинарного отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 спонтанный( S1, S2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означающего, что возможен спонтанный переход из S1 в S2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для автомата, изображенного на рис. 4.3, эти отношения будут такими:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конечное( S3).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 переход( S1, а, S1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 переход( S1, а, S2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 переход( S1, b, S1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 переход( S2, b, S3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 переход( S3, b, S4).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 спонтанный( S2, S4).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 спонтанный( S3, S1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Представим входные цепочки в виде списков Пролога. Цепочка \i ааb\i0   будет представлена как [а, а, b]. Модель автомата, получив его описание, будет обрабатывать заданную входную цепочку, и решать, допускать ее или нет. По определению, недетерминированный автомат допускает заданную цепочку, если (начав из начального состояния) после ее прочтения он способен оказаться в конечном состоянии. Модель программируется в виде бинарного отношения допускается, которое определяет принятие цепочки из данного состояния. Так\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 допускается( Состояние, Цепочка)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинно, если автомат, начав из состояния Состояние как из начального, допускает цепочку Цепочка. Отношение допускается можно определить при помощи трех предложений. Они соответствуют следующим трем случаям:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Пустая цепочка [] допускается из состояния S, если S — конечное состояние.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Непустая цепочка допускается из состояния S, если после чтения первого ее символа автомат может перейти в состояние S1, и оставшаяся часть цепочки допускается из S1. Этот случай иллюстрируется на рис. 4.4(а).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Цепочка допускается из состояния S, если автомат может сделать спонтанный переход из S в S1, а затем допустить (всю) входную цепочку из S1. Такой случай иллюстрируется на рис. 4.4(b).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти правила можно перевести на Пролог следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 допускается( S, []) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Допуск пустой цепочки\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конечное( S).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 допускается( S, [X | Остальные]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Допуск чтением первого символа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  переход( S, X, S1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  допускается( S1, Остальные).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 допускается( S, Цепочка) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Допуск выполнением спонтанного перехода\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  спонтанный( S, S1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  допускается( S1, Цепочка).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Спросить о том, допускается ли цепочка \i аааb\i0  , можно так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- допускается( S1, [a, a, a, b]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes            (да)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как мы уже видели, программы на Прологе часто оказываются способными решать более общие задачи, чем те, для которых они первоначально предназначались. В нашем случае мы можем спросить модель также о том, в каком состоянии должен находиться автомат в начале работы, чтобы он допустил цепочку \i аb\i0  :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- допускается( S, [a, b]).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = s1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = s3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как ни странно, мы можем спросить также "Каковы все цепочки длины 3, допустимые из состояния s1?"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- допускается( s1, [X1, Х2, X3]).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X1 = а\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X2 = а\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X3 = b;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X1 = b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X2 = а\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X3 = b;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nо     (нет)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы предпочитаем, чтобы допустимые цепочки выдавались в виде списков, тогда наш вопрос следует сформулировать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- Цепочка = [ _, _, _ ], допускается( s1, Цепочка).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цепочка = [а, а, b];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цепочка = [b, а, b];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nо     (нет)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно проделать и еще некоторые эксперименты, например спросить: "Из какого состояния автомат допустит цепочку длиной 7?"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эксперименты могут включать в себя переделки структуры автомата, вносящие изменения в отношения конечное, переход и спонтанный. В автомате, изображенном на рис. 4.3, отсутствуют циклические "спонтанные пути" (пути, состоящие только из спонтанных переходов). Если на рис. 4.3 добавить новый переход\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 спонтанный( s1, s3)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то получится "спонтанный цикл". Теперь наша модель может столкнуться с неприятностями. Например, вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- допускается( s1, [а]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 приведет к тому, что модель будет бесконечно переходить в состояние s1, все время надеясь отыскать какой-либо путь в конечное состояние.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.4.\b0   Почему не могло возникнуть зацикливание модели исходного автомата на рис. 4.3, когда в его графе переходов не было "спонтанного цикла"?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.5.\b0   Зацикливание при вычислении допускается можно предотвратить, например, таким способом: подсчитывать число переходов, сделанных к настоящему моменту. При этом модель должна будет искать пути только некоторой ограниченной длины. Модифицируйте так отношение допускается. Указание: добавьте третий аргумент — максимально допустимое число переходов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 допускается( Состояние, Цепочка, Макс_переходов)\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 4.4. Планирование поездки\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В данном разделе мы создадим программу, которая дает советы по планированию воздушного путешествия. Эта программа будет довольно примитивным советчиком, тем не менее она сможет отвечать на некоторые полезные вопросы, такие как:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • По каким дням недели есть прямые рейсы из Лондона в Любляну?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Как в четверг можно добраться из Любляны в Эдинбург?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Мне нужно посетить Милан, Любляну и Цюрих; вылетать нужно из Лондона во вторник и вернуться обратно в Лондон в пятницу. В какой последовательности мне следует посещать эти города, чтобы ни разу на протяжении поездки не пришлось совершать более одного перелета в день.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Центральной частью программы будет база данных, содержащая информацию о рейсах. Эта информация будет представлена в виде трехаргументного отношения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( Пункт1, Пункт2, Список_рейсов)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Список_рейсов — это список, состоящий из структурированных объектов вида:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Время_отправления / Время_прибытия / Номер_рейса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  / Список_дней_вылета\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список_дней_вылета — это либо список дней недели, либо атом "ежедневно". Одно из предложений, входящих в расписание могло бы быть, например, таким:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( лондон, эдинбург,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ 9:40 / 10:50 / bа4733/ ежедневно,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    19:40 / 20:50 / bа4833 / [пн, вт, ср, чт, пт, сб]] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Время представлено в виде структурированных объектов, состоящих из двух компонент — часов и минут, объединенных оператором ":".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Главная задача состоит в отыскании точных маршрутов между двумя заданными городами в определенные дни недели. Ее решение мы будем программировать в виде четырехаргументного отношения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 маршрут( Пункт1, Пункт2, День, Маршрут)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь Маршрут — это последовательность перелетов, удовлетворяющих следующим критериям:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) начальная точка маршрута находится в Пункт1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) конечная точка — в Пункт2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) все перелеты совершаются в один и тот же день недели — День;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (4) все перелеты, входящие в Маршрут, содержатся в определении отношения расписание;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (5) остается достаточно времени для пересадки с рейса на рейс.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Маршрут представляется в виде списка структурированных объектов вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Откуда - Куда : Номер_рейса : Время_отправления\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы еще будем пользоваться следующими вспомогательными предикатами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) рейс( Пункт1, Пункт2, День, N_рейса, Вр_отпр, Вр_приб)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь сказано, что существует рейс N_рейса между Пункт1 и Пункт2 в день недели День с указанными временами отправления и прибытия.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) вр_отпр( Маршрут, Время)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Время — это время отправления по маршруту Маршрут.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) пересадка( Время1, Время2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Между Время1 и Время2 должен существовать промежуток не менее 40 минут для пересадки с одного рейса на другой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задача нахождения маршрута напоминает моделирование недетерминированного автомата из предыдущего раздела:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Состояния автомата соответствуют городам.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Переход из состояния в состояние соответствует перелету из одного города в другой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Отношение переход автомата соответствует отношению расписание.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Модель автомата находит путь в графе переходов между исходным и конечным состояниями; планировщик поездки находит маршрут между начальным н конечным пунктами поездки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Неудивительно поэтому, что отношение маршрут можно определить аналогично отношению допускает, с той разницей, что теперь нет "спонтанных переходов". Существуют два случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Прямой рейс: если существует прямой рейс между пунктами Пункт1 и Пункт2, то весь маршрут состоит только из одного перелета:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 маршрут( Пункт1, Пункт2, День, [Пункт1-Пункт2 : Nр : Отпр]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рейс( Пункт1, Пункт2, День, Np, Отпр, Приб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Маршрут с пересадками: маршрут между пунктами P1 и Р2 состоит из первого перелета из P1 в некоторый промежуточный пункт Р3 и маршрута между Р3 и Р2. Кроме того, между окончанием первого перелета и отправлением во второй необходимо оставить достаточно времени для пересадки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 маршрут( P1, Р2, День, [P1-Р3 : Nр1 : Отпр1 | Маршрут]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  маршрут( Р3, Р2, День, Маршрут ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рейс( P1, Р3, День, Npl, Oтпpl, Приб1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вр_отпр( Маршрут, Отпр2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  пересадка( Приб1, Отпр2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вспомогательные отношения рейс, пересадка и вр_отпр запрограммировать легко; мы включили их в полный текст программы планировщика поездки на рис. 4.5. Там же приводится и пример базы данных расписания.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наш планировщик исключительно прост и может рассматривать пути, очевидно ведущие в никуда. Тем не менее его оказывается вполне достаточно, если база данных о рейсах самолетов невелика. Для больших баз данных потребовалось бы разработать более интеллектуальный планировщик, который мог бы справиться с большим количеством путей, участвующих в перебора при нахождении нужного пути.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % ПЛАНИРОВЩИК ВОЗДУШНЫХ МАРШРУТОВ\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 50, xfy, :).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рейс( Пункт1, Пункт2, День, Np, ВрОтпр, ВрПриб) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расписание( Пункт1, Пункт2, СписРейсов),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( ВрОтпр / ВрПриб / Nр / СписДней, СписРейсов),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  день_выл( День, СписДней).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [X | L] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [Y | L] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, L ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 день_выл( День, СписДней) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( День, СписДней).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 день_выл( День, ежедневно) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( День, [пн, вт, ср, чт, пт, сб, вс] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 маршрут( P1, P2, День, [P1-Р2 : Np : ВрОтпр] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % прямой рейс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рейс( P1, P2, День, Np, ВрОтпр, _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 маршрут( P1, Р2, День, [Pl-P3 : Np1 : Oтпp1 | Маршрут]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % маршрут с пересадками\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  маршрут( Р3, P2, День, Маршрут ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рейс( P1, Р3, День, Npl, Oтпp1, Приб1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вр_отпр( Маршрут, Отпр2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  пересадка( Приб1, Отпр2).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вр_отпр( [P1-Р2 : Np : Отпр | _ ], Отпр).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пересадка( Часы1 : Минуты1, Часы2 : Минуты2) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  60 * (Часы2-Часы1) + Минуты2 - Минуты1 >= 40\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % БАЗА ДАННЫХ О РЕЙСАХ САМОЛЕТОВ\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( эдинбург, лондон,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ 9:40 / 10:50 / bа4733 / ежедневно,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    13:40 / 14:50 / ba4773 / ежедневно,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    19:40 / 20:50 / bа4833 / [пн, вт, ср, чт, пт, вс] ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( лондон, эдинбург,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ 9:40 / 10:50 / bа4732 / ежедневно,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    11:40 / 12:50 / bа4752 / ежедневно,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    18:40 / 19:50 / bа4822 / [пн, вт, ср, чт, пт] ] ),\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( лондон, любляна,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [13:20 / 16:20 / ju201 / [пт],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   13:20 / 16:20 / ju213 / [вс] ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( лондон, цюрих,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ 9:10 / 11:45 / bа614 / ежедневно,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    14:45 / 17:20 / sr805 / ежедневно ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( лондон, милан,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ 8:30 / 11:20 / bа510 / ежедневно,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    11:00 / 13:50 / az459 / ежедневно ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( любляна, цюрих,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [11:30 / 12:40 / ju322 / [вт,чт] ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( любляна, лондон,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [11:10 / 12:20 / yu200 / [пт],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   11:25 / 12:20 / yu212 / [вс] ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( милан, лондон,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ 9:10 / 10:00 / az458 / ежедневно,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    12:20 / 13:10 / bа511 / ежедневно ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( милан, цюрих,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ 9:25 / 10:15 / sr621 / ежедневно,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    12:45 / 13:35 / sr623 / ежедневно ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( цюрих, любляна,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [13:30 / 14:40 / yu323 / [вт, чт] ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( цюрих, лондон,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  9:00 / 9:40 / bа613 /\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ пн, вт, ср, чт, пт, сб],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    16:10 / 16:55 / sr806 / [пн, вт, ср, чт, пт, сб] ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расписание( цюрих, милан,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ 7:55 / 8:45 / sr620 / ежедневно ] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 4.5.\b0    Планировщик воздушных маршрутов и база данных о рейсах самолетов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот некоторые примеры вопросов к планировщику:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • По каким дням недели существуют прямые рейсы из Лондона в Люблину?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- рейс( лондон, любляна, День, _, _, _ ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 День = пт;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 День = сб;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no        (нет)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Как мне добраться из Любляны в Эдинбург в четверг?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- маршрут( любляна, эдинбург, чт, R).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 R = [любляна-цюрих : уu322 : 11:30, цюрих-лондон:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      sr806 : 16:10,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      лондон-эдинбург : bа4822 : 18:40 ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Как мне посетить Милан, Любляну и Цюрих, вылетев из Лондона во вторник и вернувшись в него в пятницу, совершая в день не более одного перелета? Этот вопрос сложнее, чем предыдущие. Его можно сформулировать, использовав отношение перестановка, запрограммированное в гл. 3. Мы попросим найти такую перестановку городов Милан, Любляна и Цюрих, чтобы соответствующие перелеты можно было осуществить в несколько последовательных дней недели:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- перестановка( [милан, любляна, цюрих],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [Город1, Город2, Город3] ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рейс( лондон, Город1, вт, Np1, Oтпp1, Пpиб1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  peйc( Город1, Город2, ср, Np2, Отпр2, Приб2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рейс( Город2, Город3, чт, Np3, Отпp3, Приб3),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рейс( Город3, лондон, пт, Np4, Отпр4, Приб4).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Город1 = милан\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Город2 = цюрих\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Город3 = любляна\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Np1 = ba510\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отпр1 = 8:30\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приб1 = 11:20\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Np2 =sr621\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отпр2 = 9:25\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приб2 = 10:15\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Np3 = yu323\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отпр3 = 13:30\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приб3 = 14:40\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Np4 = yu200\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отпр4 = 11:10\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приб4 = 12:20\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 4.5. Задача о восьми ферзях\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта задача состоит в отыскании такой расстановки восьми ферзей на пустой шахматной доске, в которой ни один из ферзей не находится под боем другого. Решение мы запрограммируем в виде унарного отношения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решение( Поз)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которое истинно тогда и только тогда, когда Поз изображает позицию, в которой восемь ферзей не бьют друг друга. Будет интересно сравнить различные идеи, лежащие в основе программирования этой задачи. Поэтому мы приведем три программы, основанные на слегка различающихся ее представлениях.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 4.5.1. Программа 1\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вначале нужно выбрать способ представления позиции на доске. Один из наиболее естественных способов — представить позицию в виде списка из восьми элементов, каждый из которых соответствует одному из ферзей. Каждый такой элемент будет описывать то поле доски, на которой стоит соответствующий ферзь. Далее, каждое поле доски можно описать с помощью пары координат (X и Y), где каждая координата - целое число от 1 до 8. В программе мы будем записывать такую пару в виде\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X / Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где оператор "/" обозначает, конечно, не деление, а служит лишь для объединения координат поля в один элемент списка. На рис. 4.6 показано одно из решений задачи о восьми ферзях и его запись в виде списка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После того, как мы выбрали такое представление, задача свелась к нахождению списка вида:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [X1/Y1, X2/Y2, X3/Y3, X4/Y4, X5/Y5, X6/Y6, X7/Y7, X8/Y8]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удовлетворяющего требованию отсутствия нападений. Наша процедура решение должна будет найти подходящую конкретизацию переменных X1, Y1, Х2, Y2, \b …\b0  , Х8, Y8. Поскольку мы знаем, что все ферзи должны находиться на разных вертикалях во избежание нападений по вертикальным линиям, мы можем сразу же ограничить перебор, чтобы облегчать поиск решения. Можно поэтому сразу зафиксировать X-координаты так, чтобы список, изображающий решение, удовлетворял следующему, более конкретному шаблону:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [1/Y1, 2/Y2, 3/Y3, 4/Y4, 5/Y5, 6/Y6, 7/Y7, 8/Y8]\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 4.6.\b0   Решение задачи о восьми ферзях. Эта позиция может быть представлена в виде списка [1/4, 2/2, 3/7, 4/3, 5/6, 6/8, 7/5, 8/1].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нас интересует решение для доске размером 8&#215;8. Однако, как это часто бывает в программировании, ключ к решению легче найти, рассмотрев более общую постановку задачи. Как это ни парадоксально, но часто оказывается, что решение более общей задачи легче сформулировать, чем решение более частной, исходной задачи; после этого исходная задача решается просто как частный случай общей задачи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основная часть работы при таком подходе ложится на нахождение правильного обобщения исходной задачи. В нашем случае хорошей является идея обобщать задачу в отношении количества ферзей (количества вертикалей в списке), разрешив количеству ферзей принимать любое значение, включая нуль. Тогда отношение решение можно сформулировать, рассмотрев два случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Случай 1\i0  . Список ферзей пуст. Пустой список без сомнения является решением, поскольку нападений в этом случае нет.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Случай 2\i0  . Список ферзей не пуст. Тогда он выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ X/Y | Остальные ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В случае 2 первый ферзь находится на поле X / Y, а остальные — на полях, указанных в списке Остальные. Если мы хотим, чтобы это было решением, то должны выполняться следующие условия:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Ферзи, перечисленные в списке Остальные, не должны бить друг друга; т.е. список Остальные сам должен быть решением.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) X и Y должны быть целыми числами от 1 до 8.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Ферзь, стоящий на поле X / Y, не должен бить ни одного ферзя из списка Остальные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы запрограммировать первое условие, можно воспользоваться самим отношением решение. Второе условие можно сформулировать так: Y должен принадлежать списку целых чисел от 1 до 8. т.е. [1, 2, 3, 4, 5, 6, 7, 8]. С другой стороны, о координате X можно не беспокоиться, поскольку список-решение должен соответствовать шаблону, у которого X-координаты уже определены. Поэтому X гарантированно получит правильное значение от 1 до 8. Третье условие можно обеспечить с помощью нового отношения небьет. Все это можно записать на Прологе так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решение( [X/Y | Остальные] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решение( Остальные),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Y, [1, 2, 3, 4, 5, 6, 7, 8] ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  небьет( X/Y, Остальные).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Осталось определить отношение небьет:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 небьет( Ф, Фспис)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И снова его описание можно разбить на два случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Если список Фспис пуст, то отношение, конечно, выполнено, потому что некого бить (нет ферзя, на которого можно было бы напасть).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Если Фспис не пуст, то он имеет форму\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [Ф1 | Фспис1]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и должны выполняться два условия:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (а) ферзь на поле Ф не должен бить ферзя на поле Ф1 и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (b) ферзь на поле Ф не должен бить ни одного ферзя из списка Фспис1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Выразить требование, чтобы ферзь, находящийся на некотором поле, не бил другое поле, довольно просто: эти поля не должны находиться на одной и той же горизонтали, вертикали или диагонали: Наш шаблон решения гарантирует, что все ферзи находятся на разных вертикалях, поэтому остается только обеспечить, чтобы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Y-координаты ферзей были различны и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • ферзи не находились на одной диагонали, т.е. расстояние между полями по направлению X не должно равняться расстоянию между ними по Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 4.7 приведен полный текст программы. Чтобы облегчить ее использование, необходимо добавить список-шаблон. Это можно сделать в запросе на генерацию решений. Итак:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  шаблон( S), решение( S).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решение( [] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решение( [X/Y | Остальные ] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Первый ферзь на поле X/Y,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % остальные ферзи на полях из списка Остальные\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решение( Остальные),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит Y, [1, 2, 3, 4, 5, 6, 7, 8] ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  небьет( X/Y | Остальные).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Первый ферзь не бьет остальных\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 небьет( _, [ ]). % Некого бить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 небьет( X/Y, [X1/Y1 | Остальные] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Y =\\= Y1,       % Разные Y-координаты\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Y1-Y =\\= X1-X   % Разные диагонали\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Y1-Y =\\= X-X1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  небьет( X/Y, Остальные).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [X | L] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [Y | L] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, L).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Шаблон решения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 шаблон( [1/Y1, 2/Y2, 3/Y3, 4/Y4, 5/Y5, 6/Y6, 7/Y7, 8/Y8]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 4.7.\b0    Программа 1 для задачи о восьми ферзях.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Система будет генерировать решения в таком виде:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [1/4, 2/2, 3/7, 4/3, 5/6, 6/8, 7/5, 8/1];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [1/5, 2/2, 3/4, 4/7, 5/3, 6/8, 7/6, 8/1];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [1/3, 2/5, 3/2, 4/8, 5/6, 6/4, 7/7, 8/1].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.6.\b0   При поиске решения программа, приведенная на рис. 4.7, проверяет различные значения Y-координат ферзей. В каком месте программы задается порядок перебора альтернативных вариантов? Как можно без труда модифицировать программу, чтобы этот порядок изменился? Поэкспериментируйте с разными порядками, имея в виду выяснить, как порядок перебора альтернатив влияет на эффективность программы.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 4.5.2. Программа 2\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В соответствии с принятым в программе 1 представлением доски каждое решение имело вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [1/Y1, 2/Y2, 3/Y3, ..., 8/Y8]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 так как ферзи расставлялись попросту в последовательных вертикалях. Никакая информация не была бы потеряна, если бы X-координаты были пропущены. Поэтому можно применить более экономное представление позиции на доске, оставив в нем только Y-координаты ферзей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [Y1, Y2, Y3, ..., Y8]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы не было нападений по горизонтали, никакие два ферзя не должны занимать одну и ту же горизонталь. Это требование накладывает ограничение на Y-координаты: ферзи должны занимать все горизонтали с 1-й по 8-ю. Остается только выбрать \i порядок\i0   следования этих восьми номеров. Каждое решение представляет собой поэтому одну из перестановок списка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [1, 2, 3, 4, 5, 6, 7, 8]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такая перестановка S является решением, если каждый ферзь в ней не находится под боем (список S — "безопасный"). Поэтому мы можем написать:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решение( S) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перестановка( [1, 2, 3, 4, 5, 6, 7, 8], S),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  безопасный( S).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 4.8.\b0   (а) Расстояние по X между Ферзь и Остальные равно 1. (b) Расстояние по X между Ферзь и Остальные равно 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношение перестановка мы уже определила в гл. 3, а вот отношение безопасный нужно еще определить. Это определение можно разбить на два случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) S — пустой список. Тогда он, конечно, безопасный, ведь нападать не на кого.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) S — непустой список вида [Ферзь | Остальные]. Он безопасный, если список Остальные — безопасный и Ферзь не бьет ни одного ферзя из списка Остальные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На Прологе это выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 безопасный( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 безопасный( [Ферзь | Остальные ] :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  безопасный( Остальные),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  небьет(Ферзь | Остальные).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой программе отношение небьет более хитрое.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решение( Ферзи) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перестановка( [1, 2, 3, 4, 5, 6, 7, 8], Ферзи),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  безопасный( Ферзи).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перестановка( [], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перестановка( [Голова | Хвост], СписПер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перестановка( Хвост, ХвостПер),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( Голова, СписПер, ХвостПер).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Вставка головы в переставленный хвост\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( А, [А | Список).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалять( А, [В | Список], [В, Список1] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( А, Список, Список1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 безопасный( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 безопасный( [Ферзь | Остальные]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  безопасный( Остальные),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  небьет( Ферзь, Остальные, 1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 небьет( _, [], _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 небьет( Y, [Y1 | СписY], РасстХ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Y1-Y =\\= РасстХ,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Y-Y1 =\\= РасстХ,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Расст1 is РасстХ + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  небьет( Y, СписY, Расст1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 4.9.\b0   Программа 2 для задачи о восьми ферзях.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Трудность состоит в том, что расположение ферзей определяется только их Y-координатами, а X-координаты в представлении позиции не присутствуют в явном виде. Этой трудности можно избежать путем небольшого обобщения отношения небьет, как это показано на рис. 4.8. Предполагается, что цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 небьет( Ферзь, Остальные)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обеспечивает отсутствие нападении ферзя Ферзь на поля списка Остальные в случае, когда расстояние по X между Ферзь и Остальные равно 1. Остается рассмотреть более общий случай произвольного расстояния. Для этого мы добавим его в отношение небьет в качестве третьего аргумента:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 небьет( Ферзь, Остальные, РасстХ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Соответственно и цель небьет в отношении безопасный должна быть изменена на\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 небьет( Ферзь, Остальные, 1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь отношение небьет может быть сформулировано в соответствии с двумя случаями, в зависимости от списка Остальные: если он пуст, то бить некого и, естественно, нет нападений; если же он не пуст, то Ферзь не должен бить первого ферзя из списка Остальные (который находится от ферзя Ферзь на расстоянии РасстХ вертикалей), а также ферзей из хвоста списка Остальные, находящихся от него на расстоянии РасстХ + 1. Эти соображения приводят к программе, изображенной на рис. 4.9.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 4.5.3. Программа 3\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша третья программа для задачи о восьми ферзях опирается на следующие соображения. Каждый ферзь должен быть размещен на некотором поле, т.е. на некоторой вертикали, некоторой горизонтали, а также на пересечении каких-нибудь двух диагоналей. Для того, чтобы была обеспечена безопасность каждого ферзя, все они должны располагаться в разных вертикалях, разных горизонталях и в разных диагоналях (как идущих сверху вниз, так и идущих снизу вверх). Естественно поэтому рассмотреть более богатую систему представления с четырьмя координатами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i x\i0   вертикали\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i у\i0   горизонтали\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i u\i0   диагонали, идущие снизу вверх\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i v\i0   диагонали, идущие сверху вниз\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти координаты не являются независимыми: при заданных \i x\i0   и \i у\i0  , \i u\i0   и \i v\i0   определяются однозначно (пример на рис. 4.10). Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i u = x - у\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i v = x + у\i0  \par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 4.10.\b0   Связь между вертикалями, горизонталями и диагоналями. Помеченное поле имеет следующие координаты: \i x\i0   = 2,  \i у\i0   = 4, \i u\i0   = 2 - 4 = -2, \i v\i0   = 2 + 4 = 6.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Области изменения всех четырех координат таковы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Dx = [1, 2, 3, 4, 5, 6, 7, 8]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Dy = [1, 2, 3, 4, 5, 6, 7, 8]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Du = [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Dv = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задачу о восьми ферзях теперь можно сформулировать следующим образом: выбрать восемь четверок (X, Y, U, V), входящих в области изменения (X в Dx, Y в Dy и т.д.), так, чтобы ни один их элемент не выбирался дважды из одной области. Разумеется, выбор X и Y определяет выбор U и V. Решение при такой постановке задачи может быть вкратце таким: при заданных 4-x областях изменения выбрать позицию для первого ферзя, вычеркнуть соответствующие элементы из 4-x областей изменения, а затем использовать оставшиеся элементы этих областей для размещения остальных ферзей. Программа, основанная на таком подходе, показана на рис. 4.11. Позиция на доске снова представляется списком Y-координат. Ключевым отношением в этой программе является отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 peш( СписY, Dx, Dy, Du, Dv)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которое конкретизирует Y-координаты (в СписY) ферзей, считая, что они размещены в последовательных вертикалях, взятых из Dx. Все Y-координаты и соответствующие координаты U и V берутся из списков Dy, Du и Dv. Главную процедуру решение можно запустить вопросом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  решение( S)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это вызовет запуск реш с полными областями изменения координат, что соответствует пространству задачи о восьми ферзях.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решение( СписY) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  реш( СписY, % Y-координаты ферзей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [1, 2, 3, 4, 5, 6, 7, 8],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Область изменения Y-координат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [1, 2, 3, 4, 5, 6, 7, 8],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Область изменения X-координат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Диагонали, идущие снизу вверх\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 14, 15, 16] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Диагонали, идущие сверху вниз\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 реш([], [], Dy, Du, Dv).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 реш( [Y | СписY], [X | Dx1], Dy, Du, Dv) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( Y, Dy, Dy1), % Выбор Y-координаты\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  U is X-Y,             % Соответствующая диагональ вверх\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( U, Du, Du1), % Ее удаление\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  V is X+Y,             % Соответствующая диагональ вниз\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( V, Dv, Dv1), % Ее удаление\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  реш( СписY, Dх1, Dy1, Du1, Dv1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Выбор из оставшихся значений\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( А, [А | Список], Список).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить(A, [В | Список ], [В | Список1 ] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( А, Список, Список1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 4.11.\b0   Программа 3 для задачи о восьми ферзях.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура реш универсальна в том смысле, что ее можно использовать для решения задачи об N ферзях (на доске размером N&#215;N). Нужно только правильно задеть области Dx, Dy и т.д.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Удобно автоматизировать получение этих областей. Для этого нам потребуется процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 генератор( N1, N2, Список)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которая для двух заданных целых чисел N1 и N2 порождает список\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список = [N1, N1 + 1, N1 + 2, ..., N2 - 1, N2]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот она:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 генератор( N, N, [N]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 генератор( Nl, N2, [Nl | Список]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N1 < N2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  М is N1 + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  генератор( М, N2, Список).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Главную процедуру решение нужно соответствующим образом обобщить:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решение( N, S)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где N — это размер доски, а S — решение, представляемое в виде списка Y-координат N ферзей. Вот обобщенное отношение решение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решение( N, S) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  генератор( 1, N, Dxy),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Nu1 is 1 - N, Nu2 is N - 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  генератор( Nu1, Nu2, Du),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Nv2 is N + N,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  генератор( 2, Nv2, Dv),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  реш( S, Dxy, Dxy, Du, Dv).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, решение задачи о 12 ферзях будет получено с помощью:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  решение( 12, S).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = [1, 3, 5, 8, 10, 12, 6, 11, 2, 7, 9, 4]\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 4.5.4. Заключительные замечания\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Три решения задачи о восьми ферзях показывают, как к одной и той же задаче можно применять различные подходы. Мы варьировали также и представление данных. В одних случаях это представление было более экономным, в других — более наглядным и, до некоторой степени, избыточным. К недостаткам более экономного представления можно отнести то, что какая-то информация всякий раз, когда она требовалась, должна была перевычисляться.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В некоторых случаях основным шагом к решению было обобщение задачи. Как ни парадоксально, но при рассмотрении более общей задачи решение оказывалось проще сформулировать. Принцип такого обобщения — стандартный прием программирования, и его можно часто применять.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Из всех трех программ третья лучше всего показывает, как подходить к общей задаче построения структуры из заданного множества элементов при наличии ограничений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возникает естественный вопрос: " Какая из трех программ наиболее эффективна?" В этом отношение программа 2 значительно хуже двух других, а эти последние — одинаковы. Причина в том, что основанная на перестановках программа 2 строит все перестановки, тогда как две другие программы способны отбросить плохую перестановку не дожидаясь, пока она будет полностью построена. Программа 3 наиболее эффективна. Она избегает некоторых арифметических вычислений, результаты которых уже сразу заложены в избыточное представление доски, используемое этой программой.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.7.\b0   Пусть поля доски представлены парами своих координат в виде X/Y, где как X, так и Y принимают значения от 1 до 8.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (а) Определите отношение ходконя( Поле1, Поле2), соответствующее ходу коня на шахматной доске. Считайте, что Поле1 имеет всегда конкретизированные координаты, в то время, как координаты поля Поле2 могут и не быть конкретизированы. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- ходконя( 1/1, S).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = 3/2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = 2/3;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no      (нет)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) Определите отношение путьконя( Путь), где Путь — список полей, представляющих соответствующую правилам игры последовательность ходов коня по пустой доске.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (с) Используя отношение путьконя, напишите вопрос для нахождения любого пути, состоящего из 4-x ходов, и начинающегося с поля 2/1, а заканчивающегося на противоположном крае доски (Y = 8). Этот путь должен еще проходить после второго хода через поле 5/4.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Примеры, рассмотренные в данном разделе, иллюстрируют некоторые достоинства и характерные черты программирования на Прологе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Базу данных можно естественным образом представить в виде множества прологовских фактов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Такие механизмы Пролога, как вопросы и сопоставление, можно гибко использовать для получения информации из базы данных. Кроме этого можно использовать вспомогательные процедуры-утилиты, еще больше облегчающие взаимодействие с конкретной базой данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Абстракцию данных\i0   можно рассматривать как метод программирования, который облегчает работу со сложными структурами данных и вносит большую ясность и наглядность в программы. В Прологе легко соблюдать основные принципы абстракции данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Часто легко можно осуществить перевод абстрактных математических конструкций, таких как автоматы, на язык определений Пролога, готовых к выполнению.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Как это было в случае восьми ферзей, многие задачи допускают различные подходы, связанные с разными представлениями этих задач. Часто внесение избыточности в представление экономит вычисления. Происходит как бы проигрыш в рабочем пространстве, но выигрыш во времени.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Часто основным шагом на пути к решению оказывается обобщение задачи. Парадоксально, но рассмотрение более общей задачи позволяет облегчить формулировку решения.\par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 5\par
Управление перебором\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы уже видели, что программист может управлять процессом вычислений по программе, располагая ее предложения и цели в том или ином порядке. В данной главе мы рассмотрим еще одно средство управления, получившее название "отсечение" (cut) и предназначенное для ограничения автоматического перебора.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 5.1. Ограничение перебора\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В процессе достижения цели пролог-система осуществляет автоматический перебор вариантов, делая возврат при неуспехе какого-либо из них. Такой перебор — полезный программный механизм, поскольку он освобождает пользователя от необходимости программировать его самому. С другой стороны, ничем не ограниченный перебор может стать источником неэффективности программы. Поэтому иногда требуется его ограничить или исключить вовсе. Для этого в Прологе предусмотрена конструкция "отсечение".\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 5.1.\b0   Двухступенчатая функция\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте сначала рассмотрим простую программу, процесс вычислений, по которой содержит ненужный перебор. Мы выделим те точки этого процесса, где перебор бесполезен и ведет к неэффективности.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим двухступенчатую функцию, изображенную на рис. 5.1. Связь между X и Y можно определить с помощью следующих трех правил:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Правило 1\i0  : если X < 3, то Y = 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Правило 2\i0  : если 3 &#8804; X и X < 6, то Y = 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Правило 3\i0  : если 6 &#8804; X, то Y = 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На Прологе это можно выразите с помощью бинарного отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 0) :- X < 3.          % Правило 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 2) :- 3 =< X,  X < 6. % Правило 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 4) :- 6 =< X.         % Правило 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой программе предполагается, конечно, что к моменту начала вычисления f( X, Y) X уже конкретизирован каким-либо числом; это необходимо для выполнения операторов сравнения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы проделаем с этой программой два эксперимента. Каждый из них обнаружит в ней свой источник неэффективности, и мы устраним оба этих источника по очереди, применив оператор отсечения. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 5.1.1. Эксперимент 1\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проанализируем, что произойдет, если задать следующий вопрос:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- f( 1, Y), 2 < Y.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 5.2.\b0   В точке, помеченной словом "ОТСЕЧЕНИЕ", уже известно, что правила 2 и 3 должны потерпеть неудачу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При вычислении первой цели f( 1, Y) Y конкретизируется нулем. Поэтому вторая цель становится такой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2 < 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Она терпит неудачу, а поэтому и весь список целей также терпит неудачу. Это очевидно, однако перед тем как признать, что такому списку целей удовлетворить нельзя, пролог-система при помощи возвратов попытается проверить еще две бесполезные в данном случае альтернативы. Пошаговое описание процесса вычислений приводится на рис. 5.2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Три правила, входящие в отношение f, являются взаимоисключающими, поэтому успех возможен самое большее в одном из них. Следовательно, мы (но не пролог-система) знаем, что, как только успех наступил в одном из них, нет смысла проверять остальные, поскольку они все равно обречены на неудачу. В примере, приведенном на рис. 5.2, о том, что в правиле 1 наступил успех, становится известно в точке, обозначенной словом "ОТСЕЧЕНИЕ". Для предотвращения бессмысленного перебора мы должны явно указать пролог-системе, что \i не нужно\i0   осуществлять возврат из этой точки. Мы можем сделать это при помощи конструкции отсечения. "Отсечение" записывается в виде символа \b '\b0  !\b '\b0  , который вставляется между целями и играет роль некоторой псевдоцели. Вот наша программа, переписанная с использованием отсечения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 0) :- X < 3,  !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 2) :- 3 =< X,  X < 6,  !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 4) :- 6 =< X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Символ  '!'  предотвращает возврат из тех точек программы, в которых он поставлен. Если мы теперь спросим\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- f( 1, Y), 2 < Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то пролог-система породит левую ветвь дерева, изображенного на рис. 5.2. Эта ветвь потерпит неудачу на цели 2 < 0.   Система попытается сделать возврат, но вернуться она сможет не далее точки, помеченной в программе символом '!'.  Альтернативные ветви, соответствующие правилу 2 и правилу 3, порождены не будут.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Новая программа, снабженная отсечениями, во всех случаях более эффективна, чем первая версия, в которой они отсутствуют. Неудачные варианты новая программа распознает всегда быстрее, чем старая.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вывод: добавив отсечения, мы повысили эффективность. Если их теперь убрать, программа породит тот же результат, только на его получение она истратит скорее всего больше времени. Можно сказать, что в нашем случае после введения отсечений мы изменили только процедурный смысл программы, оставив при этом ее декларативный смысл в неприкосновенности. В дальнейшем мы покажем, что использование отсечения может также затронуть и декларативный смысл программы.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 5.1.2. Эксперимент 2\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проделаем теперь еще один эксперимент со второй версией нашей программы. Предположим, мы задаем вопрос:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- f( 7, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y = 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проанализируем, что произошло. Перед тем, как был получен ответ, система пробовала применить все три правила. Эти попытки породили следующую последовательность целей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Попытка применить правило 1:\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  7 < 3 терпит неудачу, происходит возврат, и попытка применить правило 2 (точка отсечения достигнута не была)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Попытка применить правило 2:\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  3 &#8804; 7  успех, но 7 < 6 терпит неудачу; возврат и попытка применить правило 3 (точка отсечения снова не достигнута)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Попытка применить правило 3:\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  6 &#8804; 7 — успех\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведенные этапы вычисления обнаруживают еще один источник неэффективности. В начале выясняется, что X < 3 не является истиной (7 < 3 терпит неудачу). Следующая цель — 3 =< X (3 &#8804; 7 — успех). Но нам известно, что, если первая проверка неуспешна, то вторая обязательно будет успешной, так как второе целевое утверждение является отрицанием первого. Следовательно, вторая проверка лишняя и соответствующую цель можно опустить. То же самое верно и для цели 6 =< X в правиле 3. Все эти соображения приводят к следующей, более экономной формулировке наших трех правил:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если X < 3, то Y = 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  иначе, если 3 &#8804; X  и X < 6, то Y = 2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  иначе Y = 4.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы можем опустить в нашей программе те условия, которые обязательно выполняются при любом вычислении. Получается третья версия программы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 0) :- X < 3, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 2) :- X < 6, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 4).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта программа дает тот же результат, что и исходная, но более эффективна, чем обе предыдущие. Однако, что будет, если мы \i теперь\i0   удалим отсечения? Программа станет такой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 0) :- X < 3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 2) :- X < 6.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( X, 4).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Она может порождать различные решения, часть из которых неверны. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- f( 1, Y).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y = 0;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y = 2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y = 4;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nо    (нет)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Важно заметить, что в последней версии, в отличие от предыдущей, отсечения затрагивают не только процедурное поведение, но изменяют также и декларативный смысл программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Более точный смысл механизма отсечений можно сформулировать следующим образом:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Назовем "целью-родителем" ту цель, которая сопоставилась с головой предложения, содержащего отсечение. Когда в качестве цели встречается отсечение, такая цель сразу же считается успешной и при этом заставляет систему принять те альтернативы, которые были выбраны с момента активизации цели-родителя до момента, когда встретилось отсечение. Все оставшиеся в этом промежутке (от цели-родителя до отсечения) альтернативы не рассматриваются.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы прояснить смысл этого определения, рассмотрим предложение вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 H :- В1, В2, ..., Вm, !, ..., Вn.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Будем считать, что это предложение активизировалось, когда некоторая цель G сопоставилась с H. Тогда G является целью-родителем. В момент, когда встретилось отсечение, успех уже наступил в целях В1, …, Вm. При выполнении отсечения это (текущее) решение В1, …, Вm "замораживается" и все возможные оставшиеся альтернативы больше не рассматриваются. Далее, цель G связывается теперь с этим предложением: любая попытка сопоставить  G  с головой какого-либо другого предложения пресекается.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Применим эти правила к следующему примеру:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С :- P, Q, R, !, S, T, U.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С :- V.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А :- В, С, D.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- А.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь А, В, С, D, P и т.д. имеют синтаксис термов. Отсечение повлияет на вычисление цели С следующим образом. Перебор будет возможен в списке целей P, Q, R; однако, как только точка отсечения будет достигнута, все альтернативные решения для этого списка изымаются из рассмотрения. Альтернативное предложение, входящее в С:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С :- V.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 также не будет учитываться. Тем не менее, перебор будет возможен в списке целей S, T, U. "Цель-родитель" предложения, содержащего отсечения, — это цель С в предложении\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А :- В, С, D.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поэтому отсечение повлияет только на цель С. С другой стороны, оно будет "невидимо" из цели А. Таким образом, автоматический перебор все равно будет происходить в списке целей В, С, D, вне зависимости от наличия отсечения в предложении, которое используется для достижения С.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 5.2. Примеры, использующие отсечение \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 5.2.1.  Вычисление максимума\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедуру нахождения наибольшего из двух чисел можно запрограммировать в виде отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mах( X, Y, Мах)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Мах = X, если X больше или равен Y, и Мах есть Y, если X меньше Y. Это соответствует двум таким предложениям:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mах( X, Y, X) :- X >= Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 max( X, Y, Y) :- X < Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти правила являются взаимно исключающими. Если выполняется первое, второе обязательно потерпит неудачу. Если неудачу терпит первое, второе обязательно должно выполниться. Поэтому возможна более экономная формулировка, использующая понятие "иначе":\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если X &#8805; Y, то Мах = X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  иначе Мах = Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На Прологе это записывается при помощи отсечения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mах( X, Y, X) :- X >= Y,  !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 mах( X, Y, Y).\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 5.2.2. Процедура проверки принадлежности списку, дающая единственное решение \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы узнать, принадлежит ли X списку L, мы пользовались отношением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа была следующей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [X | L] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит X, [Y | L] ) :- принадлежит( X, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта программа дает "недетерминированный" ответ: если X встречается в списке несколько раз, то будет найдено каждое его вхождение. Исправить этот недостаток не трудно: нужно только предотвратить дальнейший перебор сразу же после того, как будет найден первый X, а это произойдет, как только в первом предложении наступит успех. Измененная программа выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [X | L] ) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [Y | L] ) :- принадлежит( X, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта программа породит только одно решение. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- принадлежит( X, [а, b, с] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = а;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nо    (нет)\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 5.2.3. Добавление элемента к списку, если он в нем отсутствует (добавление без дублирования)\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Часто требуется добавлять элемент X в список L только в том случае, когда в списке еще нет такого элемента. Если же X уже есть в L, тогда L необходимо оставить без изменения, поскольку нам не нужны лишние дубликаты X. Отношение добавить имеет три аргумента:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( X, L, L1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где X — элемент, который нужно добавить, L — список, в который его нужно добавить, L1 — результирующий новый список. Правила добавления можно сформулировать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если X принадлежит к L, то L1 = L,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  иначе L1 — это список L с добавленным к нему элементом X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проще всего добавлять X в начало списка L так, чтобы X стал головой списка L1. Запрограммировать это можно так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( X, L, L) :- принадлежит( X, L), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( X, L, [X | L] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поведение этой процедуры можно проиллюстрировать следующим примером:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- добавить( а, [b,с], L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [a, b, c]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- до6авить( X, [b, с], L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [b, с]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = b\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- добавить( а, [b, с, X], L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [b, с, а]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = а\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот пример поучителен, поскольку мы не можем легко запрограммировать "недублирующее добавление", не используя отсечения или какой-либо другой конструкции, полученной из него. Если мы уберем отсечение в только что рассмотренной программе, то отношение добавить будет добавлять дубликаты элементов, уже имеющихся в списке. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- добавить( a, [a, b, c], L),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [а, b, с]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [а, а, b, с]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поэтому отсечение требуется здесь для правильного определения отношения, а не только для повышения эффективности. Этот момент иллюстрируется также и следующим примером.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 5.2.4. Задача классификации объектов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предположим, что у нас есть база данных, содержащая результаты теннисных партий, сыгранных членами некоторого клуба. Подбор пар противников для каждой партия не подчинялся какой-либо системе, просто каждый игрок встречался с несколькими противниками. Результаты представлены в программе в виде фактов, таких как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 победил( том, джон).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 победил( энн, том).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 победил( пат, джим).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы хотим определить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отношение класс( Игрок, Категория)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которое распределяет игроков по категориям. У нас будет три категории:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  победитель — любой игрок, победивший во всех сыгранных им играх\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  боец — любой игрок, в некоторых играх победивший, а в некоторых проигравший\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  спортсмен — любой игрок, проигравший во всех сыгранных им партиях\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, если в нашем распоряжении есть лишь приведенные выше результаты, то ясно, что Энн и Пат — победители. Том — боец и Джим — спортсмен.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Легко сформулировать правило для бойца:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X — боец, если существует некоторый Y, такой, что X победил Y, и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   существует некоторый Z, такой, что Z победил X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь правило для победителя:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X — победитель, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   X победил некоторого Y и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   X не был побежден никем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта формулировка содержит отрицание "не", которое нельзя впрямую выразить при помощи тех возможностей Пролога, которыми мы располагаем к настоящему моменту. Поэтому оказывается, что формулировка отношения победитель должна быть более хитрой. Та же проблема возникает и при формулировке правил для отношения спортсмен. Эту проблему можно обойти, объединив определения отношений победитель и боец и использовав связку "иначе". Вот такая формулировка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Если X победил кого-либо и X был кем-то побежден,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  то X — боец,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  иначе, если X победил кого-либо,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   то X — победитель, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   иначе, если X был кем-то побежден,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    то X — спортсмен.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такую формулировку можно сразу перевести на Пролог. Взаимные исключения трех альтернативных категорий выражаются при помощи отсечений:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( X, боец) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  победил( X, _ ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  победил( _, X),  !.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( X, победитель) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  победил( X, _ ),  !.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( X, спортсмен) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  победил( _, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что использование отсечения в предложении для категории победитель не обязательно, что связано с особенностями наших трех классов.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.1.\b0   Пусть есть программа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 p( 1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 p( 2) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 p( 3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Напишите все ответы пролог-системы на следующие вопросы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) ?- p( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) ?- p( X), p(Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) ?- p( X), !, p(Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.2.\b0   Следующие отношения распределяют числа на три класса - положительные, нуль и отрицательные:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( Число, положительные) :- Число > 0.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( 0, нуль).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( Число, отрицательные) :- Число < 0.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сделайте эту процедуру более эффективной при помощи отсечений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.3.\b0   Определите процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбить( Числа, Положительные, Отрицательные)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которая разбивает список чисел на два списка: список, содержащий положительные числа (и нуль), и список отрицательных чисел. Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбить( [3, -1, 0, 5, -2], [3, 0, 5], [-1, -2] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предложите две версии: одну с отсечением, другую — без.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 5.3. Отрицание как неуспех\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 "Мэри любит всех животных, кроме змей". Как выразить это на Прологе? Одну часть этого утверждения выразить легко: "Мэри любит всякого X, если X — животное". На Прологе это записывается так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 любит( мэри, X) :- животное ( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но нужно исключить змей. Это можно сделать, использовав другую формулировку:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Если X — змея, то "Мэри любит X" — не есть истина,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  иначе, если X — животное, то Мэри любит X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сказать на Прологе, что что-то не есть истина, можно при помощи специальной цели fail (неуспех), которая всегда терпит неудачу, заставляя потерпеть неудачу и ту цель, которая является ее родителем. Вышеуказанная формулировка, переведенная на Пролог с использованием fail, выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 любит( мэри, X) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  змея( X),  !,  fail.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 любит( Мэри, X) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  животное ( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь первое правило позаботится о змеях: если X — змея, то отсечение предотвратит перебор (исключая таким образом второе правило из рассмотрения), а fail вызовет неуспех. Эти два предложения можно более компактно записать в виде одного:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 любит( мэри, X):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  змея( X), !, fail;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  животное ( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ту же идею можно использовать для определения отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 различны( X, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которое выполняется, если X и Y не совпадают. При этом, однако, мы должны быть точными, потому что "различны" можно понимать по-разному:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • X и Y не совпадают буквально;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • X и Y не сопоставимы;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • значения арифметических выражений X и Y не равны.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте считать в данном случае, что X и Y различны, если они не сопоставимы. Вот способ выразить это на Прологе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Если X и Y сопоставимы, то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   цель различны( X, Y) терпит неуспех\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   иначе цель различны( X, Y) успешна.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы снова используем сочетание отсечения и fail:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 различны( X, X) :- !, fail.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 различны( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 То же самое можно записать и в виде одного предложения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 различны( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X = Y, !, fail;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  true.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь true — цель, которая всегда успешна.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти примеры показывают, что полезно иметь унарный предикат "not" (не), такой, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nоt( Цель)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинна, если Цель не истинна. Определим теперь отношение not следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Если Цель успешна, то not( Цель) неуспешна,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  иначе not( Цель) успешна.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это определение может быть записано на Прологе так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 not( P) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  P, !, fail;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  true.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Начиная с этого момента мы будем предполагать, что  not — это встроенная прологовская процедура, которая ведет себя так, как это только что было определено. Будем также предполагать, что оператор not определен как префиксный, так что цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 not( змея( X) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно записывать и как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 not змея( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Многие версии Пролога поддерживают такую запись. Если же приходится иметь дело с версией, в которой нет встроенного оператора not, его всегда можно определить самим.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следует заметить, что not, как он здесь определен с использованием неуспеха, не полностью соответствует отрицанию в математической логике. Эта разница может породить неожиданности в поведении программы, если оператором not пользоваться небрежно. Этот вопрос будет рассмотрен в данной главе позже.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тем не менее not — полезное средство, и его часто можно с выгодой применять вместо отсечения. Наши два примера можно переписать с not:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 любит( мэри, X) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  животное ( X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not змея( X).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 различны( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not( X = Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это, конечно, выглядит лучше, нежели наши прежние формулировки. Вид предложений стал более естественным, и программу стало легче читать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нашу программу теннисной классификации из предыдущего раздела можно переписать с использованием not так, чтобы ее вид был ближе к исходным определениям наших трех категорий:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( X, боец) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  победил( X, _ ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  победил( _, X).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( X, победитель) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  победил( X, _ ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not победил( _, X).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( X, спортсмен) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not победил( X, _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве еще одного примера использования not рассмотрим еще раз программу 1 для решения задачи о восьми ферзях из предыдущей главы (рис. 4.7). Мы определили там отношение небьет между некоторым ферзем и остальными ферзями. Это отношение можно определить также и как отрицание отношения "бьет". На рис. 5.3 приводится соответствующим образом измененная программа.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решение( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решение( [X/Y | Остальные] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решение( Остальные),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Y, [1, 2, 3, 4, 5, 6, 7, 8] ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not бьет( X/Y, Остальные).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 бьет( X/Y, Остальные) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X1/Y1, Остальные),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Y1 = Y;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Y1 is Y + X1 - X;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Y1 is Y - X1 + X ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( А, [А | L] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( А, [В | L] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( А, L).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Шаблон решения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 шаблон( [1/Y1, 2/Y2, 3/Y3, 4/Y4, 5/Y5, 6/Y6, 7/Y7, 8/Y8]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 5.3.\b0    Еще одна программа для решения задачи о восьми ферзях.\par
\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.4.\b0   Даны два списка Кандидаты и Исключенные, напишите последовательность целей (используя принадлежит и not), которая, при помощи перебора, найдет все элементы списка Кандидаты, не входящие в список Исключенные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.5.\b0   Определите отношение, выполняющее вычитание множеств:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разность( Множ1, Множ2, Разность)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где все три множества представлены в виде списков. Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разность( [a, b, c, d], [b, d, e, f], [a, c] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Посмотреть ответ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.6.\b0   Определите предикат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 унифицируемые( Спис1, Терм, Спис2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Спис2 — список всех элементов Спис1, которые сопоставимы с Терм'ом, но не конкретизируются таким сопоставлением. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  унифицируемые( [X, b, t( Y)], t( a), Спис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Спис = [ X, t( Y)]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что и X и Y должны остаться неконкретизированными, хотя сопоставление с t( a) вызывает их конкретизацию. Указание: используйте not ( Терм1 = Терм2). Если цель Терм1 = Терм2 будет успешна, то not( Терм1 = Tepм2) потерпит неудачу и получившаяся конкретизация будет отменена!\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 5.4. Трудности с отсечением и отрицанием\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Используя отсечение, мы кое-что выиграли, но не совсем даром. Преимущества и недостатки применения отсечения были показаны на примерах из предыдущих разделов. Давайте подытожим сначала преимущества:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) При помощи отсечения часто можно повысить эффективность программы. Идея состоит в том, чтобы прямо сказать пролог-системе: не пробуй остальные альтернативы, так как они все равно обречены на неудачу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Применяя отсечение, можно описать взаимоисключающие правила, поэтому есть возможность запрограммировать утверждение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i если\i0   условие P, \i то\i0   решение Q,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i иначе\i0   решение R\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Выразительность языка при этом повышается.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ограничения на использование отсечения проистекают из того, что есть опасность потерять такое важное для нас соответствие между декларативным и процедурным смыслами программы. Если в программе нет отсечений, то мы можем менять местами порядок предложений и целей, что повлияет только на ее эффективность, но не на декларативный смысл. Если же отсечения в ней присутствуют, то изменение порядка предложений может повлиять на ее декларативный смысл. Это значит, что программа с измененным порядком, возможно, будет давать результаты, отличные от результатов исходной программы. Вот пример, демонстрирующий этот факт:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 p :- а, b.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 p :- с.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Декларативный смысл программы: p истинно тогда и только тогда, когда истинны одновременно и а, и b или истинно с. Это можно записать в виде такой логической формулы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  p <===> (а & b) U с\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно поменять порядок этих двух предложений, но декларативный смысл останется прежним. Введем теперь отсечение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 p :- а, !, b.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 p :- с.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Декларативный смысл станет теперь таким:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  p <===> (а & b) U ( ~а & с)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если предложения поменять местами\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 p :- с.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 p :- а, !, b.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 декларативный смысл станет таким:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  p <===> с U ( а & b)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Важным моментом здесь является то, что при использовании отсечения требуется уделять больше внимания процедурным аспектам. К несчастью, эта дополнительная трудность повышает вероятность ошибок программирования.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В наших примерах из предыдущего раздела мы видели, что удаление отсечений из программы может привести к изменению ее декларативного смысла. Но были также в такие случаи, когда отсечение на него не влияло. Использование отсечений последнего типа требует меньшей осторожности, и поэтому такие отсечения иногда называют "зелеными отсечениями". С точки зрения наглядности программы такие отсечения "невинны" и их использование вполне приемлемо. При чтении программы их можно просто игнорировать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Напротив, отсечения, влияющие на декларативный смысл, называются "красными". Красные отсечения — это такие отсечения, которые делают программу трудной для понимания, и их нужно применять с особой осторожностью.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отсечение часто используется в комбинации со специальной целью fail. В частности, мы определили отрицание какой-либо цели (not), как ее неуспех. Определенное таким образом отрицание представляет собой просто особый (более ограниченный) вид отсечения. Из соображений ясности программ мы предпочтем пользоваться not вместо комбинации \i отсечение — неуспех\i0   (всюду, где возможно), поскольку отрицание является понятием более высокого уровня, чем \i отсечение — неуспех\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следует заметить, что использование оператора not также может приводить к неприятностям, и его тоже следует применять с осторожностью. Трудность заключается в том, что тот оператор not, который был нами определен, не в точности соответствует отрицанию в математике. Если спросить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- not человек( мэри).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 система, возможно, ответит "да". Не следует понимать этот ответ как "мэри не человек". Что в действительности пролог-система хочет сказать своим "да", так это то, что программе не хватает информации для доказательства утверждения "Мэри — человек". Это происходит потому, что при обработке цели not система не пытается доказать истинность этой цели впрямую. Вместо этого она пытается доказать противоположное утверждение, и если такое противоположное утверждение доказать не удается, система считает, что цель not — успешна. Такое рассуждение основано на так называемом \i предположении о замкнутости мира\i0  . В соответствии с этим постулатом \i мир замкнут\i0   в том смысле, что все в нем существующее либо указано в программе, либо может быть из нее выведено. И наоборот — если что-либо не содержится в программе (или не может быть из нее выведено), то оно не истинно и, следовательно, истинно его отрицание. Это обстоятельство требует особого внимания, поскольку мы обычно не считаем мир замкнутым: если в программе явно не сказано, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 человек( мэри)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то мы этим обычно вовсе не хотим сказать, что Мэри не человек.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дальнейшее изучение опасных аспектов использования not проведем на таком примере:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 r( а).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 g( b).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 p( X) :- not r( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если спросить теперь\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  g( X), p( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 система ответит\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если же задать тот же вопрос, но в такой форме\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- p( X), g( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 система ответит\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nо        (нет)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Читателю предлагается проследить работу программы по шагам, чтобы понять, почему получились разные ответы. Основная разница между вопросами состоит в том, что переменная X к моменту вычисления p( X) в первом случае была уже конкретизирована, в то время как во втором случае этого еще не произошло.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы детально обсудили аспекты применения отсечения, которое неявно присутствует в not. При этом нами руководило желание предупредить пользователей о соблюдении необходимой осторожности, а вовсе не желание убедить их совсем не пользоваться этим оператором. Отсечение полезно, а часто и необходимо. А что касается трудностей Пролога, порождаемых отсечением, то подобные неудобства часто возникают и при программировании на других языках.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Отсечение подавляет перебор. Его применяют как для повышения эффективности программ, так и для повышения выразительности языка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Эффективность повышается путем прямого указания (при помощи отсечения) пролог — системе не проверять альтернативы, про которые нам заранее известно, что они должны потерпеть неудачу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Отсечение дает возможность сформулировать взаимно исключающие утверждения при помощи правил вида:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \i если\i0   \b Условие\b0   \i то\i0   \b Утверждение1\b0   \i иначе\i0   \b Утверждение2\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Отсечение дает возможность ввести \i отрицание как неуспех\i0  : not( Цель) определяется через неуспех цели Цель.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Иногда бывают полезными две особые цели true и fail. true — всегда успешна и fail — всегда терпит неудачу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Существуют ограничения в применении отсечения: его появление может нарушить, соответствие между декларативным и процедурным смыслами программы. Поэтому хороший стиль программирования предполагает осторожное применение отсечений и отказ от их применения без достаточных оснований.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Оператор not, определенный через неуспех, не полностью соответствует отрицанию в математической логике. Поэтому not тоже нужно применять с осторожностью.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Различать "зеленые и "красные" отсечения предложил ван Эмден (1982).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 van Emden M. (1982). Red and green cuts. \i Logic Programming Newsletter:  2\i0  .\par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 6\par
Ввод и вывод\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой главе мы рассмотрим некоторые встроенные средства для записи данных в файл и считывания их из файла. Такие средства можно также применять и для форматирования объектов данных программы, чтобы получить желаемую форму их внешнего представления. Одновременно мы рассмотрим и средства синтеза и декомпозиции атомов.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 6.1. Связь с файлами\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 До сих пор мы применяли только один метод связи пользователя с программой — пользователь задает программе вопросы, а программа ему отвечает, конкретизируя переменные. Такой механизм связи прост и практичен и, несмотря на свою простоту, обеспечивает ввод и вывод информации. Однако он обладает слишком малой гибкостью и поэтому часто не совсем удобен. В следующих случаях требуется расширение этого основного механизма связи:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • ввод данных в форме, отличной от вопроса - например, в виде предложений, написанных на английском языке\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • вывод информации в произвольном формате\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • обмен информацией с произвольным файлом, а не только с пользовательским терминалом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Встроенные предикаты, предназначенные для этого расширения, отличаются в разных реализациях Пролога. Мы изучим здесь простой и удобный набор таких предикатов, применяемый во многих реализациях. Однако за деталями и специфическими особенностями следует, конечно, обращаться к руководствам по конкретным пролог-системам.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 6. 1.\b0    Связь между пролог-программой и различными файлами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим вначале вопрос о том, как обмениваться информацией с файлами, а затем — как можно вводить и выводить данные в разных форматах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 6.1 показана общая ситуация, в которой пролог-программа взаимодействует с несколькими файлами. Она может, в принципе, считывать данные из нескольких входных файлов, называемых также \i входными потоками\i0  , и выводить данные в несколько выходных файлов, называемых \i выходными потоками\i0  . Информация, поступающая с пользовательского терминала, рассматривается просто как еще один входной поток. Аналогично информация, выводимая на этот терминал, рассматривается как один из выходных потоков. На оба этих "псевдофайла" ссылаются с помощью имени user (пользователь). Имена остальных файлов программист должен выбирать в соответствии с правилами именования файлов, принятыми в используемой компьютерной системе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В каждый момент выполнения пролог-программы лишь два файла являются "активными": один для ввода, другой — для вывода. Эти два файла называются \i текущим входным потоком\i0   и \i текущим выходным потоком\i0   соответственно. В начальный момент эти два потока соответствуют терминалу. Текущий входной поток может быть заменен на другой файл ИмяФайла посредством цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 see( ИмяФайла)              ( Смотри(ИмяФайла) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такая цель всегда успешна (если только с файлом ИмяФайла все в порядке), а в качестве побочного эффекта происходит переключение ввода с предыдущего входного потока на файл ИмяФайла. Поэтому типичным примером использования предиката see является следующая последовательность целей, которая считывает информацию из файла файл1, а затем переключается обратно на терминал:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 see( файл1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 читать_из_файла( Информация),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 see( user),                  ( user — пользователь)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Текущий выходной поток может быть изменен при помощи цели вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 tell( ИмяФайла)              ( сообщить( ИмяФайла) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующая последовательность целей выводит некоторую информацию в файл3, а после этого перенаправляет последующий вывод обратно на терминал:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 tell( файл3),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 записать_в_файл( Информация),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 tell( user),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 seen                          ( конец чтения)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 закрывает текущий входной файл. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 told                          ( конец записи)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 закрывает текущий выходной файл.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Файлы могут обрабатываться только последовательно. В этом смысле все файлы ведут себя так же, как терминал. Каждый запрос на чтение из входного файла приводит к чтению в текущей позиции текущего входного потока. После этого чтения текущая позиция, естественно, будет перемещена на следующий, еще не прочитанный элемент данных. Следующий запрос на чтение приведет к считыванию, начиная с этой новой текущей позиции. Если запрос на чтение делается в конце файла, то в качестве ответа на такой запрос выдается атом end_of_file (конец файла). Считанную один раз информацию считать вторично невозможно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Запись производится точно так же, каждый запрос на вывод информации приведет к тому, что она будет присоединена в концу текущего выходного потока. Невозможно сдвинуться назад и переписать часть файла.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все файлы являются "текстовыми", т.е. файлами, состоящими из символов. Символы — это буквы, цифры и специальные знаки. О некоторых из них говорят, что они непечатаемые, поскольку, будучи выведенными на терминал, они не появляются на экране. Однако их присутствие может сказаться каким-либо другим образом, например появятся пробелы или пустые строки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существуют два основных способа, с помощью которых файлы рассматриваются в Прологе в зависимости от формы записанной в них информации. Один способ - рассматривать символ как основной элемент файла. Соответственно один запрос на ввод или вывод приведет к чтению или записи одного символа. Для этой цели предназначены встроенные предикаты get, get0 и put (получить, получить0 и выдать).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другой способ рассматривать файл — считать, что в качестве основных элементов построения файла используются более крупные единицы текста. Такой естественной более крупной единицей является прологовский терм. Поэтому каждый запрос на ввод/вывод такого типа приведет к переносу целого терма из текущего входного потока или в текущий выходной поток соответственно. Предикатами для переноса термов являются предикаты read и write (читать и писать). В этом случае информация в файле должна, конечно, по форме соответствовать синтаксису термов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очевидно, что выбор формы организации файла зависит от задачи. Всякий раз, когда особенности задачи допускают естественное представление информации в соответствии с синтаксисом термов, следует предпочесть файлы, состоящие из термов. Тогда появится возможность за одно обращение и вводу или выводу пересылать целые осмысленные фрагменты информации. С другой стороны, существуют задачи, природа которых диктует иную организацию файлов. Примером такого рода задачи является обработка предложений естественного языка, скажем, для организации диалога между системой и пользователем на английском языке. В таких случаях файлы следует рассматривать как последовательности символов, которые не укладываются в синтаксис термов.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 6.2. Обработка файлов термов \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 6.2.1. \i reаd\i0   и \i write\i0  \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Встроенный предикат read используется для чтения термов из текущего входного потока. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 read( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вызывает чтение следующего терма T и сопоставление его с X. Если X — переменная, то в результате X конкретизируется и становится равным T. Если сопоставление терпит неудачу, цель read( X) тоже терпит неудачу. Предикат read — детерминированный в том смысле, что в случае неуспеха не происходит возврата для ввода следующего терма. После каждого терма во входном файле должна стоять точка или пробел, или символ возврата каретки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если read( X) вычисляется в тот момент, когда достигнут конец текущего входного файла, тогда X конкретизируется атомом end_of_file (конец файла).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Встроенный предикат write выводит терм. Поэтому цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 write( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выведет терм X в текущий выходной файл. X будет выведен в той же стандартной форме, в какой обычно пролог-система изображает на экране или распечатке значения переменных. Полезной особенностью Пролога является то, что процедура write "знает", как изображать любой терм, как бы сложен он не был.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существуют дополнительные встроенные предикаты для форматирования вывода. Они вставляют пробелы в дополнительные строки в выходной поток. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 tab( N)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выводит N пробелов. Предикат nl (без аргументов) приводит к переходу на новую строку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующие примеры иллюстрируют использование этих процедур.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предположим, у нас есть процедура для вычисления кубов чисел:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 куб( N, С) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  С is N * N * N.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предположим далее, что мы хотим применить ее для вычисления кубов элементов некоторой последовательности чисел. Это можно сделать с помощью последовательности вопросов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- куб( 2, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = 8\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- ку6( 5, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y = 125\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  куб( 12, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Z = 1728\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для получения каждого результата нам придется набирать соответствующую цель. Давайте теперь изменим эту программу так, чтобы процедура куб сама читала соответствующие данные. Теперь программа будет сама читать данные и выводить их кубы до тех пор, пока не будет прочитан атом стоп:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 куб :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обработать( X).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( стоп) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  С is N * N * N,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( С),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  куб.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это был пример программы, декларативный смысл которой трудно сформулировать. В то же время ее процедурный смысл совершенно ясен: чтобы вычислить куб, сначала нужно считать X, а затем его обработать; если X = стоп, то все сделано, иначе вывести X&#179; и рекурсивно запустить процедуру куб для обработки остальных чисел.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С помощью этой новой процедуры таблица кубов чисел может быть получена таким образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- куб.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 8\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 5.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 125\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 12.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1728\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 стоп.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Числа 2, 5 и 12 были введены пользователем с терминала, остальные числа были выведены программой. Заметьте, что после каждого числа, введенного пользователем, должна стоять точка, которая сигнализирует о конце терма.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Может показаться, что приведённую процедуру куб можно упростить. Однако следующая попытка такого упрощения является ошибочной:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 куб :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( стоп), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 куб :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( N),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  С is N * N * N,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( С),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  куб.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Причина, по которой эта процедура работает неправильно, станет очевидной, если проследить, какие действия она выполняет с входным аргументом, скажем с числом 5. Цель read( стоп) потерпит неудачу при чтении этого числа, и оно будет потеряно навсегда. Следующая цель read введет следующий терм. С другой стороны может случиться, что сигнал стоп будет считан целью read( N), что приведет к попытке перемножить нечисловую информацию.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура куб ведет диалог между пользователем и программой. В таких случаях обычно желательно, чтобы программа перед тем, как читать с терминала новые данные, дала сигнал пользователю о том, что она готова к приему информации, а также, возможно, и о том, какого вида информация ожидается. Это делается обычно путем выдачи "приглашения" перед чтением. Нашу процедуру куб можно для этого изменить, например, так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 куб :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( 'Следующее число, пожалуйста:'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обработать( X).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( стоп) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  С is N * N * N,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( 'Куб'), write( N), write( 'равен'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( С), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  куб.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Разговор с новой версией мог бы быть, например, таким:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- куб.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующее число, пожалуйста: 5.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Куб 5 равен 125\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующее число, пожалуйста: 12.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Куб 12 равен 1728\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующее число, пожалуйста: стоп.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В некоторых реализациях для того, чтобы приглашение появилось на экране перед чтением, необходимо выдать дополнительный запрос (такой, скажем, как ttyflush) после записи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В последующих разделах мы увидим некоторые типичные примеры операций, в которых участвуют чтение и запись.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 6.2.2. Вывод списков \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме стандартного прологовского формата для списков существуют несколько других естественных форм их внешнего представления, которые в некоторых ситуациях являются более предпочтительными. Следующая процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывспис( L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выводит список L так, что каждый его элемент занимает отдельную строку:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывспис( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывспис( [X | L) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( X), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вывспис( L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если у нас есть список списков, то одной из естественных форм его выводе является такая, при которой все элементы каждого списка записываются на отдельной строке. Для этого мы определим процедуру вывспис2. Вот пример ее использования:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- вывспис2( [ [а, b, с], [d, e, f], [g, h, i] ] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а b с\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 d e f\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 g h i\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура, выполняющая эту работу, такова:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывспис2( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывспис2( [L | LL] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  строка( L), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вывспис1( LL).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 строка( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 строка( [X | L] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( X), tab( 1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  строка( L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список целых чисел иногда удобно представить в виде диаграммы. Следующая процедура диагр выводит список в такой форме (предполагается, что числа списка заключены между 0 и 80). Пример ее использования:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- диагр( [3, 4, 6, 5] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ***\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ****\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ******\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 *****\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедуру диагр можно определить так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 диагр( [N | L]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  звездочки( N), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  диагр( L).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 звеэдочки( N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N > 0,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( *),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N1 is N - 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  звездочки( N1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 звездочки( N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N =< 80.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 6.2.3. Формирование термов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предположим, наша программа имеет дело с семьями, которые представлены в виде термов так, как это сделано в гл. 4 (рис. 4.1). Тогда, если, переменная F конкретизирована термом, изображенный на рис. 4.1, то цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 write( F)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вызовет вывод этого терма в стандартной форме примерно так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 семья( членсемьи( том, фокс, дата( 7, май, 1950),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  работает( bbс, 15200)),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  членсемьи( энн, фокс, дата( 9, май, 1951),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   неработает),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [членсемьи( пат, фокс, дата( 5, май, 1973),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    неработает),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   членсемьи( джим, фокс, дата( 5, май, 1973),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    неработает)])\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родители\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  том фокс, датарожд 7 май 1950, работает bbс,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   оклад 15200\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  энн фокс, датарожд 9 май 1951, неработает\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дети\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  пат фокс, датарожд 5 май 1973, неработает\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  джим фокс, датарожд 5 май 1973, неработает\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 6.2.\b0   Улучшенный формат вывода термов, представляющих семью.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь содержится полная информация, однако форма представления легко может запутать, поскольку трудно проследить, какие ее части образуют самостоятельные семантические единицы. Поэтому обычно предпочитают выводить такую информацию в каком-либо формате, например так, как показано на рис. 6.2. Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывсемью( F)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 с помощью которой это достигается, приведена на рис. 6.3.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывсемью( семья ( Муж, Жена, Дети) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( родители), nl, nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вывчленсемьи( Муж), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вывчленсемьи( Жена), nl, nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( дети), nl, nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вывчленсемьи( Дети).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывчленсемьи( членсемьи( Имя, Фамилия, дата( Д, М, Г), Работа) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab(4), write( Имя),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab(1), write( Фамилия),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( ', дата рождения'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Д), tab( 1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( M), tab( 1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Г), write( ','),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вывработу( Работа).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывсписчлсемьи( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывсписчлсемьи( [P | L]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вывчленсемьи( P), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вывсписчлсемьи( L).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывработу( неработает) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( неработает).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывработу( работает Место, Оклад) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write(' работает '), write( Место),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( ', оклад '), write( Оклад).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 6.3.\b0    Программа, обеспечивающая вывод в формате, представленном на рис. 6.2.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 6.2.4. Обработка произвольного файла термов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Типичная последовательность целей для обработки файла F от начала до конца будет выглядеть примерно так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ... , see( F), обработкафайла, sеe( user), ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь обработкафайла — процедура, которая читает и обрабатывает последовательно каждый терм файла F один за другим до тех пор, пока не встретится конец файла. Приведем типичную схему для процедуры обработкафайла:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработкафайла :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( Терм),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обработка( Терм).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработка( end_of_file) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Все сделано\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработка( Терм) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обраб( Терм),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Обработать текущий элемент\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обработкафайла.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Обработать оставшуюся часть файла\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь обраб( Терм) представляет процедуру обработки отдельного терма. В качестве примера такой обработки рассмотрим процедуру, которая выдает на терминал каждый терм вместе с его порядковым номером. Назовем эту процедуру показфайла. У нее должен быть дополнительный аргумент для подсчета прочитанных термов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 показфайла( N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( Терм),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  показ( Терм, N).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 показ( Терм, N) :- !\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( N), tab( 2), write( Терм),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N1 is N + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  показфайла( N1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот другой пример программы обработки файлов, построенной по подобной схеме. Пусть есть файл с именем файл1, термы которого имеют форму\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 изделие( НомерИзд, Описание, Цена, ИмяПоставщика)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждый терм описывает одну строку каталога изделий. Нужно построить новый файл. содержащий только те изделия, которые выпускаются каким-то конкретным поставщиком. Поскольку поставщик в этом новом файле у всех изделий будет одинаков, его имя нужно записать только один раз в самом начале и убрать из всех остальных термов. Процедура будет называться\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 создатьфайл( Поставщик)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, если исходный каталог хранится в файле файл1, а мы хотим создать специальный каталог в файле файл2, содержащий всю информацию о том, что поставляет Гаррисон, тогда мы применим процедуру создатьфайл следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- seе( файл1), tеll( файл2), создатьфайл( гаррисон),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  see( user), tell( user).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедуру создатьфайл можно определить так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 создатьфайл( Поставщик) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Поставщик), write( '.'), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  создатьостальное( Поставщик).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 создатьостальное( Поставщик) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( Изделие),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обработать( Изделие, Поставщик).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( end_ot_file) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( Изделие( Ном, Опис, Цена, Поставщик),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Поставщик) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Изделие( Ном, Опис, Цена) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( '.'), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  создатьостальное( Поставщик).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать ( _, Поставщик) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  создатьостальное( Поставщик).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание на то, что обработать вписывает точки между термами, чтобы впоследствии файл мог быть прочитан процедурой read.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 6.1.\b0   Пусть f — файл термов. Определите процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 найтитерм( Терм)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которая выводит на терминал новый терм из f, сопоставимый с Терм'ом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 6.2.\b0   Пусть f — файл термов. Напишите процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 найтивсетермы( Терм)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которая выводит на экран все термы из f, сопоставимые с Tepм'ом. Обеспечьте при этом, чтобы во время поиска Терм не конкретизировался (это могло бы помешать ему сопоставиться с другими термами дальше по файлу).\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 6.3. Обработка символов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Символ записывается в текущий выходной поток при помощи цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 put( С)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где С — символ, который нужно вывести, в кодировке ASCII (число от 0 до 127), например, вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- put( 65), put( 66), put( 67).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 породит следующий вывод:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 АВС\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 65 — ASCII-код 'А', 66 — 'В', 67 — 'С'.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одиночный символ можно считать из текущего входного потока при помощи цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 get0( С)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Она вызывает чтение символа из входного потока, и переменная С конкретизируется ASCII-кодом этого символа. Вариантом предиката get0 является get, который используется для чтения символов, отличных от пробела. Поэтому цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 get( С)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вызовет пропуск всех непечатаемых символов (в частности пробелов) от текущей позиции во входном потоке до первого печатаемого символа. Этот символ затем тоже считывается и С конкретизируется его ASCII-кодом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве примера использования предикатов, переносящих одиночные символы, давайте рассмотрим процедуру сжатие, выполняющую следующую работу: считывание из входного потока произвольного предложения и вывод его же, но в форматированном виде — все группы идущих подряд пробелов заменены на одиночные пробелы. Для простоты будем считать, что все предложения входного потока, обрабатываемые процедурой сжатие, оканчиваются точками, а слова в них отделены одно от другого одним или несколькими пробелами, и только ими. Тогда следующее предложение будет допустимым:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Робот    пытался     налить    вина    из     бутылки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель сжатие выведет его в таком виде:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Робот пытался налить вина из бутылки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура сжатие будет иметь такую же структуру, как и процедуры обработки файлов из предыдущего раздела. Сначала она прочтет первый символ, выведет его, а затем завершит обработку, в зависимости от того, каким был этот символ. Есть три альтернативы, которые соответствуют следующим случаям: символ является точкой, пробелом или буквой. Взаимное исключение этих трех альтернатив обеспечивается в программе отсечениями:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сжатие :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  get0( С),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  put( С).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сделатьостальное( С).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сделатьостальное( 46) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % 46 -АSСII-код точки, Все сделано\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сделатьостальное( 32) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % 32 - ASCII-код пробела\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  get( С),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  put( С),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сделатьостальное( С).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сделатьостальное( Буква) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сжатие.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 6.3.\b0   Обобщите процедуру сжатие на случай запятых. Все пробелы, стоящие непосредственно перед запятой, нужно убрать, а после каждой запятой нужно поместить единственный пробел.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 6.4. Создание и декомпозиция атомов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Часто желательно информацию, считанную как последовательность символов, иметь в программе в виде атома. Для этой цели существует встроенный предикат name. Он устанавливает взаимосвязь между атомами и их кодировкой в ASCII. Таким образом,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 name( A, L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинно, если L — список кодов ASCII, кодирующих атом. Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 name( zx232, [122, 120, 50, 51, 50] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинно. Существуют два типичных способа использования name:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) дан атом, разбить его на отдельные символы;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) дан список символов, объединить их в один атом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Примером первого случая применения предиката является программа, которая имеет дело с заказами такси и водителями. Все это представлено в программе атомами\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 заказ1, заказ2, водитель1, водитель2, такси1, таксилюкс\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предикат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 такси( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 проверяет, относится ли атом X к тем атомам, которые представляют такси:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 такси( X) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  name( X, Хспис),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nаmе( такси, Тспис),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Тспис, _, Хспис).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [], L, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [А | L1], L2, [А | L3] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( L1, L2, L3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предикаты заказ и водитель можно определить аналогично.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наш следующий пример иллюстрирует применение объединения отдельных символов в один атом. Мы определим предикат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 читпредложение( Списслов)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 который считает предложение с произвольной формой на естественном языке и конкретизирует Списслов некоторым внутренним представлением этого предложения. В качестве внутреннего представления, обеспечивающего возможность дальнейшей обработки предложения, естественно избрать следующее: каждое слово входного предложения представляется прологовским атомом, а все предложение представляется списком этих атомов. Например, если входной поток таков:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мэри было приятно видеть неудачу робота.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то цель читпредложение( Предложение) вызовет конкретизацию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предложение=['Мэри', было, приятно, видеть, неудачу, робота]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для простоты будем считать, что каждое предложение оканчивается точкой и внутри него не используются никакие знаки препинания.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа для читпредложение показана на рис. 6.4. Вначале процедура читает текущий входной символ Симв, а затем передает его процедуре читостальное для завершения работы. Процедура читостальное должна правильно обработать следующие три случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Симв — точка, тогда все сделано.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Симв — пробел, — игнорировать его и читпредложение от остального ввода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Симв — буква, — сначала считать слово Слово, которое начинается с Симв, а затем запустить читпредложение, чтобы считать оставшуюся часть предложения, породив при этом Списслов. Общим результатом этого будет список [Слово | Списслов].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура, считывающая символы одного слова, такова:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 читбуквы( Буква, Буквы, Сделсимв)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ее три аргумента:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Буква — текущая буква (уже считанная) читаемого слова.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Буквы — список букв (начинающийся с буквы Буква), оставшихся до конца слова.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Следсимв — входной символ, непосредственно следующий за читаемым словом. Следсимв не должен быть буквой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы завершим данный пример замечанием о возможном применения процедуры читпредложение. Ее можно использовать в программе обработки текста на естественном языке. Предложения, представленные в виде списков слов, имеют удобную форму для дальнейшей обработки при помощи Пролога. В простейшем случае такой обработкой мог бы быть поиск во входном предложении определенных ключевых слов. Значительно более сложной задачей является понимание предложения, т.е. извлечение из него смысла, представленного в некотором избранном формализме. Это важная область исследований в искусственном интеллекте.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура читпредложение считывает предложение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и из его слов создает список атомов. Например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  читпредложение( Списслов)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 порождает\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Списслов=['Мэри', было, приятно, видеть, неудачу, робота]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если входным было предложение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Мэри было приятно видеть неудачу робота.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 читпредложение( Списслов) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  gеt0( Симв),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  читостальное( Симв, Списслов).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 читостальное( 46, []) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Конец предложения: 46 = ASCII-код для '.'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  читостальное( 32, Списслов) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % 32 = ASCII-код для пробела\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  читпредложение( Списслов).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Пропустить пробел\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 читостальное( Буква, [Слово | Списслов]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  читбуквы( Буква, Буквы, Следсимв),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Считать буквы текущего слова\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nаmе( Слово, Буквы),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   читостальное( Следсимв, Списслов).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 читбуквы( 46, [], 46) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Конец слова: 46 = точка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 читбуквы( 32, [], 32) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Конец слова: 32 = пробел\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 читбуквы( Бкв, [Бкв | Буквы], Следсимв) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  get0( Симв),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  читбуквы( Симв, Буквы, Следсимв).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 6.4.\b0   Процедура для преобразования предложения в список атомов.\par
\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 6.4.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 начинается( Атом, Символ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 для проверки, начинается ли Атом с символа Символ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 6.5.\b0   Определите процедуру plural, которая преобразует английские существительные из единственного числа во множественное, добавляя к слову окончание s. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- plural( table, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X  =  tables\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 6.6.\b0   Напишите процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 поиск( Ключслово, Предложение)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которая при каждом вызове находит в текущем входном файле предложение, содержащее заданное ключевое слово Ключслово. Предложение в своей исходной форме должно быть представлено в виде последовательности символов или в виде атома (процедуру читпредложение из данного раздела можно соответственно модифицировать).\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 6.5. Ввод программ: \i consult, reconsult\i0  \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Передавать программы пролог-системе можно при помощи двух встроенных предикатов: consult и reconsult. Чтобы система считала программу из файла F, нужно поставить цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- consult( F).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате все предложения программы, содержащейся в F, будут использованы пролог-системой при ответе на дальнейшие вопросы пользователя. Если позже в том же сеансе произойдет "консультация" с другим файлом, предложения этого нового файла будут просто добавлены в конец текущего множества предложений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы запустить программу, не обязательно записывать ее в файл, а затем "консультироваться" с ним. Вместо чтения файла система может принимать программу прямо с терминала, который соответствует псевдофайлу user. Добиться этого можно так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- consult( user).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После этого система будет ожидать ввода предложений программы с терминала.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В некоторых пролог-системах применяется сокращенная запись для чтения программ из файлов. Файлы, из которых предстоит чтение, просто помещаются в список и этот список используется в качестве цели. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- [файл1, файл2, файл3].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это в точности эквивалентно следующим трем целям:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  соnsult( файл1), соnsult( файл2), соnsult( файл3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Встроенный предикат reconsult аналогичен consult. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- reconsult( F).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 даст тот же эффект, что и consult( F) с одним исключением. Если в F есть предложения, касающиеся отношений, которые уже были определены ранее, старые определения заменяются на новые из F. Разница между consult и reconsult в том, что consult всегда добавляет новые предложения, в то время как reconsult переопределяет ранее введенные определения. Однако reconsult не произведет никакого эффекта на те отношения, о которых в F ничего не сказано.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следует еще раз заметить, что детали "консультирования" с файлами зависят от конкретной реализации Пролога. Это замечание касается и большинства остальных встроенных процедур.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Ввод и вывод (отличный от связанного с вопросами к программе) осуществляется посредством встроенных процедур. В данной главе описан простой и практичный набор таких процедур, имеющихся во многих реализациях Пролога.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Файлы являются последовательными. Существуют \i текущие входной\i0   и \i выходной потоки\i0  . Пользовательский терминал рассматривается как файл с именем user.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Переключение между потоками осуществляется с помощью процедур:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 sее( Файл)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Файл становится текущим входным потоком\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 tell( Файл)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Файл становится текущим выходным потоком\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 seen\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  закрывается текущий входной поток\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 told\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  закрывается текущий выходной поток\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Файлы читаются и записываются двумя способами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   как последовательности символов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   как последовательности термов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Встроенные процедуры для чтения и записи символов и термов таковы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 rеad( Терм)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   вводит следующий терм\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 write( Терм)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   выводит Терм\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 put( КодСимвола)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   выводит символ с заданным ASCII-кодом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 get0( КодСимвола)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   вводит следующий символ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 gеt( КодСимвола) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   вводит ближайший следующий "печатаемый" символ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Две процедуры облегчают форматирование:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nl      начинает новую строку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 tab( N) выводит N пробелов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Процедура nаmе( Атом, СписокКодов) осуществляет синтез и декомпозицию атомов. СписокКодов — список ASCII кодов символов, образующих Атом. \par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 7\par
Другие встроенные процедуры\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В данной главе мы изучим некоторые другие, не упоминавшиеся ранее встроенные процедуры, предназначенные для более серьезного программирования на Прологе. Эта новые процедуры дают возможность запрограммировать операции, которые известными нам средствами запрограммировать невозможно. Один набор таких процедур касается обработки термов: эти процедуры проверяют, была ли некоторая переменная конкретизирована целым числом, они разбирают термы на части, конструируют новые термы и т.д. Другой полезный набор процедур работает с "базой данных": процедуры из этого набора добавляют новые отношения в программу или удаляют из нее существующие.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Множество встроенных процедур сильно зависит от конкретной реализации Пролога. Однако процедуры, обсуждаемые в данной главе, имеются во многих реализациях. Различные реализации могут иметь свои наборы дополнительных средств.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 7.1. Проверка типов термов \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 7.1.1. Предикаты \i var\i0  , \i nоnvar\i0  , \i atom\i0  , \i integer\i0  , \i atomic\i0  \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Термы бывают разных типов: переменные, целые числа, атомы и т.д. Если терм — переменная, то в некоторый момент выполнения программы он может оказаться конкретизированным или не конкретизированным. Далее, если он конкретизирован, то его значение может быть атомом, структурой и т.п. Иногда бывает полезно узнать, каков тип этого значения. Например, пусть мы хотим сложить значения двух переменных X и Y:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Z is X + Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перед вычислением этой цели необходимо, чтобы X и Y были конкретизированы целыми числами. Если у нас нет уверенности в том, что X и Y действительно конкретизированы целыми числами, то перед выполнением арифметического действия нужно проверить это программно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для этого следует воспользоваться встроенным предикатом integer (целое). Предикат integer( X) принимает значение истина, если X — целое или если X — переменная, имеющая целое значение. Будем говорить в этом случае, что X "обозначает" целое. Цель для сложения X и Y можно тогда "защитить" такой проверкой переменных X и Y:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ..., integer( X), integer( Y), Z is X + Y, ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если неверно, что X и Y оба являются целыми, то система и не будет пытаться их сложить. Таким образом, цели integer "охраняют" цель Z is X + Y от бессмысленного вычисления.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Встроенные предикаты этого типа таковы: var (переменная), nonvar (непеременная), atom (атом), integer (целое), atomic (атомарный). Они имеют следующий смысл:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 var( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта цель успешна, если X в текущий момент — не конкретизированная переменная.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nonvar( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта цель успешна, если X — терм, отличный от переменной, или если X — уже конкретизированная переменная.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 atom( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта цель истинна, если X обозначает атом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 integer( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель истинна, если X обозначает целое.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 atomic( X)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель истинна, если X обозначает целое или атом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующие примеры вопросов к пролог-системе иллюстрируют применение этих встроенных предикатов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- var( Z), Z = 2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Z = 2\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- Z = 2, var( Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- integer( Z), Z = 2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- Z = 2, integer( Z), nonvar( Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Z = 2\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- atom( 22).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- atomic( 22).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- atom( ==>).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- atom( p( 1) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Необходимость в предикате atom продемонстрируем на следующем примере. Пусть мы хотим подсчитать, сколько раз заданный атом встречается в некоторой списке объектов. Для этого мы определим процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( А, L, N)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где А — атом, L — список и N — количество вхождений этого атома. В качестве первой попытки можно было бы определить счетчик так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( _, [], 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( A, [A | L], N) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  счетчик( A, L, N1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % N1 - число вхождений атома в хвост\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N is N1 + 1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( А, [ _ | L], N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  счетчик( A, L, N).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь на нескольких примерах посмотрим, как эта процедура работает:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- счетчик( а, [а, b, а, а], N).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 N = 3\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- счетчик( a, [a, b, X, Y], Na).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Na = 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- счетчик( b, [a, b, X, Y], Nb).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Nb = 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- L=[a, b, X, Y], счетчик( а, L, Na), счетчик( b, L, Nb).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Na = 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Nb = 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y = a\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В последнем примере как X, так и Y после конкретизации получили значение а, и поэтому Nb оказалось равным только 1, однако мы хотели не этого. Нас интересовало количество реальных появлений конкретного \i атома\i0  , а вовсе не число термов, \i сопоставимых\i0   с этим атомом. В соответствии с этим более точным определением отношения счетчик мы должны теперь проверять, является ли голова списка атомом. Усовершенствованная программа выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( _, [], 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( А, [В | L], N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  atom( В), А = В, !, % B равно атому А?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( A, L, N1),  % Подсчет в хвосте\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N is N1 + 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( А, L, N).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Иначе - подсчитать только в хвосте\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В следующем более сложном упражнении по программированию числовых ребусов используется предикат nonvar.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 7.1.2. Решение числового ребуса с использованием \i nonvar\i0  \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Известным примером числового ребуса является\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 D O N A L D\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 +\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 G E R A L D\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 -----------\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 R O B E R T\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задача состоит в том. чтобы заменить буквы D, О, N и т.д. на цифры таким образом, чтобы вышеприведенная сумма была правильной. Разным буквам должны соответствовать разные цифры, иначе возможно тривиальное решение, например, все буквы можно заменить на нули.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Определим отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумма( N1, N2, N)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где N1, N2 и N представляют три числа данного ребуса. Цель cyммa(N1, N2, N) достигается, если существует такая замена букв цифрами, что N1+N2 = N.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первым шагом к решению будет выбор представления чисел N1, N2 и N в программе. Один из способов - представить каждое число в виде списка его цифр. Например, число 255 будет тогда представляться списком [2, 2, 5]. Поскольку значения цифр нам не известны заранее, каждая цифра будет обозначаться соответствующей неинициализированной переменной. Используя это представление, мы можем сформулировать задачу так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   [ D, O, N, A, L, D ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 + [ G, E, R, A, L, D ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 = [ R, О, B, E, R, T ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь задача состоит в том. чтобы найти такую конкретизацию переменных D, О, N и т.д., для которой сумма верна. После того, как отношение сумма будет запрограммировано, задание для пролог-системы на решение ребуса будет иметь вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- сумма( [D, O, N, A, L, D], [G, E, R, A, L, D],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [R, O, В, E, R, T ).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 7.1. \b0  Поразрядное сложение. Отношения в показанном i-м разряде такие: D\sub 3i \nosupersub = (C1 + D\sub 1i\nosupersub  + D\sub 2i\nosupersub ) mod 10; C = (C1 + D\sub 1i\nosupersub  + D\sub 2i\nosupersub ) div 10 (div — целочисленное деление, mod — остаток от деления).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для определения отношения сумма над списками цифр нам нужно запрограммировать реальные правила суммирования в десятичной системе счисления. Суммирование производится цифра за цифрой, начиная с младших цифр в сторону старших, всякий раз учитывая цифру переноса справа. Необходимо также сохранять множество допустимых цифр, т.е. цифр, которые еще не были использованы для конкретизации уже встретившихся переменных. Поэтому, вообще говоря, кроме трех чисел N1, N2 и N в рассмотрении должна участвовать некоторая дополнительная информация, как показано на рис. 7.1:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • перенос перед сложением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • перенос после сложения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • множество цифр, доступных перед сложением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • оставшиеся цифры, не использованные при сложении\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для формулировки отношения сумма мы снова воспользуемся принципом обобщения задачи: введем вспомогательное, более общее отношение сумма1. Это отношение будет иметь несколько дополнительных аргументов, соответствующих той дополнительной информации, о которой говорилось выше:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумма1( N1, N2, N, C1, С, Цифры1, Цифры)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь N1, N2 и N — наши три числа, как и в отношении сумма, C1 — перенос справа (до сложения N1 и N2), а С — перенос влево (после сложения). Пример:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- сумма1( [H, E], [6, E], [U, S], 1, 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [1, 3, 4, 7, 8, 9], Цифры ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 H = 8\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 E = 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 S = 7\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 U = 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цифры = [1, 9]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если N1 и N удовлетворяют отношению сумма, то, как показано на рис. 7.1, C1 и С должны быть равны 0. Цифры1 — список цифр, которые не были использованы для конкретизации переменных. Поскольку мы допускаем использование в отношении сумма любых цифр, ее определение в терминах отношения сумма1 выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумма( N1, N2, N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  cyммa1( N1, N2, N, 0, 0, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Бремя решения задачи переложено теперь на отношение сумма1. Но это отношение является уже достаточно общим, чтобы можно было определить его рекурсивно. Без ограничения общности мы предположим, что все три списка, представляющие три числа, имеют одинаковую длину. Наш пример, конечно, удовлетворяет этому условию, но если это не так, то всегда можно приписать слева нужное количество нулей к более "короткому" числу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Определение отношения сумма1 можно разбить на два случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Все три числа представляются пустыми списками. Тогда\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумма1( [], [], [], 0, 0, Циф, Циф).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Все три числа имеют какую-то самую левую цифру и справа от нее - остальные цифры. То есть, они имеют вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [D1 | N1], [D2 | N2], [D | N]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом случае должны выполняться два условия:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (а) Оставшиеся цифры, рассматриваемые как три числа N1, N2 и N, сами должны удовлетворять отношению сумма1, выдавая влево некоторый перенос C2 и оставляя некоторое подмножество неиспользованных цифр Циф2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (b) Крайние левые цифры D1, D2 и D, а также перенос C2 должны удовлетворять отношению, показанному на рис. 7.1: C2, D1 и D2 складываются, давая в результате D и перенос влево. Это условие в нашей программе формулируется в виде отношения суммацифр.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переводя это на Пролог, получаем:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумма1( [D1 | N1], [D2 | N2], [D | N], C1, С, Циф1, Циф) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сумма1( Nl, N2, N, C1, C2, Циф1, Циф2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  суммацифр( D1, D2, C2, D, С, Циф2, Циф).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Осталось только описать на Прологе отношение суммацифр. В его определении есть одна тонкая деталь, касающаяся применения металогического предиката nonvar. D1, D2 и D должны быть десятичными цифрами. Если хоть одна из этих переменных еще не конкретизирована, ее нужно конкретизировать какой-нибудь цифрой из списка Циф2. Как только такая конкретизация произошла, эту цифру нужно удалить из множества доступных цифр. Если D1, D2 и D уже конкретизированы, тогда, конечно, ни одна из доступных цифр "потрачена" не будет. В программе эти действия реализуются при помощи недетерминированного вычеркивания элемента списка. Если этот элемент - не переменная, ничего не вычеркивается (конкретизации не было). Вот эта программа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( Элемент, Список, Список) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nonvar( Элемент), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( Элемент, [Элемент | Список ], Список).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить(Элемент, [А | Список], [А | Список1]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( Элемент, Список, Список1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Полная программа для решения арифметических ребусов приводится на рис. 7.2. В программу включены также определения двух ребусов. Вопрос к пролог-системе для ребуса про DONALD'a, GERALD'a и ROBERT'a с использованием этой программы выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- ребус1( N1, N2, N), сумма( N1, N2, N).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Решение числовых ребусов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумма( N1, N2, N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Числа представлены в виде списков цифр\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сумма1( N1, N2, N,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   0, 0,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    % Перенос справа и перенос влево равны 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    % Все цифры доступны\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумма1( [], [], [], 0, 0, Цифры, Цифры).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумма1( [D1 | N1], [D2 | N2], [D | N], C1, С, Циф1, Циф) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сумма1( Nl, N2, N, C1, C2, Циф1, Циф2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  суммацифр( Dl, D2, C2, С, Циф2, Циф).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 суммацифр( Dl, D2, C1, D, С, Циф1, Циф) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( D1, Циф1, Циф2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Выбор доступной цифры для D1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( D2, Циф2, Циф3),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Выбор доступной цифры для D2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( D, Циф3, Циф),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Выбор доступной цифры для D\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  S is D1 + D2 + C1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  D is S mod 10,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  С is S div 10.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( A, L, L) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nonvar( A), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Переменная А уже конкретизирована\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( А, [А | L], L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( А, [В | L], [В | L1]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( A, L, L1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Примеры ребусов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ребус1( [D, O, N, A, L, D],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [G, E, R, A, L, D],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [R, O, B, E, R, T].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ребус2( [0, S, E, N, D],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [0, M, O, R, E],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [M, O, N, E, Y].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 7.2.\b0    Программа для арифметических ребусов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иногда этот ребус упрощают, сообщая часть решения в виде дополнительного ограничения, например D равно 5. В такой форме ребус можно передать пролог-системе при помощи сумма1:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- сумма1( [5, O, N, A, L, 5],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [G, E, R, A, L, 5],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [R, O, B, E, R, T],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  0, 0, [0, 1, 2, 3, 4, 6, 7, 8, 9], _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Интересно, что в обоих случаях существует только одно решение, т.е. только один способ заменить буквы цифрами.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 7.1.\b0   Напишите процедуру упростить для упрощения алгебраических сумм, в которых участвуют числа и символы (строчные буквы). Пусть эта процедура переупорядочивает слагаемые так, чтобы символы предшествовали числам. Вот примеры ее использования:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- упростить( 1 + 1 + а, E).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 E = а + 2\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- упростить( 1 + a + 4 + 2 + b + с, E).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 E = а + b + с + 7\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- упростить( 3 + x + x, E).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 E = 2*x + 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 7.2.\b0   Определите процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( Элемент, Список)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 для добавления нового элемента в список. Предполагается, что все элементы, хранящиеся в списке, — атомы. Список состоит из всех хранящихся в нем элементов, а за ними следует хвост, который не конкретизирован и служит для принятия новых элементов. Пусть, например, в списке уже хранятся а, b и с, тогда\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список = [а, b, с | Хвост]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Хвост — переменная. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( d, Список)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вызовет конкретизацию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Xвoст = [d | НовыйХвост] и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список = [а, b, с, d | НовыйХвост]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким способом структура может наращиваться, включая в себя новые элементы. Определите также соответствующее отношение принадлежности.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 7.2. Создание и декомпозиция термов: \i =.., functor, arg, name\i0  \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имеются три встроенные предиката для декомпозиции и синтеза термов: functor, arg и =... Рассмотрим сначала отношение =.., которое записывается как инфиксный оператор. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Терм =.. L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинна, если L — список, начинающийся с главного функтора терма Терм, вслед за которым идут его аргументы. Вот примеры:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- f( а, b) =.. L.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [f, а, b]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- T =.. [прямоугольник, 3, 5].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 T = прямоугольник( 3, 5)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- Z =.. [p, X, f( X,Y) ].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Z = p( X, f( X,Y) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Зачем может понадобиться разбирать терм на составляющие компоненты — функтор и его аргументы? Зачем создавать новый терм из заданного функтора и аргументов? Следующий пример показывает, что это действительно нужно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим программу, которая манипулирует геометрическими фигурами. Фигуры — это квадраты, прямоугольники, треугольники, окружности в т.д. В программе их можно представлять в виде термов, функтор которых указывает на тип фигуры, а аргументы задают ее размеры:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 квадрат( Сторона)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 треугольник( Сторона1, Сторона2, Сторона3)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 окружность( R)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одной из операций над такими фигурами может быть увеличение. Его можно реализовать в виде трехаргументного отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 увел( Фиг, Коэффициент, Фиг1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Фиг и Фиг1 — геометрические фигуры одного типа (с одним в тем же функтором), причем параметры Фиг1 равны параметрам Фиг, умноженным на Коэффициент. Для простоты будем считать, что все параметры Фиг, а также Коэффициент уже известны, т.е. конкретизированы числами. Один из способов программирования отношения увел таков:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 увел( квадрат( A), F, квадрат( А1) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  A1 is F*A\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 увел( окружность( R), F, окружность( R1) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  R1 is F*R1\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 увел( прямоугольник( А, В), F, прямоугольник( А1, В1)) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  A1 is F*A, B1 is F*B.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такая программа будет работать, однако она будет выглядеть довольно неуклюже при большом количестве различных типов фигур. Мы будем вынуждены заранее предвидеть все возможные типы, которые могут когда-либо встретиться. Придется заготовить по предложению на каждый тип, хотя во всех этих предложениях по существу говорится одно и то же: возьми параметры исходной фигуры, умножь их на коэффициент и создай фигуру того же типа с этими новыми параметрами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ниже приводится программа, в которой делается попытка (неудачная) справиться для начала хотя бы со всеми однопараметрическими фигурами при помощи одного предложения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 увел( Тип( Пар), F, Тип( Пар1) ):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Пар1 is F*Пар.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако в Прологе подобные конструкции, как правило, запрещены, поскольку функтор должен быть атомом, и, следовательно, переменная Тип синтаксически не будет воспринята как функтор. Правильный метод — воспользоваться предикатом '=..'. Тогда процедура увел будет иметь обобщенную формулировку, пригодную для фигур любых типов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 увел( Фиг, F, Фиг1):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Фиг =.. [Тип | Параметры],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  умножспис( Параметры, F, Параметры1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Фиг1 =.. [Тип | Параметры)].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 умножспис( [], _, []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 умножспис( [X | L], F, [X1 | L1] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X1 is F*X, умножспис( L, F, L1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наш следующий пример использования предиката '=..' связан с обработкой символьных выражений (формул), где часто приходится подставлять вместо некоторого подвыражения другое выражение. Мы определим отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подставить( Подтерм, Терм, Подтерм1, Терм1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 следующим образом: если все вхождения Подтерм'а в Терм заменить на Подтерм1, то получится Терм1. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- подставить( sin( x), 2*sin( x)*f( sin( x)), t, F ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 F = 2*t*f( t)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Под "вхождением" Подтерм'а в Терм мы будем понимать такой элемент Терм'а, который \i сопоставим\i0   с Подтерм'ом. Вхождения будем искать сверху вниз. Поэтому цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- подставить( а+b, f( а, А+В), v, F).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 даст результат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 F = f( а, v)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А = а\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В = b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а не\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 F = f( a, v + v)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А = а + b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В = а + b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При определении отношения подставить нам нужно рассмотреть несколько случаев и для каждого принять свое решение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если Подтерм = Терм, то Терм1 = Подтерм1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 иначе если Терм — "атомарный" (не структура),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  то Терм1 = Терм (подставлять нечего),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  иначе подстановку нужно выполнить над аргументами Tерм'a.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти правила можно превратить в программу, показанную на рис. 7.3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Термы, полученные при помощи предиката '=..', разумеется, можно использовать и в качестве целей. Это дает возможность программе в процессе вычислений самой порождать и вычислять цели, структура которых не обязательно была известна заранее в момент написания программы. Последовательность целей, иллюстрирующая этот прием, могла бы выглядеть примерно так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 получить( Функтор),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вычислить( Списарг),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Цель =.. [Функтор | Списарг],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь получить и вычислить — некоторые определенные пользователем процедуры, предназначенные для вычисления компонент цели. После этого цель порождается предикатом '=..', а затем активизируется при помощи простого указания ее имени Цель.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % подставить( Подтерм, Терм, Подтерм1, Терм1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % состоит в следующем: если все вхождения Подтерм'а в Терм\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % заменить на Подтерм1, то получится Терм1.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Случай 1: Заменить весь терм\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подставить( Терм, Терм, Терм1, Терм1) :- !.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Случай 2: нечего подставлять\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подставить( _, Терм, _, Терм) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  atomic( Терм), !.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Случай 3: Проделать подстановку в аргументах\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подставить( Под, Терм, Под1, Терм1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Терм =.. [F | Арги],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Выделить аргументы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  подспис( Под, Арги, Под1, Арги1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Выполнить над ними подстановку\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Терм1 =.. [F | Арги1].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подспис( Под, [Терм | Термы], Под1, [Терм1 | Термы1]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  подставить( Под, Терм, Под1, Терм1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  подспис( Под, Термы, Под1, Термы1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 7.3.\b0    Процедура подстановки в терм вместо одного из его подтермов некоторого другого подтерма.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Некоторые реализации Пролога могут содержать требование, чтобы все цели, появляющиеся в программе, по своей \i синтаксической\i0   форме были либо атомами, либо структурами с атомом в качестве главного функтора. Поэтому переменная, вне зависимости от ее текущей конкретизации, может по своей синтаксической форме не подойти в качестве цели. Эту трудность можно обойти при помощи еще одного встроенного предиката call (вызов), чьим аргументом является цель, подлежащая вычислению. В соответствий с этим предыдущий пример должен быть переписан так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель = [Функтор | Списарг],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 саll( Цель)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иногда нужно извлечь из терма только его главный функтор или один из аргументов. В этом случае можно, конечно, воспользоваться отношением '=..'. Но более аккуратным и практичным, а также и более эффективным способом будет применение одной из двух новых встроенных процедур: functor и аrg. Вот их смысл: цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 functor( Терм, F, N)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинна, если F — главный функтор Tepм'a, а N — арность F. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 arg( N, Терм, А)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинна, если А — N-й аргумент в Терм'е, в предположении, что нумерация аргументов идет слева направо и начинается с 1. Примеры для иллюстрации:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- functor( t( f( x), X, t), Фун, Арность).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Фун = t\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Арность = 3\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- аrg( 2, f( X, t( a), t( b) ), Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Y = t( a)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- functor( D, дата, 3),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 arg( 1, D, 29),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 arg( 2, D, июнь),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 arg( 3, D, 1982).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 D = дата( 29, июнь, 1982)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Последний пример иллюстрирует особый случай применения предиката functor. Цель functor( D, дата, 3) создает "обобщенный" терм с главным функтором дата и тремя аргументами. Этот терм обобщенный, так как все три его аргумента — не конкретизированные переменные, чья имена генерируются пролог-системой. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 D = дата( _5, _6, _7)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Затем эти три переменные конкретизируются при помощи трех целей аrg.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К рассматриваемому множеству встроенных предикатов относится также и введенный в гл. 6 предикат name, предназначенный для синтеза и декомпозиция атомов. Для полноты изложения мы здесь напомним его смысл. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 name( A, L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинна, если L — список кодов (в кодировке ASCII) символов, входящих в состав атома А.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 7.3.\b0   Определите предикат конкрет(Терм) так, чтобы он принимал значение истина, когда в Tepм'e нет ни одной неконкретизированной переменной.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 7.4.\b0   Процедура подставить из данного раздела производит, при наличии разных вариантов, лишь самую "внешнюю" подстановку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Модифицируйте эту процедуру так, чтобы она находила все возможные варианты при помощи автоматического перебора. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- подставить( a+b, f( A+B), новый, НовыйТерм).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А = а\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В = b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 НовыйТерм = f( новый);\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А = а+b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В = а+b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 НовыйТерм = f( новый + новый)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша исходная версия нашла бы только первый из этих двух ответов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 7.5. \b0  Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 включает( Tepм1, Терм2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которое выполняется, если Терм1 является более общим, чем Терм2. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- включает( X, с).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- включает( g( X), g( t( Y))).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- включает f( X,X), f( a,b)).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 7.3. Различные виды равенства\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В каких случаях мы считаем, что два терма равны? До сих пор мы рассматривали три вида равенства в Прологе. Первый был связан с сопоставлением и записывался так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это равенство верно, если X и Y сопоставимы. Следующий вид равенства записывался в виде\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X is E\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такое равенство выполняется, если X сопоставим со значением арифметического выражения E. Мы также рассматривали равенства вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Е1 =:= Е2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которые верны, если равны значения арифметических выражений Е1 и Е2. Наоборот, если значения двух арифметических выражений не равны, мы пишем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Е1 =/= Е2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иногда нам может понадобиться более строгий вид равенства - \i буквальное равенство\i0   двух термов. Этот вид реализован еще одним встроенным предикатом, записываемым как инфиксный оператор '==':\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Т1 == Т2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это равенство выполняется, если термы Т1 и Т2 идентичны, т.е. имеют в точности одинаковую структуру, причем все соответствующие компоненты совпадают. В частности, должны совпадать и имена переменных. Отношение "не идентичны", дополнительное к данному, записывается так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 T1 \\== T2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведем несколько примеров:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- f( a, b) == f( а, b).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- f( a, b) == f( a, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nо\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- f( a, X) == f( a, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- X \\== Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- t( X, f( a, Y) ) == t( X, f( a, Y) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте в качестве примера переопределим отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( Терм, Список, N)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 из разд. 7.1. Пусть на этот раз N будет числом буквальных вхождений Терм'а в Список:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( _, [], 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( Терм, [Голова | L], N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Терм == Голова, !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  счетчик( Терм, L, N1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N is N1 + 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 счетчик( Терм, L, N). \par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 7.4. Работа с базой данных\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Реляционная модель предполагает, что база данных — это описание некоторого множества отношений. Пролог-программу можно рассматривать как именно такую базу данных: описание отношений частично присутствует в ней в явном виде (факты), а частично — в неявном (правила). Более того, встроенные предикаты дают возможность корректировать эту базу данных в процессе выполнения программ. Это делается добавлением к программе (в процессе вычисления) новых предложений или же вычеркиванием из нее уже существующих. Предикаты, используемые для этой цели, таковы: assert (добавить), asserta, assertz и retract (удалить).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 assert( С)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 всегда успешна, а в качестве своего побочного эффекта вызывает "констатацию" предложения С, т.е. добавление его к базе данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 retract( С)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 приводит к противоположному эффекту: удаляет предложение, сопоставимое с С. Следующий диалог иллюстрирует их работу:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- кризис.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- assert( кризис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- кризис.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- retract( кризис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- кризис.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предложения, добавленные к программе таким способом, ведут себя точно так же, как и те, что были в "оригинале" программы. Следующий пример показывает, как с помощью assert и retract можно работать в условиях изменяющейся обстановки. Предположим, что у нас есть такая программа о погоде:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 хорошая :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  солнечно, not дождь.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 необычная :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  солнечно, дождь.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отвратительная :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  дождь, туман.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дождь.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 туман.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ниже приводится пример диалога с этой программой, во время которого база данных постепенно изменяется:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- хорошая.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- отвратительная.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- retract( туман).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- отвратительная.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- assert( солнечно).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- необычная.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- retract( дождь).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- хорошая.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Добавлять и удалять можно предложения любой формы. Следующий пример показывает, что, кроме того, retract может работать недетерминировано: используя механизм возвратов с помощью только одной цели retract можно удалить целое множество предложений. Предположим, что в программе, с которой мы "консультируемся", есть такие факты:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 быстр( энн).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 медл( том).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 медл( пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К этой программе можно добавить правило:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- assert(\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( быстрее( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    быстр( X), медл( Y) ) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- быстрее( А, В).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А = энн\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В = том\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- retract( медл( X) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = том;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = пат;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nо\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- быстрее( энн, _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nо\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметьте, что при добавлении нового правила синтаксис требует, чтобы оно (как аргумент assert) было заключено в скобки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При добавлении нового предложения может возникнуть желание указать, на какое место в базе данных его следует поместить. Такую возможность обеспечивают предикаты asserta и assertz. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 asserta( С)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 помещает С в начале базы данных. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 assertz( С)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 — в конце. Вот пример, иллюстрирующий работу этих предикатов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- assеrt( p( a)), assertz( p( b) ), asserta( p( c) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- p( X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = с;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = а;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Между consult и assertz существует связь. Обращение к файлу при помощи consult можно в терминах assertz определить так: считать все термы (предложения) файла и добавить их в конец базы данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одним из полезных применений предиката asserta является накопление уже вычисленных ответов на вопросы. Пусть, например, в программе определен предикат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Задача, Решение)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем теперь задать вопрос и потребовать, чтобы ответ на него был запомнен, с тем чтобы облегчить получение ответов на будущие вопросы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- решить( задача1, решение),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  asserta( решить( Задача1, Решение) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если в первой из приведенных целей будет успех, ответ ( Решение) будет сохранен, а затем использован так же, как и любое другое предложение, при ответе на дальнейшие вопросы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Преимущество такого "запоминания" состоит в том, что на дальнейшие вопросы, сопоставимые с добавленным фактом, ответ будет получен, как правило, значительно быстрее, чем в первый раз. Ответ будет теперь получен как факт, а не как результат вычислений, требующих, возможно, длительного времени.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Развитие этой идеи состоит в использовании assert для порождения всех решений в виде таблицы фактов. Например, создать таблицу произведений всех чисел от 0 до 9 можно так: породить пару чисел X и Y, вычислить Z, равное X * Y, добавить эти три числа в виде строки в таблицу произведений, а затем создать искусственно неуспех. Неуспех вызовет возврат, в результате которого будет найдена новая пара чисел, и в таблицу добавится новая строка и т.д. Эта идея реализована в процедуре\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 таблица :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, L), % Выбрать первый сомножитель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Y, L), % Выбрать второй сомножитель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Z is X*Y,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  assert( произв( X,Y,Z) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  fail.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- таблица.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 потерпит, конечно, неудачу, однако в качестве своего побочного эффекта приведет к добавлению в базу данных целой таблицы произведений. После этого можно, например, спросить, какие пары дают произведения, равные 8:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- произв( А, В, 8).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А = 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В = 8;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А = 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В = 4;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь следует сделать одно замечание, относящееся к стилю программирования. Приведенные примеры показали некоторые явно полезные применения assert и retract. Однако использование этих отношений требует особой внимательности. Не рекомендуется применять их слишком часто и без должной осторожности - это плохой стиль программирования. Ведь добавляя и удаляя предложения, мы фактически изменяем программу. Поэтому отношения, выполнявшиеся в некоторой ее точке, могут оказаться неверными в другой. В разные моменты времени ответы на одни и те же вопросы будут различными. Таким образом, большое количество обращений к assert и retract может затемнить смысл программы и станет трудно разобрать, что истинно, а что — нет. В результате поведение программы может стать непонятным, трудно объяснимым, и вряд ли можно будет ей доверять.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 7.6.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (а) Напишите вопрос к пролог-системе, который удаляет из базы данных всю таблицу произв.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (b) Измените этот вопрос так, чтобы он удалил из таблицы только те строки, в которых произведение равно 0.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 7.7.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 копия( Терм, Копия)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которое порождает такую копию Терм'а Копия, в которой все переменные переименованы. Это легко сделать, используя assert и retract.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 7.5. Средства управления\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К настоящему моменту мы познакомились с большинством дополнительных средств управления, за исключением repeat (повторение). Здесь мы для полноты приводим список всех таких средств.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i отсечение\i0  , записывается как '!', предотвращает перебор, введено в гл. 5.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • fail — цель, которая всегда терпит неудачу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • true — цель, которая всегда успешна.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • not( P) — вид отрицания, который всегда ведет себя в точном соответствии со следующим определением:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 not( P) :- P, !, fail; true.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Некоторые проблемы, связанные с отсечением и not детально обсуждались в гл. 5.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • саll( P) активизирует цель P. Обращение к саll имеет успех, если имеет успех P.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • repeat — цель, которая всегда успешна. Ее особое свойство состоит в том, что она недетерминирована, поэтому всякий раз, как до нее доходит перебор, она порождает новую ветвь вычислений. Цель repeat ведет себя так, как если бы она была определена следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 repeat.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 repeat :- repeat.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Стандартный способ применения repeat показан в процедуре квадраты, которая читает последовательность чисел и выдает их квадраты. Последовательность чисел заканчивается атомом стоп, который служит для процедуры сигналом окончания работы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 квадраты :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  repeat,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( X = стоп, !;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Y is X*X, write( Y), fail ).\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 7.6. \i bagof\i0  , \i setof\i0   и \i findall\i0  \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При помощи механизма автоматического перебора можно получить одни за другим все объекты, удовлетворяющие некоторой цели. Всякий раз, как порождается новое решение, предыдущее пропадает и становится с этого момента недоступным. Однако у нас может возникнуть желание получить доступ ко всем порожденным объектам сразу, например собрав их в список. Встроенные предикаты bagof (набор) и setof (множество) обеспечивают такую возможность; вместо них иногда используют предикат findall (найти все).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 bagof( X, P, L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 порождает список L всех объектов X, удовлетворяющих цели P. Обычно bagof имеет смысл применять только тогда, когда X и P содержат общие переменные. Например, допустим, что мы включили в программу следующую группу предложений для разбиения букв (из некоторого множества) на два класса — гласные и согласные:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( а, глас).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( b, согл).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( с, согл).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( d, согл).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( e, глас).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( f, согл).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда мы можем получить список всех согласных, упомянутых в этих предложениях, при помощи цели:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- bagof( Буква, класс( Буква, согл), Буквы).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Буквы = [d, c, d, f]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если же мы в указанной цели оставим класс букв неопределенным, то, используя автоматический перебор, получим два списка букв, каждый из которых соответствует одному из классов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- bagof( Буква, класс( Буква, Класс), Буквы).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Класс = глас\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Буквы = [а,e]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Класс = согл\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Буквы = [b, c, d, f]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если bagof( X, P, L) не находит ни одного решения для P, то цель bagof просто терпит неуспех. Если один и тот же X найден многократно, то все его экземпляры будут занесены в L, что приведет к появлению в L повторяющихся элементов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предикат setof работает аналогично предикату bagof. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 setof( X, P, L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 как и раньше, порождает список L объектов X, удовлетворяющих P. Только на этот раз список L будет упорядочен, а из всех повторяющихся элементов, если таковые есть, в него попадет только один. Упорядочение происходит по алфавиту или по отношению '<', если элементы списка — числа. Если элементы списка — структуры, то они упорядочиваются по своим главным функторам. Если же главные функторы совпадают, то решение о порядке таких термов принимается по их первым несовпадающим функторам, расположенным выше и левее других (по дереву). На вид объектов, собираемых в список, ограничения нет. Поэтому можно, например, составить список пар вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Класс / Буква\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 при этом гласные будут расположены в списке первыми ("глас" по алфавиту раньше "согл"):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- setof( Класс/Буква, класс( Буква, Класс), Спис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Спис = [глас/а, глас/e, согл/b, согл/с, согл/d, согл/f]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще одним предикатом этого семейства, аналогичным bagof, является findall.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 findall( X, P, L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тоже порождает список объектов, удовлетворяющих P. Он отличается от bagof тем, что собирает в список \i все\i0   объекты X, не обращая внимание на (возможно) отличающиеся для них конкретизации тех переменных из P, которых нет в X. Это различие видно из следующего примера:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- findall( Буква, класс( Буква, Класс), Буквы).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Буквы = [a, b, c, d, e, f]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если не существует ни одного объекта X, удовлетворяющего P, то findall все равно имеет успех и выдает L = [].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если в используемой реализации Пролога отсутствует встроенный предикат findall, то его легко запрограммировать следующим образом. Все решения для P порождаются искусственно вызываемыми возвратами. Каждое решение, как только оно получено, немедленно добавляется к базе данных, чтобы не потерять его после нахождения следующего решения. После того, как будут получены и сохранены все решения, их нужно собрать в список, а затем удалить из базы данных при помощи retract. Весь процесс можно представлять себе как построение очереди из порождаемых решений. Каждое вновь порождаемое решение добавляется в конец этой очереди при помощи assert. Когда все решения собраны, очередь расформировывается. Заметим также, что конец очереди надо пометить, например, атомом "дно" (который, конечно, должен отличаться от любого ожидаемого решения). Реализация findall в соответствии с описанным методом показана на рис. 7.4.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 findall( X, Цель, ХСпис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  саll( Цель),           % Найти решение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  assert( очередь( X) ), % Добавить егo\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  fail;                  % Попытаться найти еще решения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  assertz( очередь( дно) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Пометить конец решений\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  собрать( ХСпис).       % Собрать решения в список\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( L) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  retract( очередь(X) ), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Удалить следующее решение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( X == дно, !, L = [];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Конец решений?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  L = [X | Остальные], собрать( Остальные) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Иначе собрать остальные\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 7.4.\b0   Реализация отношения findall.\par
\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 7.8.\b0   Используя bagof, определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 множподмножеств( Мн, Подмн)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 для вычисления множества всех подмножеств данного множества (все множества представлены списками).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 7.9.\b0   Используя bagof, определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 копия( Терм, Копия)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 чтобы Копия представляла собой Терм, в котором все переменные переименованы.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В любой реализации Пролога обычно предусматривается набор встроенных процедур для выполнения различных полезных операций, несуществующих в чистом Прологе. В данной главе мы рассмотрели подобное множество предикатов, имеющееся во многих реализациях.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Тип терма можно установить при помощи следующих предикатов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 var( X)     X — (неконкретизированная) переменная\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nonvar( X)  X — не переменная\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 atom( X)    X — атом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 integer( X) X — целое\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 atomic( X)  X — или атом, или целое\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Термы можно синтезировать или разбирать на части:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Терм =.. [Функтор [ СписокАргументов]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 functor( Терм, Функтор, Арность)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 arg( N, Терм, Аргумент)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 name( атом, КодыСимволов)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Программу на Прологе можно рассматривать как реляционную базу данных, которую можно изменять при помощи следующих процедур:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 аssert( Предл)  добавляет предложение Предл к программе\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 аssеrtа( Предл) добавляет в начало\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 assertz( Предл) добавляет в конец\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 rеtrасt( Предл) удаляет предложение, сопоставимое с предложением Предл\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Все объекты, отвечающие некоторому заданному условию, можно собрать в список при помощи предикатов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 bagof( X, P, L)   L — список всех X, удовлетворяющих условию P\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 setof( X, P, L)   L — отсортированный список всех X, удовлетворяющих условию P\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 findall( X, P, L) аналогичен bagof\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • repeat — средство управления, позволяющее порождать неограниченное число альтернатив для автоматического перебора.\par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 8\par
Стиль и методы программирования\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой главе мы рассмотрим некоторые общие принципы хорошего программирования и обсудим, в частности, следующие вопросы: "Как представлять себе прологовские программы? Из каких элементов складывается хороший стиль программирования на Прологе? Как отлаживать пролог-программы? Как повысить их эффективность?"\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 8.1. Общие принципы хорошего программирования\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Главный вопрос, касающийся хорошего программирования, — это вопрос о том, что такое хорошая программа. Ответ на этот вопрос не тривиален, поскольку существуют разные критерии качества программ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следующие критерии общеприняты:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Правильность\i0  . Хорошая программа в первую очередь должна быть правильной, т.е. она должна делать именно то, для чего предназначалась. Это требование может показаться тривиальным и самоочевидным. Однако в случае сложных программ правильность достигается не так часто. Распространенной ошибкой при написании программ является пренебрежение этим очевидным критерием, когда большее внимание уделяется другим критериям — таким, как эффективность.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Эффективность\i0  . Хорошая программа не должна попусту тратить компьютерное время и память.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Простота, читабельность\i0  . Хорошая, программа должна быть легка для чтения и понимания. Она не должна быть более сложной, чем это необходимо. Следует избегать хитроумных программистских трюков, затемняющих смысл программы. Общая организация программы и расположение ее текста должны облегчать ее понимание.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Удобство модификации\i0  . Хорошая программа должна быть легко модифицируема и расширяема. Простота и модульная организация программы облегчают внесение в нее изменений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Живучесть\i0  . Хорошая программа должна быть живучей. Она не должна сразу "ломаться", если пользователь введет в нее неправильные или непредусмотренные данные. В случае подобных ошибок программа должна сохранять работоспособность и вести себя разумно (сообщать об ошибках).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Документированность\i0  . Хорошая программа должна быть хорошо документирована. Минимальная документация — листинг с достаточно подробными комментариями.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Степень важности того или иного критерия зависит от конкретной задачи, от обстоятельств написания программы, а также от условий ее эксплуатации. Наивысшим приоритетом пользуется, без сомнения, правильность. Обычно простоте, удобству модификации, живучести и документированности придают во крайней мере не меньший приоритет, чем эффективности.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует несколько общих соображений, помогающих реализовать вышеупомянутые критерии на практике. Одно важное правило состоит в том, чтобы сначала \i продумать\i0   задачу, подлежащую решению, и лишь затем приступать к написанию текста программы на конкретном языке программирования. Как только мы хорошо поймем задачу, и способ ее решения будет нами полностью и во всех деталях продуман, само программирование окажется быстрым и легким делом и появится неплохой шанс за короткое время получить правильную программу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Распространенной ошибкой является попытка начать писать программу даже до того, как была уяснена полная постановка задачи. Главная причина, по которой следует воздерживаться от преждевременного начала программирования, состоит в том, что обдумывание задачи и поиск метода ее решения должны проводиться в терминах, наиболее адекватных самой этой задаче. Эти термины чаще всего далеки от синтаксиса применяемого языка программирования и могут быть утверждениями на естественном языке и рисунками.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Исходная формулировка способа решения задачи должна быть затем трансформирована в программу, но этот процесс трансформации может оказаться нелегким. Неплохим подходом к его осуществлению является применение принципа \i пошаговой детализации\i0  . Исходная формулировка рассматривается как "решение верхнего уровня", а окончательная программа - как "решение низшего уровня".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В соответствии с принципом пошаговой детализации окончательная программа получается после серии трансформаций или "детализаций" решения. Мы начинаем с первого решения — решения верхнего уровня, а затем последовательно проходим по цепочке решений; все эти решения эквивалентны, но каждое следующее решение выражено более детально, чей предыдущее. На каждом шагу детализации понятия, использовавшиеся в предыдущих формулировках, прорабатываются более подробно, а их представление все более приближается к языку программирования. Следует отдавать себе отчет в том, что детализация касается не только процедур, но и структур данных. На начальных шагах работают обычно с более абстрактными, более крупными информационными единицами, детальная структура которых уточняется впоследствии.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Стратегия нисходящей пошаговой детализации имеет следующие преимущества:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • она позволяет сформулировать грубое решение в терминах, наиболее адекватных решаемой задаче;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • в терминах таких мощных понятий решение будет сжатым и простым, а потому скорее всего правильным;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • каждый шаг детализации должен быть достаточно малым, чтобы не представлять больших интеллектуальных трудностей, если это удалось — трансформация решения в новое, более детальное представление скорее всего будет выполнена правильно, а следовательно, таким же правильным окажется и полученное решение следующего шага детализации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В случае Пролога мы можем говорить о пошаговой детализации \i отношений\i0  . Если существо задачи требует мышления в алгоритмических терминах, то мы можем также говорить и о детализации \i алгоритмов\i0  , приняв процедурную точку зрения на Пролог.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы удачно сформулировать решение на некотором уровне детализации и придумать полезные понятия для следующего, более низкого уровня, нужны идеи. Поэтому программирование — это творческий процесс, что верно в особенности, когда речь идет о начинающих программистах. По мере накопления опыта работа программиста постепенно становится все менее искусством и все более ремеслом. И все же главным остается вопрос: как возникают идеи? Большинство идей приходит из опыта, из тех задач, решения которых уже известны. Если мы не знаем прямого решения задачи, то нам может помочь уже решенная задача, похожая на нашу. Другим источником идей является повседневная жизнь. Например, если необходимо запрограммировать сортировку списка, то можно догадаться, как это сделать, если задать себе вопрос: "А как бы я сам стал действовать, чтобы расположить экзаменационные листы студентов по их фамилиям в алфавитном порядке?"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Общие принципы, изложенные в данном разделе, известны также как составные части "структурного программирования"; они, в основном, применимы и к программированию на Прологе. В следующих разделах мы обсудим их более детально, обращая особое внимание на применение этих принципов программирования к Прологу.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 8.2. Как представлять себе программы на Прологе\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одной из характерных особенностей Пролога является то, что в нем допускается как процедурный, так и декларативный стиль мышления при составлении программы. Эти два подхода детально обсуждались в гл. 2 и затем многократно иллюстрировались на примерах. Какой из этих подходов окажется более эффективным и практичным, зависит от конкретной задачи. Обычно построение декларативного решения задачи требует меньших усилий, но может привести к неэффективной программе. В процессе построения решения мы должны сводить задачу к одной или нескольким более легким подзадачам. Возникает важный вопрос: как находить эти подзадачи? Существует несколько общих принципов, которые часто применяются при программировании на Прологе. Они будут обсуждаться в следующих разделах.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 8.2.1. Использование рекурсии\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот принцип состоит в том, чтобы разбить задачу на случаи, относящиеся к двум группам:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) тривиальные, или "граничные" случаи;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) "общие" случаи, в которых решение получается из решений для (более простых) вариантов самой исходной задачи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот метод мы использовали в Прологе постоянно. Рассмотрим еще один пример: обработка списка элементов, при которой каждый элемент преобразуется по одному и тому же правилу. Пусть это будет процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобрспис( Спис, F, НовСпиc)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Спис — исходный список, F — правило преобразования (бинарное отношение), а НовСпиc — список всех преобразованных элементов. Задачу преобразования списка Спис можно разбить на два случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Граничный случай: Спис = []\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если Спис = [], то НовСпиc = [], независимо от F\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Общий случай: Спис = [X | Хвост]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Чтобы преобразовать список вида [X | Хвост], необходимо:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   преобразовать список Хвост; результат — НовХвост;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   элемент X по правилу F; результат — НовХ;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   результат преобразования всего списка — [НовХ | НовХвост].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тот же алгоритм, изложенный на Прологе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобрспис( [], _, []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобрспис( [X | Хвост], F, [НовХ | НовХвост] :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  G =.. [F, X, НовХ],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  саll( G),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  пpeoбpcпиc( Хвост, F, НовХвост).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Одна из причин того, что рекурсия так естественна для определения отношений на Прологе, состоит в том, что объекты данных часто сами имеют рекурсивную структуру. К таким объектам относятся списки и деревья. Список либо пуст (граничный случай), либо имеет голову и хвост, который сам является списком (общий случай). Двоичное дерево либо пусто (граничный случай), либо у него есть корень и два поддерева, которые сами являются двоичными деревьями (общий случай). Поэтому для обработки всего непустого дерева необходимо сначала что-то сделать с его корнем, а затем обработать поддеревья.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 8.2.2. Обобщение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Часто бывает полезно обобщить исходную задачу таким образом, чтобы полученная более общая задача допускала рекурсивную формулировку. Исходная задача решается, тогда как частный случай ее более общего варианта. Обобщение отношения обычно требует введения одного или более дополнительных аргументов. Главная проблема состоит в отыскании подходящего обобщения, что может потребовать более тщательного изучения задачи. В качестве примера рассмотрим еще раз задачу о восьми ферзях. Исходная задача состояла в следующем: разместить на доске восемь ферзей так, чтобы обеспечить отсутствие взаимных нападений. Соответствующее отношение назовем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 восемьферзей( Поз)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оно выполняется (истинно), если Поз — представленная тем или иным способом позиция, удовлетворяющая условию задачи. Можно предложить следующую полезную идею: обобщить задачу, перейдя от 8 ферзей к произвольному количеству — N. Количество ферзей станет дополнительным аргументом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 n_ферзей( Поз, N)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Преимущество такого обобщения состоит в том, что отношение n_ферзей допускает непосредственную рекурсивную формулировку:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Граничный случай: N = 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Разместить 0 ферзей — тривиальная задача.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Общий случай: N > 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для "безопасного" размещения N ферзей необходимо:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • получить требуемое размещение для (N - 1) ферзей и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • добавить оставшегося ферзя так, чтобы он не бил ни одного из уже поставленных ферзей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как только мы научимся решать более общую задачу, решить исходную уже не составит труда:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 восемьферзей( Поз) :- n_ферзей( Поз, 8)\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 8.2.3. Использование рисунков\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В поиске идей для решения задачи часто бывает полезным обратиться к ее графическому представлению. Рисунок может помочь выявить в задаче некоторые существенные отношения. После этого останется только описать на языке программирования то, что мы \i видим\i0   на рисунке.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Использование графического представления при решении задач полезно всегда, однако похоже, что в Прологе оно работает особенно хорошо. Происходит это по следующим причинам:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Пролог особенно хорошо приспособлен для задач, в которых фигурируют объекты и отношения между ними. Часто такие задачи естественно иллюстрировать графами, в которых узлы соответствуют объектам, а дуги — отношениям.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Естественным наглядным изображением структурных объектов Пролога являются деревья.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Декларативный характер пролог-программ облегчает перевод графического представления на Пролог. В принципе, порядок описания "картинки" не играет роли, мы просто помещаем в программу то, что видим, в произвольном порядке. (Возможно, что из практических соображений этот порядок впоследствии придется подправить с целью повысить эффективность программы.) \par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 8.3. Стиль программирования\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подчиняться при программировании некоторым стилистическим соглашениям нужно для того, чтобы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • уменьшить опасность внесения ошибок в программы и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • создавать программы, которые легко читать, понимать, отлаживать и модифицировать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ниже дается обзор некоторых из составных частей хорошего стиля программирования на Прологе. Мы рассмотрим некоторые общие правила хорошего стиля, табличную организацию длинных процедур и вопросы комментирования программ.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 8.3.1. Некоторые правила хорошего стиля\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Предложения программы должны быть короткими. Их тела, как правило, должны содержать только несколько целей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Процедуры должны быть короткими, поскольку длинные процедуры трудны для понимания. Тем не менее длинные процедуры вполне допустимы в том случае, когда они имеют регулярную структуру (этот вопрос еще будет обсуждаться в данной главе).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Следует применять мнемонические имена процедур и переменных. Они должны отражать смысл отношений и роль объектов данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Существенное значение имеет расположение текста программы. Для улучшения читабельности программы нужно постоянно применять пробелы, пустые строки и отступы. Предложения, относящиеся к одной процедуре, следует размещать вместе в виде отдельной группы строк; между предложениями нужно вставлять пустую строку (этого не нужно делать, возможно, только в случае перечисления большого количества фактов, касающихся одного отношения); каждую цель можно размещать на отдельной строке. Пролог-программы иной раз напоминают стихи по эстетической привлекательности своих идей и формы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Стилистические соглашения такого рода могут варьироваться от программы к программе, так как они зависят от задачи и от личного вкуса. Важно, однако, чтобы на протяжении одной программы постоянно применялись одни и те же соглашения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Оператор отсечения следует применять с осторожностью. Если легко можно обойтись без него — не пользуйтесь им. Всегда, когда это возможно, предпочтение следует отдавать "зеленым отсечениям" перед "красными". Как говорилось в гл. 5, отсечение называется "зеленым", если его можно убрать, на затрагивая декларативный смысл предложения. Использование "красных отсечений" должно ограничиваться четко определенными конструкциями, такими как оператор not или конструкция выбора между альтернативами. Примером последней может служить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i если\i0  Условие\i то\i0  Цель1\i иначе\i0  Цель2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С использованием отсечения эта конструкция переводится на Пролог так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Условие, !. % Условие выполнено?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель1;      % Если да, то Цель1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель2       % Иначе - Цель2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Из-за того, что оператор not связан с отсечением, он тоже может привести к неожиданностям. Поэтому, применяя его, следует всегда помнить точное прологовское определение этого оператора. Тем не менее, если приходится выбирать между not и отсечением, то лучше использовать not, чем какую-нибудь туманную конструкцию с отсечением.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Внесение изменений в программу при помощи assert и retract может сделать поведение программы значительно менее понятным. В частности, одна и та же программа на одни и те же вопросы будет отвечать по-разному в разные моменты времени. В таких случаях, если мы захотим повторно воспроизвести исходное поведение программы, нам придется предварительно убедиться в том, что ее исходное состояние, нарушенное при обращении к assert и retract, полностью восстановлено.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Применение точек с запятой может затемнять смысл предложений. Читабельность можно иногда улучшить, разбивая предложения, содержащие точки с запятой, на несколько новых предложений, однако за это, возможно, придется заплатить увеличенном длины программы и потерей в ее эффективности.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для иллюстрации некоторых положений данного раздела рассмотрим отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 слить( Спис1, Спис2, Спис3)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Спис1 и Спис2 — упорядоченные списки, а Спис3 — результат их слияния (тоже упорядоченный). Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 слить( [2, 4, 7], [1, 3, 4, 8], [1, 2, 3, 4, 4, 7, 8] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот стилистически неудачная реализация этого отношения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 слить( Спис1, Спис2, Спис3) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Спис1 = [], !, Спис3 = Спис2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Первый список пуст\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Спис2 = [], !,  Спис3 = Спис1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Второй список пуст\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Спис1 = [X | Остальные],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Спис2 = [Y | Остальные],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( X < Y, !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Z = X, % Z - голова Спис3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  слить( Остальные1, Спис2, Остальные3 );\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Z = Y,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  слить( Спис1, Остальные2, Остальные3 ) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Спис3 = [Z | Остальные3].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот более предпочтительный вариант, не использующий точек с запятой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 слить( [], Спис, Спис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 слить( Спис, [], Спис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 слить( [X | Остальные1], [Y | Остальные2], [X | Остальные3] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X < Y, !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  слить(Остальные1, [Y | Остальные2], Остальные3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 слить( Спис1, [Y | Остальные2], [Y | Остальные3]): -\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  слить( Спис1, Остальные2, Остальные3 ).\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 8.3.2. Табличная организация длинных процедур\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Длинные процедуры допустимы, если они имеют регулярную структуру. Обычно эта структура представляет собой множество фактов, соответствующее определению какого-либо отношения в табличной форме. Преимущества такой организации длинной процедуры состоят в том, что:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Ее структуру легко понять.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Ее удобно совершенствовать: улучшать ее можно, просто добавляя новые факты.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Ее легко проверять и модифицировать (просто заменяя отдельные факты, независимо от остальных). \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 8.3.3. Комментирование\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программные комментарии должны объяснять в первую очередь, для чего программа предназначена и как ею пользоваться, и только затем — подробности используемого метода решения и другие программные детали. Главная цель комментариев — обеспечить пользователю возможность применять программу, понимать ее и, может быть, модифицировать. Комментарии должны содержать в наиболее краткой форме всю необходимую для этого информацию. Недостаточное комментирование — распространенная ошибка, однако, программу можно и перенасытить комментариями. Объяснения деталей, которые и так ясны из самого текста программы, являются ненужной перегрузкой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Длинные фрагменты комментариев следует располагать перед текстом, к которому они относятся, в то время как короткие комментарии должны быть вкраплены в сам текст. Информация, которую в самом общем случае следует включать в комментарии, должна схватывать следующие вопросы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Что программа делает, как ею пользоваться (например, какую цель следует активизировать и каков вид ожидаемых результатов), примеры ее применения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Какие предикаты относятся к верхнему уровню?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Как представлены основные понятия (объекты)?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Время выполнения и требования по объему памяти.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Каковы ограничения на программу?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Использует ли она какие-либо средства, связанные с конкретной операционной системой?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Каков смысл предикатов программы? Каковы их аргументы? Какие аргументы являются "входными" и какие — "выходными", если это известно? (В момент запуска предиката входные аргументы имеют полностью определенные значения, не содержащие не конкретизированных переменных.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Алгоритмические и реализационные детали.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 8.4. Отладка\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда программа не делает того, чего от нее ждут, главной проблемой становится отыскание ошибки (или ошибок). Всегда легче найти ошибку в какой-нибудь части программы (или в отдельном модуле), чем во всей программе. Поэтому следует придерживаться следующего хорошего принципа: проверять сначала более мелкие программные единицы и только после того, как вы убедились, что им можно доверять, начинать проверку большего модуля или всей программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отладка в Прологе облегчается двумя обстоятельствами: во-первых, Пролог — интерактивный язык, поэтому можно непосредственно обратиться к любой части программы, задав пролог-системе соответствующий вопрос; во-вторых, в реализациях Пролога обычно имеются специальные средства отладки. Следствием этих двух обстоятельств является то, что отладка программ на Прологе может производиться, вообще говоря, значительно эффективнее, чем в других языках программирования.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основным средством отладки является \i трассировка\i0   (tracing). "Трассировать цель" означает: предоставить пользователю информацию, относящуюся к достижению этой цели в процессе ее обработки пролог-системой. Эта информация включает:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Входную информацию — имя предиката и значении аргументов в момент активизации цели.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Выходную информацию — в случае успеха, значения аргументов, удовлетворяющих цели; в противном случае — сообщение о неуспехе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Информацию о повторном входе, т.е. об активизации той же цели в результате автоматического возврата.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В промежутке между входом и выходом можно получить трассировочную информацию для всех подцелей этой цели. Таким образом, мы можем следить за обработкой нашего вопроса на всем протяжении нисходящего пути от исходной цели к целям самого нижнего уровня, вплоть до отдельных фактов. Такая детальная трассировка может оказаться непрактичной из-за непомерно большого количества трассировочной информации. Поэтому пользователь может применить "селективную" трассировку. Существуют два механизма селекции: первый подавляет выдачу информации о целях, расположенных ниже некоторого уровня; второй трассирует не все предикаты, а только некоторые, указанные пользователем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Средства отладки приводятся в действие при помощи системно-зависимых встроенных предикатов. Обычно используется следующий стандартный набор таких предикатов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 trace\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 запускает полную трассировку всех целей, следующих за trace.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 notrace\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прекращает дальнейшее трассирование.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 spy( P) (следи за P)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 устанавливает режим трассировки предиката P. Обращение к spy применяют, когда хотят получить информацию только об указанном предикате и избежать трассировочной информации от других целей (как выше, так и ниже уровня запуска P). "Следить" можно сразу за несколькими предикатами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 nospy( P)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прекращает "слежку" за P.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Трассировка ниже определенной глубины может быть подавлена во время выполнения программы при помощи специальных команд. Существуют и другие команды отладки, такие как возврат к предыдущей точке процесса вычислений. После такого возврата можно, например, повторить вычисления с большей степенью детализации трассировки.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 8.5. Эффективность\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует несколько аспектов эффективности программ, включая такие наиболее общие, как время выполнения и требования по объему памяти. Другим аспектом является время, необходимое программисту для разработки программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Традиционная архитектура вычислительных машин не очень хорошо приспособлена для реализации прологовского способа выполнения программ, предусматривающего достижение целей из некоторого списка. Поэтому ограниченность ресурсов по времени и пространству сказывается в Прологе, пожалуй, в большей степени, чем в большинстве других языков программирования. Вызовет ли это трудности в практических приложениях, зависит от задачи. Фактор времени практически не имеет значения, если пролог-программа, которую запускают по несколько раз в день, занимает 1 секунду процессорного времени, а соответствующая программа на каком-либо другом языке, скажем на Фортране, — 0.1 секунды. Разница в эффективности становится существенной, если эти две программы требуют 50 и 5 минут соответственно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С другой стороны, во многих областях применения Пролога он может существенно сократить время разработки программ. Программы на Прологе, вообще говоря, легче писать, легче понимать и отлаживать, чем программы, написанные на традиционных языках. Задачи, тяготеющие к "царству Пролога", включают в себя обработку символьной, нечисловой информации, структурированных объектов данных и отношений между ними. Пролог успешно применяется, в частности. в таких областях, как символьное решение уравнений, планирование, базы данных, автоматическое решение задач, машинное макетирование, реализация языков программирования, дискретное и аналоговое моделирование, архитектурное проектирование, машинное обучение, понимание естественного языка, экспертные системы и другие задачи искусственного интеллекта. С другой стороны, применение Пролога в области вычислительной математики вряд ли можно считать естественным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прогон \i откомпилированной\i0   программы обычно имеет большую эффективность, чем \i интерпретация\i0  . Поэтому, если пролог-система содержит как интерпретатор, так и компилятор, следует пользоваться компилятором, если время выполнения критично.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если программа страдает неэффективностью, то ее обычно можно кардинально улучшить, изменив сам алгоритм. Однако для того, чтобы это сделать, необходимо изучить процедурные аспекты программы. Простой способ сокращения времени выполнения состоит в нахождении более удачного порядка предложений в процедуре и целей — в телах процедур. Другой, относительно простой метод заключается в управлении действиями системы посредством отсечений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Полезные идеи, относящиеся к повышению эффективности, обычно возникают только при достижении более глубокого понимания задачи. Более эффективный алгоритм может, вообще говоря, привести к улучшениям двух видов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Повышение эффективности поиска путем скорейшего отказа от ненужного перебора и от вычисления бесполезных вариантов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Применение cтруктур данных, более приспособленных для представления объектов программы, с целью реализовать операции над ними более эффективно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы изучим оба вида улучшений на примерах. Кроме того, мы рассмотрим на примере еще один метод повышения эффективности. Этот метод основан на добавлении в базу данных тех промежуточных результатов, которые с большой вероятностью могут потребоваться для дальнейших вычислений. Вместо того, чтобы вычислять их снова, программа просто отыщет их в базе данных как уже известные факты.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 8.5.1. Повышение эффективности решения задачи о восьми ферзях\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве простого примера повышения эффективности давайте вернемся к задаче о восьми ферзях (см. рис. 4.7). В этой программе Y-координаты ферзей перебираются последовательно — для каждого ферзя пробуются числа от 1 до 8. Этот процесс был запрограммирован в виде цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( Y, [1, 2, 3, 4, 5, 6, 7, 8] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура принадлежит работает так: вначале пробует Y = 1, затем Y = 2, Y = 3 и т.д. Поскольку ферзи расположены один за другим в смежных вертикалях доски, очевидно, что такой порядок перебора не является оптимальным. Дело в том, что ферзи, расположенные в смежных вертикалях будут бить друг друга, если они не будут разнесены по вертикали на расстояние, превышающее, по крайней мере одно поле. В соответствии с этим наблюдением можно попытаться повысить эффективность, просто изменив порядок рассмотрения координат-кандидатов. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( Y, [1, 5, 2, 6, 3, 7, 4, 8] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это маленькое изменение уменьшит время, необходимое для нахождения первого решения, в 3-4 раза.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В следующем примере такая же простая идея, связанная с изменением порядка, превращает практически неприемлемую временную сложность в тривиальную.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 8.5.2. Повышение эффективности программы раскраски карты\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задача раскраски карты состоит в приписывании каждой стране на заданной карте одного из четырех заданных цветов с таким расчетом, чтобы ни одна пара соседних стран не была окрашена в одинаковый цвет. Существует теорема, которая гарантирует, что это всегда возможно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пусть карта задана отношением соседства\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соседи( Страна, Соседи)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Соседи — список стран, граничащих со страной Страна. При помощи этого отношения карта Европы с 20-ю странами будет представлена (в алфавитном порядке) так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соседи( австрия, [венгрия, запгермания, италия,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  лихтенштейн, чехословакия,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  швейцария, югославия]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соседи( албания, [греция, югославия]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соседи( андорра, [испания, франция]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решение представим в виде списка пар вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Страна / Цвет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которые устанавливают цвет для каждой страны на данной карте. Для каждой карты названия стран всегда известны заранее, так что задача состоит в нахождении цветов. Таким образом, для Европы задача сводится к отысканию подходящей конкретизации переменных C1, C2, СЗ и т.д. в списке\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [австрия/C1, албания/C2, андорра/С3, ...]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь определим предикат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 цвета( СписЦветСтран)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 который истинен, если СписЦветСтран удовлетворяет тем ограничениям, которые наложены на раскраску отношением соседи. Пусть четырьмя цветами будут желтый, синий, красный и зеленый. Условие запрета раскраски соседних стран в одинаковый цвет можно сформулировать на Прологе так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 цвета( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 цвета( [Страна/Цвет | Остальные] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цвета( Остальные),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Цвет, [желтый, синий, красный, зеленый]),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not( принадлежит( Страна1/Цвет, Остальные),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сосед( Страна, Страна1) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сосед( Страна, Страна1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  соседи( Страна, Соседи),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Страна1, Соседи).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь принадлежит( X, L) — как всегда, отношение принадлежности к списку. Для простых карт с небольшим числом стран такая программа будет работать. Что же касается Европы, то здесь результат проблематичен. Если считать, что мы располагаем встроенным предикатом setof, то можно попытаться раскрасить карту Европы следующим образом. Определим сначала вспомогательное отношение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 страна( С) :- соседи( С, _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда вопрос для раскраски карты Европы можно сформулировать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- sеtоf( Стр/Цвет, страна( Стр), СписЦветСтран),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цвета( СписЦветСтран).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель setof — построить "шаблон" списка СписЦветСтран, в котором в элементах вида страна/ цвет вместо цветов будут стоять неконкретизированные переменные. Предполагается, что после этого цель цвета конкретизирует их. Такая попытка скорее всего потерпит неудачу вследствие неэффективности работы программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тщательное исследование способа, при помощи которого пролог-система пытается достичь цели цвета, обнаруживает источник неэффективности. Страны расположены в списке в алфавитном порядке, а он не имеет никакого отношения к их географическим связям. Порядок, в котором странам приписываются цвета, соответствует порядку их расположения в списке (с конца к началу), что в нашем случае никак не связано с отношением соседи. Поэтому процесс раскраски начинается в одном конце карты, продолжается в другой и т.д., перемещаясь по ней более или менее случайно. Это легко может привести к ситуации, когда при попытке раскрасить очередную страну окажется, что она окружена странами, уже раскрашенными во все четыре доступных цвета. Подобные ситуации приводят к возвратам, снижающим эффективность.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ясно поэтому, что эффективность зависит от порядка раскраски стран. Интуиция подсказывает простую стратегию раскраски, которая должна быть лучше, чем случайная: начать со страны, имеющей иного соседей, затем перейти к ее соседям, затем — к соседям соседей и т.д. В случае Европы хорошим кандидатом для начальной страны является Западная Германия (как имеющая наибольшее количество соседей — 9). Понятно, что при построении шаблона списка элементов вида страна/цвет Западную Германию следует поместить в конец этого списка, а остальные страны - добавлять со стороны его начала. Таким образом, алгоритм раскраски, который начинает работу с конца списка, в начале займется Западной Германией и продолжит работу, переходя от соседа к соседу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Новый способ упорядочивания списка стран резко повышает эффективность по отношению к исходному, алфавитному порядку, и теперь возможные раскраски карты Европы будут получены без труда.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно было бы построить такой правильно упорядоченный список стран вручную, но в этом нет необходимости. Эту работу выполнит процедура создспис. Она начинает построение с некоторой указанной страны (в нашем случае — с Западной Германии) и собирает затем остальные страны в список под названием Закрытый. Каждая страна сначала попадает в другой список, названный Открытый, а потом переносится в Закрытый. Всякий раз, когда страна переносится из Открытый в Закрытый, ее соседи добавляются в Открытый.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 создспис( Спис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  собрать( [запгермания], [], Спис ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( [], Закрытый, Закрытый).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Кандидатов в Закрытый больше нет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( [X | Открытый], Закрытый, Спис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X | Закрытый), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % X уже собран ?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  собрaть( Открытый, Закрытый, Спис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Отказаться от X\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( [X | Открытый], Закрытый, Спис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  соседи( X, Соседи),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Найти соседей X\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Соседи, Открытый, Открытый1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Поместить их в Открытый\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  собрать( Открытый1, [X | Закрытый], Спис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Собрать остальные\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношение конк — как всегда — отношение конкатенации списков.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 8.5.3. Повышение эффективности конкатенации списков за счет совершенствования структуры данных\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 До сих пор в наших программах конкатенация была определена так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [], L, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [X | L1], L2, [X | L3] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( L1, L2, L3 ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта процедура неэффективна, если первый список — длинный. Следующий пример объясняет, почему это так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- конк( [а, b, с], [d, e], L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот вопрос порождает следующую последовательность целей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [а, b, с], [d, e], L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( [b, с], [d, e], L') где L = [a | L']\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   конк( [с], [d, e], L'')   где L' = [b | L''']\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    конк( [], [d, e], L''')   где L'' = [c | L''']\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     true  (истина) где L''' = [d, e]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ясно, что программа фактически сканирует весь первый список, пока не обнаружит его конец.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А нельзя ли было бы проскочить весь первый список за один шаг и сразу подсоединить к нему второй список, вместо того, чтобы постепенно продвигаться вдоль него? Но для этого необходимо знать, где расположен конец списка, а следовательно, мы нуждаемся в другом его представлении. Один из вариантов — представлять список парой списков. Например, список\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [а, b, с]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно представить следующими двумя списками:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L1 = [a, b, c, d, e]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L2 = [d, e]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подобная пара списков, записанная для краткости как L1-L2, представляет собой "разность" между L1 и L2. Это представление работает только при том условии, что L2 — "конечный участок" списка L1. Заметим, что один и тот же список может быть представлен несколькими "разностными парами". Поэтому список [а, b, с] можно представить как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [а, b, с]-[]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [a, b, c, d, e]-[d, e]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [a, b, c, d, e | T]-[d, e | T]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [а, b, с | T]-T\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где T — произвольный список, и т.п. Пустой список представляется любой парой L-L.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поскольку второй член пары указывает на конец списка, этот конец доступен сразу. Это можно использовать для эффективной реализации конкатенации. Метод показан на рис. 8.1. Соответствующее отношение конкатенации записывается на Прологе в виде факта\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конкат( A1-Z1, Z1-Z2, A1-Z2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте используем конкат для конкатенации двух списков: списка [а, b, с], представленного парой [а, b, с | Т1]-Т1, и списка [d, e], представленного парой [d, e | Т2]-Т2:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- конкат( [а, b, с | Т1]-T1, [d, e | Т2]-Т2, L ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оказывается, что для выполнения конкатенации достаточно простого сопоставления этой цели с предложением конкат. Результат сопоставления:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 T1 = [d, e | Т2]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [a, b, c, d, e | T2]-T2\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 8.1.\b0   Конкатенация списков, представленных в виде разностных пар. L1 представляется как A1-Z1, L2 как A2-Z2 и результат L3 — как A1-Z2. При этом должно выполняться равенство Z1 = А2.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 8.5.4. Повышение эффективности зa счет добавления вычисленных фактов к базе данных\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иногда в процессе вычислений приходится одну и ту же цель достигать снова и снова. Поскольку в Прологе отсутствует специальный механизм выявления этой ситуации, соответствующая цепочка вычислений каждый раз повторяется заново.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве примера рассмотрим программу вычисления N-го числа Фибоначчи для некоторого заданного N. Последовательность Фибоначчи имеет вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1, 1, 2, 3, 5, 8, 13, …\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждый член последовательности, за исключением первых двух, представляет собой сумму предыдущих двух членов. Для вычисления N-гo числа Фибоначчи F определим предикат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фиб( N, F)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нумерацию чисел последовательности начнем с N = 1. Программа для фиб обрабатывает сначала первые два числа Фибоначчи как два особых случая, а затем определяет общее правило построения последовательности Фибоначчи:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фиб( 1, 1).    % 1-e число Фибоначчи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фиб( 2, 1).    % 2-e число Фибоначчи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фиб( N, F) :-  % N-e число Фиб., N > 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N > 2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N1 is N - 1, фиб( N1, F1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N2 is N - 2, фиб( N2, F2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  F is F1 + F2. % N-e число есть сумма двух\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                % предыдущих\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура фиб имеет тенденцию к повторению вычислений. Это легко увидеть, если трассировать цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- фиб( 6, F).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 8.2 показано, как протекает этот вычислительный процесс. Например, третье число Фибоначчи f( 3) понадобилось в трех местах, и были повторены три раза одни и те же вычисления.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этого легко избежать, если запоминать каждое вновь вычисленное число. Идея состоит в применении встроенной процедуры assert для добавления этих (промежуточных) результатов в базу данных в виде фактов. Эти факты должны предшествовать другим предложениям, чтобы предотвратить применение общего правила в случаях, для которых результат уже известен. Усовершенствованная процедура фиб2 отличается от фиб только этим добавлением:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фиб2( 1, 1).            % 1-e число Фибоначчи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фиб2( 2, 1).            % 2-e число Фибоначчи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фиб2( N, F) :-          % N-e число Фиб., N > 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N > 2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N1 is N - 1, фиб2( N1, F1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N2 is N - 2, фиб2( N2, F2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  F is F1 + F2,           % N-e число есть сумма\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                          % двух предыдущих\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  asserta( фиб2( N, F) ). % Запоминание N-го числа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта программа, при попытке достичь какую-либо цель, будет смотреть сперва на накопленные об этом отношении факты и только после этого применять общее правило. В результате, после вычисления цели фиб2( N, F), все числа Фибоначчи вплоть до N-го будут сохранены. На рис. 8.3 показан процесс вычислении 6-го числа при помощи фиб2. Сравнение этого рисунка с рис. 8.2. показывает, на сколько уменьшилась вычислительная сложность. Для больших N такое уменьшение еще более ощутимо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Запоминание промежуточных результатов — стандартный метод, позволяющий избегать повторных вычислений. Следует, однако, заметить, что в случае чисел Фибоначчи повторных вычислений можно избежать еще и применением другого алгоритма, а не только запоминанием промежуточных результатов.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 8.2.\b0    Вычисление 6-го числа Фибоначчи процедурой фиб.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 8.3.\b0   Вычисление 6-го числа Фибоначчи при помощи процедуры фиб2, которая запоминает предыдущие результаты. По сравнению с процедурой фиб здесь вычислений меньше (см. рис. 8.2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот новый алгоритм позволяет создать программу более трудную для понимания, зато более эффективную. Идея состоит на этот раз не в том, чтобы определить N-e число Фибоначчи просто как сумму своих предшественников по последовательности, оставляя рекурсивным вызовам организовать вычисления "сверху вниз" вплоть до самых первых двух чисел. Вместо этого можно работать "снизу вверх": начать с первых двух чисел и продвигаться вперед, вычисляя члены последовательности один за другим. Остановиться нужно в тот момент, когда будет достигнуто N-e число. Большая часть работы в такой программе выполняется процедурой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фибвперед( М, N, F1, F2, F)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь F1 и F2 — (М – 1)-e и М-e числа, а F — N-e число Фибоначчи. Рис. 8.4 помогает понять отношение фибвперед. В соответствии с этим рисунком фибвперед находит последовательность преобразований для достижения конечной конфигурации (в которой М = N) из некоторой заданной начальной конфигурации. При запуске фибвперед все его аргументы, кроме F, должны быть конкретизированы, а М должно быть меньше или равно N. Вот эта программа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фиб3( N, F) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  фибвперед( 2, N, 1, 1, F).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Первые два числа Фиб. равны 1\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фибвперед( М, N, F1, F2, F2) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  М >= N. % N-e число достигнуто\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 фибвперед( M, N, F1, F2, F) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  M < N,  % N-e число еще не достигнуто\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  СледМ is М + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  СледF2 is F1 + F2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  фибвперед( СледМ, N, F2, СледF2, F).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 8.4.\b0   Отношения в последовательности Фибоначчи. "Конфигурация" изображается здесь в виде большого круга и определяется тремя параметрами: индексом М и двумя последовательными числами f( M-1) и f( М).\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 8.1.\b0   Все показанные ниже процедуры подсп1, подсп2 и подсп3 реализуют отношение взятия подсписка. Отношение подсп1 имеет в значительной мере процедурное определение, тогда как подсп2 и подсп3 написаны в декларативном стиле. Изучите поведение этих процедур на примерах нескольких списков, обращая внимание на эффективность работы. Две из них ведут себя одинаково и имеют одинаковую эффективность. Какие? Почему оставшаяся процедура менее эффективна?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подсп1( Спис, Подспис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  начало( Спис, Подспис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подсп1( [ _ | Хвост], Подспис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Подспис - подсписок хвоста\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  подсп1( Хвост, Подспис).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 начало( _, []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 начало( [X | Спис1], [X | Спис2] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  начало( Спис1, Спис2).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подсп2( Спис, Подспис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Спис1, Спис2, Спис),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Спис3, Подспис, Cпис1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подсп3( Спис, Подспис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Спис1, Спис2, Спис),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Подспис, _, Спис2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 8.2.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить_в_конец( Список, Элемент, НовыйСписок)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавляющее Элемент в конец списка Список; результат — НовыйСписок. Оба списка представляйте разностными парами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 8.3.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обратить( Список, ОбращенныйСписок)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где оба списка представлены разностными парами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 8.4.\b0   Перепишите процедуру собрать из разд. 8.5.2, используя разностное представление списков, чтобы конкатенация выполнялась эффективнее.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Для оценки качества программы существует несколько критериев: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   правильность\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   эффективность\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   простота, читабельность\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   удобство модификации\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   документированность\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Принцип \i пошаговой детализации\i0   — хороший способ организации процесса разработки программ. Пошаговая детализация применима к отношениям, алгоритмам и структурам данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Следующие методы часто помогают находить идеи для совершенствования программ на Прологе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \i Применение рекурсии\i0  : выявить граничные и общие случаи рекурсивного определения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \i Обобщение\i0  : рассмотреть такую более общую задачу, которую проще решить, чем исходную.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \i Использование рисунков\i0  : графическое представление помогает в выявлении важных отношений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Полезно следовать некоторым стилистическим соглашениям для уменьшения опасности внесения ошибок в программы и создания программ, легких для чтения, отладки и модификации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В пролог-системах обычно имеются средства отладки. Наиболее полезными являются средства трассировки программ.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Существует много способов повышения эффективности программы. Наиболее простые способы включают в себя:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   изменение порядка целей и предложений\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   управляемый перебор при помощи введения отсечений\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   запоминание (с помощью assert) решений, которые иначе пришлось бы перевычислять\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Более тонкие и радикальные методы связаны с улучшением алгоритмов (особенно, в части повышения эффективности перебора) и с совершенствованием структур данных. \par
\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Часть 2\par
Пролог в искусственном интеллекте\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\qc\par\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 9\par
Операции над структурами данных\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Один из фундаментальных вопросов программирования — это вопрос о представлении сложных объектов (таких как, например, множества), а также вопрос об эффективной реализации операций над подобными объектами. В этой главе мы рассмотрим несколько часто используемых структур данных, принадлежащих к трем большим семействам: спискам, деревьям и графам. Мы изучим способы представления этих структур на Прологе и составим программы, реализующие некоторые операции над ними, в том числе, сортировку списков, работу с множествами как древовидными структурами, запись элементов данных в дерево, поиск данных в дереве, нахождение пути в графе и т.п. Мы подробно разберем несколько примеров, чрезвычайно поучительных с точки зрения программирования на Прологе.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 9.1. Представление списков. Сортировка\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 9.1.1. Замечания в некоторых альтернативных способах представления списков\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В главе 3 была введена специальная система обозначений для списков (специальная прологовская нотация), которую мы и использовали в последующем изложении. Разумеется, это был всего лишь один из способов представления списков на Прологе. \i Список\i0   — это, в самом общем смысле, структура, которая либо\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i пуста\i0  , либо\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • состоит из \i головы\i0   и \i хвоста\i0  , причем хвост должен быть сам списком.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поэтому для представления этой структуры нам необходимо иметь всего лишь два языковых средства: специальный символ, обозначающий пустой список, и функтор для соединения головы с хвостом. Мы могли бы, например, выбрать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ничего_не_делать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 в качестве символа, обозначающего пустой список, и атом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 затем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 в качестве инфиксного оператора для построения списка по заданным голове и хвосту. Этот оператор мы можем объявить в программе, например, так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 500, xfy, затем).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ войти, сесть, поужинать]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно было бы тогда записать как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 войти затем сесть затем поужинать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  затем ничего_не_делать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Важно заметить, что на соответствующем уровне абстракции специальная прологовская нотация и всевозможные альтернативные способы обозначения списков сводятся, фактически, к одному и тому же представлению. В связи с этим типовые операции над списками, такие как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит ( X, L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( L1, L2, L3)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( X, L1, L2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 запрограммированные нами в специальной прологовской нотации, легко поддаются перепрограммированию в различные системы обозначений, выбранные пользователем. Например, отношение конк транслируется на язык "затем — ничего_не_делать" следующим образом. Определение, которое мы использовали до сих пор, имеет вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [], L, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [X | L1], L2, [X | L3] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( L1, L2, L3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В новой системе обозначений оно превращается в\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( ничего_не_делать, L, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( X затем L1, L2, X затем L3) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк(L1, L2, L3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот пример показывает, как легко наши определения отношений над списками обобщаются на весь класс структур этого типа. Решение о том, какой именно способ записи списков будет использоваться в той или иной программе, следует принимать в соответствии с тем смыслом, который мы придаем списку в каждом конкретном случае. Если, например, список — это просто множество элементов, то наиболее удобна обычная прологовская нотация, поскольку в ней непосредственно выражается то, что программист имел в виду. С другой стороны, некоторые типы выражений также можно трактовать как своего рода списки. Например, для конъюнктов в исчислении высказываний подошло бы следующее спископодобное представление:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • истина соответствует пустому списку,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • & — оператор для соединения головы с хвостом, определяемый, например, как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 300, xfy, &)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конъюнкция членов а, b, и с выглядела бы тогда как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а & b & с & истина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все приведенные примеры базируются, по существу, на одной и той же структуре, представляющей список. Однако в гл. 8 мы рассмотрели существенно другой способ, влияющий на эффективность вычислений. Уловка состояла в том, что список представлялся в виде пары списков, являясь их "разностью". Было показано, что такое представление приводит к очень эффективной реализации отношения конкатенации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Материал настоящего раздела проливает свет и на то различие, которое существует между применением операторов в математике и применением их в Прологе. В математике с каждым оператором всегда связано некоторое действие, в то время как в Прологе операторы используются просто для представления структур.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.1.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 список( Объект)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 для распознавания случаев, когда Объект является стандартным прологовским списком.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.2.\b0   Определите отношение принадлежности к списку, используя систему обозначений, введенную в этой разделе: "затем — ничего_не_делать".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.3.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобр( СтандСпис, Спис)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 для преобразования списков из стандартного представления в систему "затем — ничего_не_делать". Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобр( [а, b], а затем b затем ничего_не_делать)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.4.\b0   Обобщите отношение преобр на случай произвольного альтернативного представления списков. Конкретное представление задается символом, обозначающим пустой список, и функтором для соединения головы с хвостом. В отношении преобр придется добавить два новых аргумента:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобр( СтандСпис, Спис, Функтор, ПустСпис)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Примеры применения этого отношения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- пpeoбp( [а, b], L, затем, ничего_не_делать).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = а затем b затем ничего_не_делать\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?-  преобр( [а, b, с], L, +, 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = а+(b+(с+0) )\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 9.1.2. Сортировка списков\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сортировка применяется очень часто. Список можно отсортировать (упорядочить), если между его элементами определено отношение порядка. Для удобства изложения мы будем использовать отношение порядка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 больше( X, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означающее, что X \i больше, чем\i0   Y, независимо от того, что мы в действительности понимаем под "больше, чем". Если элементами списка являются числа, то отношение больше будет, вероятно, определено как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 больше( X, Y) :- X > Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если же элементы списка — атомы, то отношение больше может соответствовать алфавитному порядку между ними.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пусть\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сорт( Спис, УпорСпис)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обозначает отношение, в котором Спис — некоторый список, а УпорСпис — это список, составленный из тех же элементов, но упорядоченный по возрастанию в соответствия с отношением больше. Мы построим три определения этого отношения на Прологе, основанные на трех различных идеях о механизме сортировки. Вот первая идея:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Для того, чтобы упорядочить список Спис, необходимо:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • Найти в Спис два смежных элемента X и Y, таких, что больше( X, Y), и поменять X и Y местами, получив тем самым новый список Спис1; затем отсортировать Спис1.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • Если в Спис нет ни одной пары смежных элементов X и Y, таких, что больше( X, Y), то считать, что Спис уже отсортирован.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы переставили местами 2 элемента X и Y, расположенные в списке "не в том порядке", с целью приблизить список к своему упорядоченному состоянию. Имеется в виду, что после достаточно большого числа перестановок все элементы списка будут расположены в правильном порядке. Описанный принцип сортировки принято называть \i методом пузырька\i0  , поэтому соответствующая прологовская процедура будет называться пузырек.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пузырек( Спис, УпорСпис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перест( Спис, Спис1), !, % Полезная перестановка?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  пузырек( Спис1, УпорСпис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пузырек( УпорСпис, УпорСпис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Если нет, то список уже упорядочен\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перест( [X, Y | Остаток], [Y, X ) Остаток] ):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Перестановка первых двух элементов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перест( [Z | Остаток], [Z | Остаток1] ):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перест( Остаток, Остаток1). % Перестановка в хвосте\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще один простой алгоритм сортировки называется \i сортировкой со вставками.\i0   Он основан на следующей идее:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Для того, чтобы упорядочить непустой список L = [X | Хв], необходимо:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (1) Упорядочить хвост Хв списка  L.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (2) Вставить голову X списка L в упорядоченный хвост, поместив ее в такое место, чтобы получившийся список остался упорядоченным. Список отсортирован.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот алгоритм транслируется в следующую процедуру вставсорт на Прологе:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вставсорт([], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вставсорт( [X | Хв], УпорСпис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вставсорт( Хв, УпорХв), % Сортировка хвоста\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( X, УпорХв, УпорСпис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Вставить X на нужное место\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( X, [Y | УпорСпис], [Y | УпорСпис1]):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, Y), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( X, УпорСпис, УпорСпис1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( X, УпорСпис, [X | УпорСпис] ).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.1.\b0   Сортировка списка процедурой быстрсорт.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедуры сортировки пузырек и вставсорт просты, но не эффективны. Из этих двух процедур процедура со вставками более эффективна, однако среднее время, необходимое для сортировки списка длиной  \i n\i0    процедурой вставсорт, возрастает с ростом \i n\i0   пропорционально \i n\i0  &#178;. Поэтому для длинных списков значительно лучше работает алгоритм \i быстрой сортировки\i0  , основанный на следующей идее (рис. 9.1):\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Для того, чтобы упорядочить непустой список L,  необходимо:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (1) Удалить из списка L какой-нибудь элемент X и разбить оставшуюся часть на два списка, называемые Меньш и Больш, следующим образом: все элементы большие, чем X, принадлежат списку Больш, остальные — списку Меньш.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (2) Отсортировать список Меньш, результат — список УпорМеньш.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (3) Отсортировать список Больш, результат — список УпорБольш.\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (4) Получить результирующий упорядоченный список как конкатенацию списков УпорМеньш и [ X | УпорБольш].\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что если исходный список пуст, то результатом сортировки также будет пустой список. Реализация быстрой сортировки на Прологе показана на рис. 9.2. Здесь в качестве элемента X, удаляемого из списка, всегда выбирается просто голова этого списка. Разбиение на два списка запрограммировано как отношение с четырьмя аргументами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбиение( X, L, Больш, Меньш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Временная сложность нашего алгоритма зависит от того, насколько нам повезет при разбиении сортируемого списка. Если списки всегда разбиваются на два списка примерно равной длины, то процедура сортировки имеет временную сложность порядка \i n \i0  log \i n\i0  , где \i n\i0   — длина исходного списка. Если же, наоборот, разбиение всегда приводит к тому, что один из списков оказывается значительно больше другого, то сложность будет порядка  \i n\i0  &#178;. Анализ показывает, что, к счастью, средняя производительность быстрой сортировки ближе к лучшему случаю, чем к худшему.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программу, показанную на рис. 9.2, можно усовершенствовать, если реализовать операцию конкатенации более эффективно. Напомним, что конкатенация становится тривиальной операцией после применения разностного представления списков, введенного в гл. 8. Для того, чтобы использовать эту идею в нашей процедуре сортировки, нужно представить встречающиеся в ней списки в форме пар вида A-Z следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  УпорМеньш имеет вид A1-Z1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  УпорБольш имеет вид A2-Z2\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 быстрсорт( [], [] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 быстрсорт( [X | Хвост], УпорСпис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разбиение( X, Хвост, Меньш, Больш),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  быстрсорт( Меньш, УпорМеньш),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  быстрсорт( Больш, УпорБольш),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( УпорМеньш, [X | УпорБольш], УпорСпис).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбиение( X, [], [], [] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбиение( X, [Y | Хвост], [Y | Меньш], Больш ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, Y), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разбиение( X, Хвост, Меньш, Больш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбиение( X, [Y | Хвост], Меньш, [Y | Больш] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разбиение( X, Хвост, Меньш, Больш).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [], L, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [X | L1], L2, [X | L3] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( L1, L2, L3 ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.2.\b0   Быстрая сортировка.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда конкатенации списков\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 УпорМеньш и [ X | УпорБольш]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 будет соответствовать конкатенация пар\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 A1-Z1 и [ X | A2]-Z2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате мы получим\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 А1-Z2, причем Z1 = [ X | А2]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пустой список представляется парой Z-Z. Систематически вводя изменения в программу рис. 9.2, мы получим более эффективный способ реализации процедуры быстрсорт, показанный на рис. 9.3 под именем быстрсорт2. Здесь, как и раньше, процедура быстрсорт использует обычное представление списков, но в действительности сортировку выполняет более эффективная процедура быстрсорт2, использующая разностное представление. Эти две процедуры связаны между собой, соотношением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 быстрсорт( L, S) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  быстрсорт2( L, S-[] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 быстрсорт( Спис, УпорСпис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  быстрсорт2( Спис, УпорСпис-[] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 быстрсорт2( [], Z-Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 быстрсорт2( [X | Хвост], A1-Z2) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разбиение( X, Хвост, Меньш, Больш),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  быстрсорт2( Меньш, А1-[X | A2] ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  быстрсорт2( Больш, A2-Z2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.3.\b0   Более эффективная реализация процедуры быстрсортс использованием разностного представления списков. Отношение разбиение( X, Спис, Меньш, Больш) определено, как на рис. 9.2.\par
\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.5.\b0   Напишите процедуру слияния двух упорядоченных списков в один третий список. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- слить( [2, 5, 6, 6, 8], [1, 3, 5, 9], L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L = [1, 2, 3, 5, 5, 6, 6, 8, 9]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.6.\b0   Программы сортировки, показанные на рис. 9.2 и 9.3, отличаются друг от друга способом представления списков. Первая из них использует обычное представление, в то время как вторая — разностное представление. Преобразование из одного представления в другое очевидно и может быть автоматизировано. Введите в программу рис. 9.2 необходимые изменения, чтобы преобразовать ее в программу рис. 9.3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.7.\b0   Наша программа быстрсорт в случае, когда исходный список уже упорядочен или почти упорядочен, работает очень неэффективно. Проанализируйте причины этого явления.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.8.\b0   Существует еще одна хорошая идея относительно механизма сортировки списков, позволяющая избавиться от недостатков программы быстрсорт, а именно: разбить список на два меньших списка, отсортировать их, а затем слить вместе. Итак, для того, чтобы отсортировать список L, необходимо\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • разбить L на два списка L1 и L2 примерно одинаковой длины;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • произвести сортировку списков L1 и L2,получив списки S1 и S2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • слить списки S1 и S2, завершив на этом сортировку списка L.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Реализуйте этот принцип сортировки и сравните его эффективность с эффективностью программы быстрсорт.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 9.2. Представление множеств двоичными деревьями\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Списки часто применяют для представления множеств. Такое использование списков имеет тот недостаток, что проверка принадлежности элемента множеству оказывается довольно неэффективной. Обычно предикат принадлежит( X, L) для проверки принадлежности X к L программируют так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит X, [X | L] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит X, [ Y | L] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы найти X в списке L, эта процедура последовательно просматривает список элемент за элементом, пока ей не встретится либо элемент X, либо конец списка. Для длинных списков такой способ крайне неэффективен.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для облегчения более эффективной реализация отношения принадлежности применяют различные древовидные структуры. В настоящем разделе мы рассмотрим двоичные деревья.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Двоичное дерево либо пусто, либо состоит из следующих трех частей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • корень\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • левое поддерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  правое поддерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Корень может быть чем угодно, а поддеревья должны сами быть двоичными деревьями. На рис. 9.4 показано представление множества [а, b, с, d] двоичным деревом. Элементы множества хранятся в виде вершин дерева. Пустые поддеревья на рис. 9.4 не показаны. Например, вершина b имеет два поддерева, которые оба пусты.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует много способов представления двоичных деревьев на Прологе. Одна из простых возможностей — сделать корень главным функтором соответствующего терма, а поддеревья — его аргументами. Тогда дерево рис. 9.4 примет вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а( b, с( d) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такое представление имеет среди прочих своих недостатков то слабое место, что для каждой вершины дерева нужен свой функтор. Это может привести к неприятностям, если вершины сами являются структурными объектами.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.4.\b0   Двоичное дерево.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует более эффективный и более привычный способ представления двоичных деревьев: нам нужен специальный символ для обозначения пустого дерева и функтор для построения непустого дерева из трех компонент (корня и двух поддеревьев). Относительно функтора и специального символа сделаем следующий выбор:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Пусть атом nil представляет пустое дерево.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В качестве функтора примем дер, так что дерево с корнем X, левым поддеревом L и правым поддеревом R будет иметь вид терма дер( L, X, R) (см. рис. 9.5).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом представлении дерево рис. 9.4 выглядит как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дер( дер( nil, b, nil), a,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  дер( дер( nil, d, nil), с, nil) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь рассмотрим отношение принадлежности, которое будем обозначать внутри. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, T)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинна, если X есть вершина дерева T. Отношение внутри можно определить при помощи следующих правил:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 X есть вершина дерева T, если\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • корень дерева T совпадает с X, или\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • X — это вершина из левого поддерева, или\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • X — это вершина из правого поддерева.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.5.\b0   Представление двоичных деревьев.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти правила непосредственно транслируются на Пролог следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, дер( _, X, _) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, дер( L, _, _) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внутри( X, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, дер( _, _, R) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внутри( X, R).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очевидно, что цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, nil)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 терпит неудачу при любом X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Посмотрим, как ведет себя наша процедура. Рассмотрим рис. 9.4. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, T)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 используя механизм возвратов, находит все элементы данных, содержащиеся в множестве, причем обнаруживает их в следующем порядке:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X = а; X = b; X = с; X = d\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь рассмотрим вопрос об эффективности. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( а, T)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 достигается сразу же после применения первого предложения процедуры внутри. С другой стороны, цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( d, T)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 будет успешно достигнута только после нескольких рекурсивных обращений. Аналогично цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( e, T)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 потерпит неудачу только после того, как будет просмотрено все дерево в результате рекурсивного применения процедуры внутри ко \i всем\i0   поддеревьям дерева T.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом последнем случае мы видим такую же неэффективность, как если бы мы представили множество просто списком. Положение можно улучшить, если между элементами множества существует отношение порядка. Тогда можно упорядочить данные в дереве слева направо в соответствии с этим отношением.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.6.\b0   Двоичный справочник. Элемент 6 найден после прохода по отмеченному пути 5&#8594;8&#8594;6.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Будем говорить, что непустое дерево дер( Лев, X, Прав) упорядочено слева направо, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) все вершины левого поддерева Лев меньше X;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) все вершины правого поддерева Прав больше X;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) оба поддерева упорядочены.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Будем называть такое двоичное дерево \i двоичным справочником\i0  . Пример показан на рис. 9.6.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Преимущество упорядочивания состоит в том, что для поиска некоторого объекта в двоичном справочнике всегда достаточно просмотреть не более одного поддерева. Экономия при поиске объекта X достигается за счет того, что, сравнив X с корнем, мы можем сразу же отбросить одно из поддеревьев. Например, пусть мы ищем элемент 6 в дереве, изображенной на рис. 9.6. Мы начинаем с корня 5, сравниваем 6 с 5, получаем 6 > 5. Поскольку все элементы данных в левом поддереве должны быть меньше, чем 5, единственная область, в которой еще осталась возможность найти элемент 6, — это правое поддерево. Продолжаем поиск в правом поддереве, переходя к вершине 8, и т.д.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Общий метод поиска в двоичном справочнике состоит в следующем:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Для того, чтобы найти элемент X в справочнике Д, необходимо:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • если X — это корень справочника Д, то считать, что X уже найден, иначе\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • если X меньше, чем корень, то искать X в левом поддереве, иначе\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • искать X в правом поддереве;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • если справочник Д пуст, то поиск терпит неудачу.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти правила запрограммированы в виде процедуры, показанной на рис. 9.7. Отношение больше( X, Y), означает, что X больше, чем Y. Если элементы, хранимые в дереве, — это числа, то под "больше, чем" имеется в виду просто X > Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует способ использовать процедуру внутри также и для \i построения\i0   двоичного справочника. Например, справочник Д, содержащий элементы 5, 3, 8, будет построен при помощи следующей последовательности целей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- внутри( 5, Д), внутри( 3, Д), внутри( 8, Д).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Д = дер( дер( Д1, 3, Д2), 5, дер( Д3, 8, Д4) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменные Д1, Д2, Д3 и Д4 соответствуют четырем неопределенным поддеревьям. Какими бы они ни были, все равно дерево Д будет содержать заданные элементы 3, 5 и 8. Структура построенного дерева зависит от того порядка, в котором указываются цели (рис. 9.8).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, дер( _, X, _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, дер( Лев, Корень, Прав) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( Корень, X), % Корень больше, чем X\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, Лев).     % Поиск в левом поддереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, дер( Лев, Корень, Прав) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, Корень), % X больше, чем корень\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внутри( X, Прав).   % Поиск в правом поддереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.7.\b0   Поиск элемента X в двоичном справочнике.\par
\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.8.\b0   (а) Дерево Д, построенное как результат достижения целей: внутри( 5, Д), внутри( 3, Д), внутри( 8, Д). (b) Дерево, полученное при другом порядке целей: внутри( 5, Д), внутри( 3, Д), внутри( 8, Д).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь уместно сделать несколько замечаний относительно эффективности поиска в справочниках. Вообще говоря, поиск элемента в справочнике эффективнее, чем поиск в списке. Но насколько? Пусть \i n\i0   — число элементов множества. Если множество представлено списком, то ожидаемое время поиска будет пропорционально его длине \i n\i0  . В среднем нам придется просмотреть примерно половину списка. Если множество представлено двоичным деревом, то время поиска будет пропорционально глубине дерева. Глубина дерева — это длина самого длинного пути между корнем и листом дерева. Однако следует помнить, что глубина дерева зависит от его формы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы говорим, что дерево (приближенно) сбалансировано, если для каждой вершины дерева соответствующие два поддерева содержат примерно равное число элементов. Если дерево хорошо сбалансировано, то его глубина пропорциональна log \i n\i0  . В этом случае мы говорим, что дерево имеет логарифмическую сложность. Сбалансированный справочник лучше списка настолько же, насколько log \i n\i0   меньше \i n\i0  . К сожалению, это верно только для приближенно сбалансированного дерева. Если происходит разбалансировка дерева, то производительность падает. В случае полностью разбалансированных деревьев, дерево фактически превращается в список. Глубина дерева в этом случае равна \i n\i0  , а производительность поиска оказывается столь же низкой, как и в случае списка. В связи с этим мы всегда заинтересованы в том, чтобы справочники были сбалансированы. Методы достижения этой цели мы обсудим в гл. 10.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.9.\b0   Определите предикаты\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 двдерево( Объект)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 справочник( Объект)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 распознающие, является ли Объект двоичным деревом или двоичным справочником соответственно. Используйте обозначения, введенные в данном разделе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.10.\b0   Определите процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 глубина( ДвДерево, Глубина)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вычисляющую глубину двоичного дерева в предположении, что глубина пустого дерева равна 0, а глубина одноэлементного дерева равна 1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.11.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 линеаризация( Дерево, Список)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соответствующее "выстраиванию" всех вершин дерева в список.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.12.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 максэлемент( Д, Элемент)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 таким образом, чтобы переменная Элемент приняла значение наибольшего из элементов, хранящихся в дереве Д.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.13.\b0   Внесите изменения в процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( Элемент, ДвСправочник)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавив в нее третий аргумент Путь таким образом, чтобы можно было бы получить путь между корнем справочника и указанным элементом.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 9.3. Двоичные справочники: добавление и удаление элемента\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы имеем дело с динамически изменяемым множеством элементов данных, то нам может понадобиться внести в него новый элемент или удалить из него один из старых. В связи с этим набор основных операций, выполняемых над множеством S, таков:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, S)       % X  содержится в  S\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( S, X, S1) % Добавить  X  к  S,  результат -  S1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( S, X, S1)  % Удалить  X  из  S,  результат -  S1\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.9.\b0   Введение в двоичный справочник нового элемента на уровне листьев. Показанные деревья соответствуют следующей последовательности вставок: добавить( Д1, 6, Д2)\b , \b0  добавить( Д2, 6, Д3)\b , \b0  добавить( Д3, 6, Д4)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доблист( nil, X, дер( nil, X, nil) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доблист( дер( Лев, X, Прав), X, дер( Лев, X, Прав) ). \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доблист( дер( Лев, Кор, Прав), X, дер( Лев1, Кор, Прав)) :- \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( Кор, X), \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доблист( Лев, X, Лев1)). \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доблист( дер( Лев, Кор, Прав), X, дер( Лев, Кор, Прав1)) :- \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, Кор), \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  доблист( Прав, X, Прав1). \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.10.\b0   Вставление в двоичный справочник нового элемента в качестве листа.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Определим отношение \i добавить\i0  . Простейший способ: ввести новый элемент на самый нижний уровень дерева, так что он станет его листом. Место, на которое помещается новый элемент, выбрать таким образом, чтобы не нарушить упорядоченность дерева. На рис. 9.9 показано, какие изменения претерпевает дерево в процессе введения в него новых элементов. Назовем такой метод вставления элемента в множество\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доблист( Д, X, Д1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Правила добавления элемента на уровне листьев таковы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Результат добавления элемента X к пустому дереву есть дерево дер( nil, X, nil).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Если X совпадает с корнем дерева Д, то Д1 = Д (в множестве не допускается дублирования элементов).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Если корень дерева Д больше, чем X, то X вносится в левое поддерево дерева Д; если корень меньше, чем X, то X вносится в правое поддерево.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 9.10 показана соответствующая программа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь рассмотрим операцию \i удалить\i0  . Лист дерева удалить легко, однако удалить какую-либо внутреннюю вершину — дело не простое. Удаление листа можно на самом деле определить как операцию, обратную операции добавления листа:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удлист( Д1, X, Д2) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  доблист( Д2, X, Д1).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.11.\b0   Удаление X из двоичного справочника. Возникает проблема наложения "заплаты" на место удаленного элемента X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К сожалению, если X — это внутренняя вершина, то такой способ не работает, поскольку возникает проблема, иллюстрацией к которой служит рис. 9.11. Вершина X имеет два поддерева Лев и Прав. После удаления вершины X в дереве образуется "дыра", и поддеревья Лев и Прав теряют свою связь с остальной частью дерева. К вершине А оба эти поддерева присоединить невозможно, так как вершина А способна принять только одно из них.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если одно из поддеревьев \b Лев\b0   и \b Прав\b0   пусто, то существует простое решение: подсоединить к А непустое поддерево. Если же оба поддерева непусты, то можно использовать следующую идею (рис. 9.12): если самую левую вершину Y поддерева Прав переместить из ее текущего положения вверх и заполнить ею пробел, оставшийся после X, то упорядоченность дерева не нарушится. Разумеется, та же идея сработает и в симметричном случае, когда перемещается самая правая вершина поддерева Лев.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9. 2.\b0   Заполнение пустого места после удаления X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 9.13 показана программа, реализующая операцию удаления элементов в соответствии с изложенными выше соображениями. Основную работу по перемещению самой левой вершины выполняет отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удмин( Дер, Y, Дер1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь Y — минимальная (т.е. самая левая) вершина дерева Дер, а Дер1 — то, во что превращается дерево Дер после удаления вершины Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует другой, элегантный способ реализация операции \i добавить\i0   и \i удалить\i0  . Отношение \i добавить\i0   можно сделать недетерминированным в том смысле, что новый элемент вводится на произвольный уровень дерева, а не только на уровень листьев. Правила таковы:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Для того, чтобы добавить X в двоичный справочник Д, необходимо одно из двух:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • добавить X на место корня дерева (так, что X станет новым корнем) или\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • если корень больше, чем X, то внести X в левое поддерево, иначе — в правое поддерево.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 уд( дер( nil, X, Прав), X, Прав).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 уд( дер( Лев, X, nil), X, Лев).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 уд( дер( Лев, X, Прав), X, дер( Лев,Y, Прав1) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удмин( Прав, Y, Прав1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 уд( дер( Лев, Кор, Прав), X, дер( Лев1, Кор, Прав) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( Кор, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  уд( Лев, X, Лев1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 уд( дер( Лев, Кор, Прав), X, дер( Лев, Кор, Прав1) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, Кор),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  уд( Прав, X, Прав1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удмин( дер( nil, Y, Прав), Y, Прав).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удмин( дер( Лев, Кор, Прав), Y, дер( Лев1, Кор, Прав) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удмин( Лев, Y, Лев1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.13.\b0   Удаление элемента из двоичного справочника.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Трудным моментом здесь является введение X на место корня. Сформулируем эту операций в виде отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добкор( Д, X, X1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где X — новый элемент, вставляемый вместо корня в Д, а Д1 — новый справочник с корнем X. На рис. 9.14 показано, как соотносятся X, Д и Д1. Остается вопрос: что из себя представляют поддеревья L1 и L2 (или, соответственно, R1 и R2) на рис. 9.14?\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.14.\b0   Внесение X в двоичный справочник в качестве корня.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответ мы получим, если учтем следующие ограничения на L1, L2:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • L1 и L2 — двоичные справочники;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • множество всех вершин, содержащихся как в L1, так и в L2, совпадает с множеством вершин справочника L;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • все вершины из L1 меньше, чем X; все вершены из L2 больше, чем X.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношение, которое способно наложить все эти ограничения на L1, L2, — это как раз и есть наше отношение добкор. Действительно, если бы мы вводили X в L на место корня, то поддеревьями результирующего дерева как раз и оказались бы L1 и L2. В терминах Пролога L1 и L2 должны быть такими, чтобы достигалась цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добкор( L, X, дер( L1, X, L2) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Те же самые ограничения применимы к R1, R2:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добкор( R, X, дер( R1, X, R2) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 9.15 показана программа для "недетерминированного" добавления элемента в двоичный справочник.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( Д, X, Д1) :-               % Добавить X на место корня\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  добкор( Д, X, Д1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( дер( L, Y, R), X, дер( L1, Y, R) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( Y, X),                      % Ввести X в левое поддерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  добавить( L, X, L1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( дер( L, Y, R), X, дер( L, Y, R1) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, Y),                      % Ввести X в правое поддерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  добавить( R, X, R1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добкор( nil, X, дер( nil, X, nil) ). % Ввести X в пустое дерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добкор( дер( L, Y, R), X, дер( L1, X, дер( L2, Y, R) )) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( Y, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  добкор( L, X, дер( L1, X, L2) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добкор( дep( L, Y, R), X, дep( дep( L, Y, R1), X, R2) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  добкор( R, X, дер( R1, X, R2) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.15.\b0   Внесение элемента на произвольный уровень двоичного справочника.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта процедура обладает тем замечательным свойством, что в нее не заложено никаких ограничений на уровень дерева, в который вносится новый элемент. В связи с этим операцию \i добавить\i0   можно использовать "в обратном направлении" для удаления элемента из справочника. Например, приведенная ниже последовательность целей строит справочник Д, содержащий элементы 3, 5, 1, 6, а затем удаляет из него элемент 5, после чего получается справочник ДД:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( nil, 3, Д1), добавить( Д1, 5, Д2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( Д2, 1, Д3), добавить( Д3, 6, Д),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( ДД, 5, Д).\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 9.4. Отображение деревьев\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так же, как и любые объекты данных в Прологе, двоичное дерево T может быть непосредственно выведено на печать при помощи встроенной процедуры write. Однако цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 write( T)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 хотя и отпечатает всю информацию, содержащуюся в дереве, но действительная структура дерева никак при этом не будет выражена графически. Довольно утомительная работа — пытаться представить себе структуру дерева, рассматривая прологовский терм, которым она представлена. Поэтому во многих случаях желательно иметь возможность отпечатать дерево в такой форме, которая графически соответствует его структуре.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует относительно простой способ это сделать. Уловка состоит в том, чтобы изображать дерево растущим слева направо, а не сверху вниз, как обычно. Дерево нужно повернуть влево таким образом, чтобы корень стал его крайним слева элементом, а листья сдвинулись вправо (рис. 9.16).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.16.\b0   (а) Обычное изображение дерева. (b) То же дерево, отпечатанное процедурой отобр (дуги добавлены для ясности).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте определим процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( T)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 так, чтобы она отображала дерево в форме, показанной на рис. 9.16. Принцип работы этой процедуры:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Для того, чтобы отобразить непустое дерево T, необходимо:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (1) отобразить правое поддерево дерева T с отступом вправо на расстояние H;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (2) отпечатать корень дерева T;\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 (3) отобразить левое поддерево дерева T с отступом вправо на расстояние H.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Величина отступа H, которую можно выбирать по желанию, — это дополнительный параметр при отображении деревьев. Введем процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр2( T, H)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 печатающую дерево T с отступом на H пробелов от левого края листа. Связь между процедурами отобр и отобр2 такова:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( T) :- отобр2( T, 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 9.17 показана программа целиком. В этой программе предусмотрен сдвиг на 2 позиции для каждого уровня дерева. Описанный принцип отображения можно легко приспособить для деревьев других типов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( T) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр2( T, 0).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр2( nil, _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр2( дер( L, X, R), Отступ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Отступ2 is Отступ + 2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр2( R, Отступ2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( Отступ), write( X), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( L, Отступ2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.17.\b0   Отображение двоичного дерева.\par
\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.14.\b0   Наша процедура изображает дерево, ориентируя его необычным образом: корень находится слева, а листья — справа. Напишите (более сложную) процедуру для отображения дерева, ориентированного обычным образом, т.е. с корнем наверху и листьями внизу. \par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 9.5. Графы \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 9.5.1. Представление графов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Графы используются во многих приложениях, например для представления отношений, ситуаций или структур задач. Граф определяется как множество \i вершин\i0   вместе с множеством \i ребер\i0  , причем каждое ребро задается парой вершин. Если ребра направлены, то их также называют \i дугами\i0  . Дуги задаются \i упорядоченными\i0   парами. Такие графы называются \i направленными\i0  . Ребрам можно приписывать стоимости, имена или метки произвольного вида, в зависимости от конкретного приложения. На рис. 9.18 показаны примеры графов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В Прологе графы можно представлять различными способами. Один из них — каждое ребро записывать в виде отдельного предложения. Например, графы, показанные на рис. 9.18, можно представить в виде следующего множества предложений:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 связь( а, b).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 связь( b, с).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дуга( s, t, 3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дуга( t, v, 1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дуга( u, t, 2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другой способ — весь граф представлять как один объект. В этом случае графу соответствует пара множеств — множество вершин и множество ребер. Каждое множество можно задавать при помощи списка, каждое ребро — парой вершин. Для объединения двух множеств в пару будем применять функтор граф, а для записи ребра — функтор p. Тогда (ненаправленный) граф рис. 9.18 примет вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 G1 = граф( [a, b, c, d],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [p( а, b), p( b, d), p( b, с), p( c, d)] )\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.18.\b0   (а) Граф. (b) Направленный граф. Каждой дуге приписана ее стоимость.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для представления направленного графа (рис. 9.18), применив функторы диграф и д (для дуг), получим\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 G2 = диграф( [s, t, u, v],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [д( s, t, 3), д( t, v, 1), д( t, u, 5), д( u, t, 2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   д( v, u, 2) ] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если каждая вершина графа соединена ребром еще по крайней мере с одной вершиной, то в представлении графа можно опустить множество вершин, поскольку оно неявным образом содержится в списке ребер.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще один способ представления графа — связать с каждой вершиной список смежных с ней вершин. В этом случае граф превращается в список пар, каждая из которых состоит из вершины- плюс ее список смежности. Наши графы (рис. 9.18), например, можно представить как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 G1 = [ a->[b1, b->[a, c, d], c->[b, d], d->[b, c] ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 G2 = [s->[t/3], t->[u/5, v/l], u->[t/2], v->[u/2]]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь символы '->' и '/' — инфиксные операторы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Какой из способов представления окажется более удобным, зависит от конкретного приложения, а также от того, какие операции имеется в виду выполнять над графами. Вот типичные операции:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • найти путь между двумя заданными вершинами;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • найти подграф, обладающий некоторыми заданными свойствами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Примером последней операции может служить построение основного дерева графа. В последующих разделах, мы рассмотрим некоторые простые программы для поиска пути в графе и построения основного дерева. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 9.5.2. Поиск пути в графе\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пусть G — граф, а А и Z — две его вершины. Определим отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь( А, Z, G, P)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где P — ациклический путь между А и Z в графе G. Если G — граф, показанный в левой части рис. 9.18, то верно:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь( a, d, G, [a, b, d] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь( а, d, G, [a, b, c, d] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поскольку путь не должен содержать циклов, любая вершина может присутствовать в пути не более одного раза. Вот один из методов поиска пути:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Для того, чтобы найти ациклический путь P между А и Z в графе G, необходимо:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Если А = Z , то положить P = [А], иначе найти ациклический путь P1 из произвольной вершины Y в Z, а затем найти путь из А в Y, не содержащий вершин из P1.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой формулировке неявно предполагается, что существует еще одно отношение, соответствующее поиску пути со следующий ограничением: путь не должен проходить через вершины из некоторого подмножества (в данном случае P1) множества всех вершин графа. В связи с этим мы определим ещё одну процедуру:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь1( А, P1, G, P)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Аргументы в соответствии с рис. 9.19 имеют следующий смысл:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • А — некоторая вершина,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • G — граф,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • P1 — путь в G,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • P — ациклический путь в G, идущий из А в начальную вершину пути P1, а затем — вдоль пути P1 вплоть до его конца.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Pис. 9.19.\b0   Отношение путь1: Путь — это путь между А и Z, в своей заключительной части он перекрывается с Путь1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Между путь и путь1 имеется следующее соотношение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь( А, Z, G, P) :- путь1( А, [Z], G, P).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 9.19 показана идея рекурсивного определения отношения путь1. Существует "граничный" случай, когда начальная вершина пути P1 (Y на рис. 9.19) совпадает с начальной вершиной А пути P. Если же начальные вершины этих двух путей не совпадают, то должна существовать такая вершина X, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Y — вершина, смежная с X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) X не содержится в P1 и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) для P выполняется отношение путь1( А, [X | P1], G, P).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь( A, Z, Граф, Путь) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  путь1( А, [Z], Граф, Путь).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь1( А, [А | Путь1, _, [А | Путь1] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь1( А, [Y | Путь1], Граф, Путь) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  смеж( X, Y, Граф),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, Путь1), % Условие отсутствия цикла\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  путь1( А, [ X, Y | Путь1], Граф, Путь).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.20.\b0   Поиск в графе Граф ациклического пути Путь из А в Z.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 9.20 программа показана полностью. Здесь принадлежит — отношение принадлежности элемента списку. Отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 смеж( X, Y, G)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает, что в графе G существует дуга, ведущая из X в Y. Определение этого отношения зависит от способа представления графа. Если G представлен как пара множеств (вершин и ребер)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 G = граф( Верш, Реб)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 смеж( X, Y, граф( Верш, Реб) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( p( X, Y), Реб);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( p( Y, X), Реб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Классическая задача на графах — поиск Гамильтонова цикла, т.е. ациклического пути, проходящего через все вершины графа. Используя отношение путь, эту задачу можно решить так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 гамильтон( Граф, Путь) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  путь( _, _, Граф, Путь),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  всевершины( Путь, Граф).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 всевершины( Путь, Граф) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not (вершина( В, Граф),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not принадлежит( В, Путь) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь вершина( В, Граф) означает: В — вершина графа Граф.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждому пути можно приписать его стоимость. Стоимость пути равна сумме стоимостей входящих в него дуг. Если дугам не приписаны стоимости, то тогда, вместо стоимости, говорят о длине пути.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы наши отношения путь и путь1 могли работать со стоимостями, их нужно модифицировать, введя дополнительный аргумент для каждого пути:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь( А, Z, G, P, С)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь1( A, P1, C1, G, P, С)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь С — стоимость пути P, a C1 — стоимость пути P1. В отношении смеж также появится дополнительный аргумент, стоимость дуги. На рис. 9.21 показана программа поиска пути, которая строит путь и вычисляет его стоимость.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь( А, Z, Граф, Путь, Ст) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  путь1( A, [Z], 0, Граф, Путь, Ст).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь1( А, [А | Путь1], Ст1, Граф, [А | Путь1], Ст).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь1( А, [Y | Путь1], Ст1, Граф, Путь, Ст) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  смеж( X, Y, СтXY, Граф),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not принадлежит( X, Путь1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Ст2 is Ст1 + СтXY,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  путь1( А, [ X, Y | Путь1], Ст2, Граф, Путь, Ст).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.21.\b0   Поиск пути в графе: Путь — путь между А и Z в графе Граф стоимостью Ст.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эту процедуру можно использовать для нахождения пути минимальной стоимости. Мы можем построить путь минимальной стоимости между вершинами Верш1, Верш2 графа Граф, задав цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь( Bepш1, Верш2, Граф, МинПуть, МинСт),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not( путь( Верш1, Верш2, Граф, _, Ст), Ст<МинСт )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Аналогично можно среди всех путей между вершинами графа найти путь максимальной стоимости, задав цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 путь( _, _, Граф, МаксПуть, МаксСт),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not( путь( _, _, Граф, _, Ст), Ст > МаксСт)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заметим, что приведенный способ поиска максимальных и минимальных путей крайне неэффективен, так как он предполагает просмотр всех возможных путей и потому не подходит для больших графов из-за своей высокой временной сложности. В искусственном интеллекте задача поиска пути возникает довольно часто. В главах 11 и 12 мы изучим более сложные методы нахождения оптимальных путей. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 9.5.3. Построение остовного дерева\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Граф называется \i связным\i0  , если между любыми двумя его вершинами существует путь. Пусть G = (V, E) — связный граф с множеством вершин V и множеством ребep E. \i Остовное дерево\i0   графа G — это связный граф T = ( V,  E'), где E' — подмножество E такое, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) T — связный граф, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) в T нет циклов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Выполнение этих двух условий гарантирует то, что T — дерево. Для графа, изображенного в левой части рис. 9.18, существует три остовных дерева, соответствующих следующим трем спискам ребер:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер1 = [а-b, b-c, c-d]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер2 = [а-b, b-d, d-с]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер3 = [а-b, b-d, b-c]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь каждый терм вида X-Y обозначает ребро, соединяющее вершины X и Y. В качестве корня можно взять любую из вершин, указанных в списке. Остовные деревья представляют интерес, например в задачах проектирования сетей связи, поскольку они позволяют, имея минимальное число линий, установить связь между любыми двумя узлами, соответствующими вершинам графа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Определим процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 остдерево( G, T)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где T — остовное дерево графа G. Будем предполагать, что G — связный граф. Можно представить себе алгоритмический процесс построения остовного дерева следующим образом. Начать с пустого множества ребер и постепенно добавлять новые ребра, постоянно следя за тем, чтобы не образовывались циклы. Продолжать этот процесс до тех пор, пока не обнаружится, что нельзя присоединить ни одного ребра, поскольку любое новое ребро порождает цикл. Полученное множество ребер будет остовным деревом. Отсутствие циклов можно обеспечить, если придерживаться следующего простого правила: ребро присоединяется к дереву только в том случае, когда одна из его вершин уже содержится в строящемся дереве, а другая пока еще не включена в него. Программа, реализующая эту идею, показана на рис. 9.22. Основное отношение, используемое в этой программе, — это\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( Дер1, Дер, G)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь все три аргумента — множества ребер. G — связный граф; Дер1 и Дер — два подмножества G, являющиеся деревьями. Дер — остовное дерево графа G, полученное добавлением некоторого (может быть пустого) множества ребер из G к Дер1. Можно сказать, что "Дер1 расширено до Дер".\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Построение остовного дерева графа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Деревья и графы представлены списками\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % своих ребер, например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Граф = [а-b, b-с, b-d, c-d]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 остдерево( Граф, Дер) :- % Дер - остовное дерево Граф'а\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Ребро, Граф),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширить( [Ребро], Дер, Граф).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( Дер1, Дер, Граф) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  добребро( Дер1, Дер2, Граф),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширить( Дер2, Дер, Граф).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( Дер, Дер, Граф) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not добребро( Дер, _, Граф).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Добавление любого ребра приводит к циклу\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добребро( Дер, [А-В | Дер], Граф) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  смеж( А, В, Граф),      % А и В - смежные вершины\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вершина( А, Дер).       % А содержится в Дер\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not вершина( В, Дер).   % А-В не порождает цикла\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 смеж( А, В, Граф) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит ( А-В, Граф);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит ( В-А, Граф).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вершина( А, Граф) :-     % А содержится в графе, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  смеж( А, _, Граф).      % А смежна какой-нибудь вершине\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Pис. 9.22.\b0   Построение остовного дерева: алгоритмический подход. Предполагается, что Граф — связный граф.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Интересно, что можно написать программу построения остовного дерева совершенно другим, полностью декларативным способом, просто формулируя на Прологе некоторые математические определения. Допустим, что как графы, так и деревья задаются списками своих ребер, как в программе рис. 9.22. Нам понадобятся следующие определения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) T является остовным деревом графа G, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  • T — это подмножество графа G и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  • T — дерево и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  • T "накрывает" G, т.е. каждая вершина из G содержится также в T.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Множество ребер T есть дерево, если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  • T — связный граф и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  • T не содержит циклов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти определения можно сформулировать на Прологе (с использованием нашей программы путь из предыдущего раздела) так, как показано на рис. 9.23. Следует, однако, заметить, что эта программа в таком ее виде не представляет практического интереса из-за своей неэффективности.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Построение остовного дерева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Графы и деревья представлены списками ребер.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 остдерево( Граф, Дер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  подмнож( Граф, Дер),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  дерево( Дер),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  накрывает( Дер, Граф).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дерево( Дер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  связи( Дер),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not имеетцикл( Дер).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 связи( Дер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not ( вершина( А, Дер), вершина( В, Дер),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not путь( А, А, Дер, _ ) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеетцикл( Дер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  смеж( А, В, Дер),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  путь( А, В, Дер, [А, X, Y | _ ). % Длина пути > 1\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 накрывает( Дер, Граф) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not ( вершина( А, Граф), not вершина( А, Дер) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подмнож( [], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подмнож( [ X | L], S) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  подмнож( L, L1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( S = L1; S = [ X | L1] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 9.23.\b0   Построение остовного дерева: "декларативный подход".\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношения вершина и смеж см. на рис. 9. 22.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.15.\b0   Рассмотрите остовные деревья в случае, когда каждому ребру графа приписана его стоимость. Пусть \i стоимость\i0   остовного дерева определена как сумма стоимостей составляющих его ребер. Напишите программу построения для заданного графа его остовного дерева минимальной стоимости.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В данной главе мы изучали реализацию на Прологе некоторых часто используемых структур данных и соответствующих операций над ними. В том числе\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Списки:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   варианты представления списков\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   сортировка списков:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     сортировка методом "пузырька"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     сортировка со вставками\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     быстрая сортировка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     эффективность этих процедур\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Представление множеств двоичными деревьями и двоичными справочниками:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    поиск элемента в дереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    добавление элемента\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    удаление элемента\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    добавление в качестве листа или корня\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    сбалансированность деревьев и его связь с эффективностью этих операций\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    отображение деревьев\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Графы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    представление графов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    поиск пути в графе\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    построение остовного дерева\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой главе мы занимались такими важными темами, как сортировка и работа со структурами данных для представления множеств. Общее описание структур данных, а также алгоритмов, запрограммированных в данной главе, можно найти, например, в Aho, Hopcroft and Ullman (1974, 1983) или Baase (1978). В литературе рассматривается также поведение этих алгоритмов, особенно их временная сложность. Хороший и краткий обзор соответствующих алгоритмов и результатов их математического анализа можно найти в Gonnet (1984).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прологовская программа для внесения нового элемента на произвольный уровень дерева (раздел 9.3) была впервые показана автору М. Ван Эмденом (при личном общении).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Aho А. V., Hopcroft J. E. and Ullman J. D. (1974). \i The Design and Analysis of Computer Algorithms.\i0   Addison-Wesley. [Имеется перевод: Ахо А., Хопкрофт Дж. Построение и анализ вычислительных алгоритмов. Пер. с англ. — М.: Мир, 1979.]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Aho А. V., Hopcroft J. E. and Ullman J. D. (1983). \i Data Structures and Algorithms.\i0   Addison-Wesley.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Baase S. (1978). \i Computer Algorithms.\i0   Addison-Wesley.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Gonnet G. H. (1984). \i Handbook of Algorithms and Data Structures.\i0   Addison-Wesley.\par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 10\par
Усовершенствованные методы представления множеств деревьями\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В данной главе мы рассмотрим усовершенствованные методы представления множеств при помощи деревьев. Основная идея состоит в том, чтобы поддерживать сбалансированности или приближенную сбалансированность дерева, с тем чтобы избежать вырождения его в список. Механизмы балансировки деревьев гарантируют, даже в худшем случае, относительно быстрый доступ к элементам данных, хранящихся в дереве, при логарифмическом порядке времени доступа. В этой главе изложено два таких механизма: двоично-троичные (кратко, 2-3) деревья и AVL-деревья. (Для изучения остальных глав понимание данной главы не обязательно.)\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 10.1. Двоично-троичные справочники\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Двоичное дерево называют хорошо сбалансированным, если оба его поддерева имеют примерно одинаковую глубину (или размер) и сами сбалансированы. Глубина сбалансированного дерева приближенно равна log \i n\i0  , где \i n\i0   — число вершин дерева. Время, необходимое для вычислений, производимых отношениями внутри, добавить и удалить над двоичными справочниками, пропорционально глубине дерева. Таким образом, в случае двоичных справочников это время имеет порядок log \i n\i0  . Логарифмический рост сложности алгоритма, проверяющего принадлежность элемента множеству, — это определенное достижение по сравнению со списковым представлением, поскольку в последнем случае мы имеем линейный рост сложности с ростом размера множества. Однако плохая сбалансированность дерева ведет к деградации производительности алгоритмов, работающие со справочником. В крайнем случае, двоичный справочник вырождается в список, как показано на рис. 10.1. Форма справочника зависит от той последовательности, а которой в всего записываются элементы данных. В лучшей случае мы получаем хорошую балансировку и производительность порядка log \i n\i0  , а в худшем — производительность будет порядка \i n\i0  . Анализ показывает, что в среднем сложность алгоритмов внутри, добавить и удалить сохраняет порядок log \i n\i0   в допущении, что все возможные входные последовательности равновероятны. Таким образом, средняя производительность, к счастью, оказывается ближе к лучшему случаю, чек к худшему. Существует, однако, несколько довольно простых механизмов, которые поддерживают хорошую сбалансированность дерева, вне зависимости от входной последовательности, формирующей дерево. Эти механизмы гарантируют производительность алгоритмов внутри, добавить и удалить порядка log \i n\i0   даже \i в худшем случае\i0  . Один из этих механизмов - двоично-троичные деревья (кратко, 2-3 деревья), а другой — AVL-деревья.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 10.1.\b0   Полностью разбалансированный двоичный справочник. Производительность его та же, что и у списка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2-3 дерево определяется следующим образом: оно или пусто, или состоит из единственной вершины, или удовлетворяет следующим условиям:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • каждая внутренняя вершина имеет две или три дочерних вершины, и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • все листья дерева находятся на одном и том же уровне.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Двоично-троичным (2-3) справочником называется 2-3 дерево, все элементы данных которого хранятся в листьях и упорядочены слева направо. На рис. 10.2 показан пример. Внутренние вершины содержат метки, равные минимальным элементам тех или иных своих поддеревьев, в соответствии со следующими правилами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • если внутренняя вершина имеет два поддерева, то она содержит минимальный элемент второго из них;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • если внутренняя вершина имеет три поддерева, то она содержит минимальные элементы второго и третьего поддеревьев.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 10.2.\b0   2-3 справочник. Отмеченный путь показывает процесс поиска элемента 10.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При поиске элемента X в 2-3 справочнике мы начинаем с корня и двигаемся в направлении самого нижнего уровня, руководствуясь при этом метками внутренних вершин дерева. Пусть корень содержит метки M1 и M2, тогда\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • если X < M1, то поиск продолжается в левом поддереве, иначе\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • если X < M2, то поиск продолжается в среднем поддереве, иначе —\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • в правом поддереве.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если в корне находится только одна метка М, то переходим к левому поддереву при X < M и к правому поддереву — в противоположном случае. Продолжаем применять сформулированные выше правила, пока не окажемся на самом нижнем уровне дерева, где и выяснится, найден ли элемент X, или же поиск потерпел неудачу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так как все листья 2-3 дерева находятся на одном и том же уровне, 2-3 дерево идеально сбалансировано с точки зрения глубины составляющих его поддеревьев. Все пути от корня до листа, которые мы проходим при поиске, имеют одну и ту же длину порядка log\i  n\i0  , где \i n\i0   — число элементов, хранящихся в дереве.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При добавлении нового элемента данных 2-3 дерево может расти не только в глубину, но и в ширину. Каждая внутренняя вершина, имеющая два поддерева, может приобрести новое поддерево, что приводит к росту вширь. Если же, с другой стороны, у вершины уже есть три поддерева, и она должна принять еще одно, то она расщепляется на две вершины, каждая из которых берет на себя по два из имеющихся четырех поддеревьев. Образовавшаяся при этом новая вершина передается вверх по дереву для присоединения к одной из выше расположенных вершин. Если же эта ситуация возникает на самом высоком уровне, то дерево вынуждено "вырасти" на один уровень вверх. Рис. 10.3 иллюстрирует описанный принцип.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 10.3.\b0   Вставление нового элемента в 2-3 справочник. Дерево растет сначала вширь, а затем уже вглубь.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Включение нового элемента в 2-3 справочник мы запрограммируем как отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб23( Дер, X, НовДер)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где дерево НовДер получено введением элемента X в дерево Дер. Основную работу мы поручим двум дополнительным отношениям, которые мы назовем встав. Первое из них имеет три аргумента:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Дер, X, НовДер).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь НовДер — результат вставления элемента X в Дер. Деревья Дер и НовДер имеют \i одну и ту же глубину\i0  . Разумеется, не всегда возможно сохранить ту же глубину дерева. Поэтому существует еще одно отношение с пятью аргументами специально для этого случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Дер, X, НДа, Mб, НДб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имеется в виду, что при вставления X в Дер дерево Дер разбивается на два дерева НДа и НДб, имеющих ту же глубину, что и Дер. Мб — это минимальный элемент из НДб. Пример показан на рис. 10.4.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 10.4.\b0   Объекты, показанные на рисунке, удовлетворяют отношению встав( Дер, 6, НДа, Мб, НДб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2-3 деревья мы будем представлять в программе следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • nil представляет пустое дерево;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • л( X) представляет дерево, состоящее из одной вершины — листа с элементом X;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • в2( Д1, М, Д2) представляет дерево с двумя поддеревьями Д1 и Д2; M — минимальный элемент из Д2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • в3( Д1, M2, Д2, М3, Д3) представляет дерево с тремя поддеревьями Д1, Д2 и Д3; M2 — минимальный элемент из Д2; М3 — минимальный элемент из Д3; Д1, Д2 и Д3 — 2-3 деревья.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Между доб23 и встав существует следующая связь: если после вставления нового элемента дерево не "вырастает", то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб23( Дер, X, НовДер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Дер, X, НовДер).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако если после вставления элемента глубина дерева увеличивается, то встав порождает два поддерева Д1 и Д2, а затем составляет из них дерево большей глубины:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб23( Дер, X, в2( Д1, М, Д2) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Дер, X, Д1, М, Д2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношение встав устроено более сложным образом, поскольку ему приходится иметь дело со многими случаями, а именно вставление в пустое дерево, в дерево, состоящее из одного листа, и в деревья типов в2 и в3. Возникают также дополнительные подслучаи, так как новый элемент можно вставить в первое, либо во второе, либо в третье поддерево. В связи с этим мы определим встав как набор правил таким образом, чтобы каждое предложение процедуры встав имело дело с одним из этих случаев. На рис. 10.5 показаны некоторые из возможных случаев. На Пролог они транслируются следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Случай а\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( в2( Д1, M, Д2), X, в2( НД1, M, Д2) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   больше( M, X), % M больше, чем X\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   встав( Д1, X, НД1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Случай b\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( в2( Д1, M, Д2), X, в3( НД1а, Мб, НД1б, M, Д2) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   больше( M, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   встав( Д1, X, НД1а, Мб, НД1б).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Случай с\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( в3( Д1, M2, Д2, М3, Д3), X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   в2( НД1а, Мб, НД1б), M2, в2(Д2, М3, Д3) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   больше( M2, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   встав( Д1, X, НД1а, Мб, НД1б).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 10.5.\b0   Некоторые из случаев работы отношения встав\b . \b0  (a) встав( в2( Д1, М, Д2), X, в2( НД1, М, Д2) ); (b) встав( в2( Д1, М, Д2), X, в3( НД1а, Мб, НД1б, М, Д2) ); (c) встав( в3( Д1, M2, Д2, М3, Д3), X, в2( НД1а, Мб, НД1б), M2, в2( Д2, М3, Д3) ). \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Вставление элемента в 2-3 справочник\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб23( Дер, X, Дер1) :-      % Вставить X в Дер, получить Дер1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Дер, X, Дер1).       % Дерево растет вширь\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб23( Дер, X, в2( Д1, M2, Д2) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Дер, X, Д1, M2, Д2). % Дерево растет вглубь\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб23( nil, X, л( X) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( л( А), X, л( А), X, л( X) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, А).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( л( А), X, л( X), А, л( А) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( А, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( в2( Д1, М, Д2), X, в2( НД1, М, Д2) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( М, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д1, X, НД1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( в2( Д1, М, Д2), X, в3( НД1а, Мб, НД1б, М, Д2) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( М, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д1, X, НД1а, Мб, НД1б).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( в2( Д1, М, Д2), X, в2( Д1, М, НД2) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, М),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д2, X, НД2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( в2( Д1, М, Д2), X, в3( Д1, М, НД2а, Мб, НД2б) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, М),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д2, X, НД2а, Мб, НД2б).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( в3( Д1, M2, Д2, М3, Д3), X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  в3( НД1, M2, Д2, М3, Д3) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( M2, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д1, X, НД1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( в3( Д1, M2, Д2, М3, Д3), X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  в2( НД1а, Мб, НД1б), M2, в2( Д2, М3, Д3) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( M2, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д1, X, НД1а, Мб, НД1б).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( в3( Д1, M2, Д2, М3, Д3), X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  в3( Д1, M2, НД2, М3, Д3) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, M2), больше( М3, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д2, X, НД2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( в3( Д1, M2, Д2, М3, Д3), X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  в2( Д1, M2, НД2а), Мб, в2( НД2б, М3, Д3) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, M2), больше( М3, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д2, X, НД2а, Мб, НД2б).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( в3( Д1, M2, Д2, М3, Д3), X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  в3( Д1, M2, Д2, М3, НД3) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, М3),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д3, X, НД3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( в3( Д1, M2, Д2, М3, Д3), X,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  в2( Д1, M2, Д2), М3, в2( НД3а, Мб, НД3б) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, М3),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д3, X, НД3а, Мб, НД3б).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 10.6.\b0   Вставление элемента в 2-3 справочник. В этой программе предусмотрено, что попытка повторного вставления элемента терпит неудачу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа для вставления нового элемента в 2-3 справочник показана полностью на рис. 10.6. На рис. 10.7 показана программа вывода на печать 2-3 деревьев.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша программа иногда выполняет лишние возвраты. Так, если встав с тремя аргументами терпит неудачу, то вызывается процедура встав с пятью аргументами, которая часть работы делает повторно. Можно устранить источник неэффективности, если, например, переопределить встав как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав2( Дер, X, Деревья)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Деревья — список, состоящий либо из одного, либо из трех аргументов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Деревья = [ НовДер]\b , \b0  если встав( Дер, X, НовДер)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Деревья = [ НДа, Мб, НДб], \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если встав( Дер, X, НДа, Мб, НДб)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь отношение доб23 можно переопределить так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб23( Д, X, Д1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д, X, Деревья),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  соединить( Деревья, Д1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношение соединить формирует одно дерево Д1 из деревьев, находящихся в списке Деревья.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Отображение 2-3 справочников\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр(Д) :- \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Д, 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( nil, _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( л(А), H) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( H), write( A), nl.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( в2( Д1, М, Д2), H) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  H1 is H + 5,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Д2, H1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( H), write( --), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( H), write( M), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( H), write( --), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Д1, H1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( в3( Д1, M2, Д2, М3, Д3), H) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  H1 is H + 5\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Д3, H1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( H), write( --), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( H), write( M3), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Д2, H1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( H), write( M2), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( H), write( --), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Д1, H1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       15\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     15\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       13\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   13\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       12\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     12\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       10\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     10\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        8\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  8\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        7\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      7\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    5\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     --\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        1\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 10.2. AVL-дерево: приближенно сбалансированное дерево\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 AVL-дерево — это дерево, обладающее следующими свойствами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Левое и правое поддеревья отличаются по глубине не более чем на 1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Оба поддерева являются AVL-деревьями.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Деревья, удовлетворяющие этому определению, могут быть слегка разбалансированными. Однако можно показать, что даже в худшем случае глубина AVL-дерева примерно пропорциональна log \i n\i0  , где \i n\i0   — число вершин дерева. Таким образом гарантируется логарифмический порядок производительности операций внутри, добавить и удалить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Операции над AVL-деревом работают по существу так же, как и над двоичным справочником. В них только сделаны добавления, связанные с поддержанием приближенной сбалансированности дерева. Если после вставления или удаления дерево перестает быть приближенно сбалансированным, то специальные механизмы возвращают ему требуемую степень сбалансированности. Для того, чтобы эффективно реализовать этот механизм, нам придется сохранять некоторую дополнительную информацию относительно степени сбалансированности дерева. На самом деле, нам нужно знать только разность между глубинами поддеревьев, которая может принимать значения -1, 0 или +1. Тем не менее для простоты мы предпочтем сохранять сами величины глубин поддеревьев, а не разности между ними.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы определим отношение вставления элемента как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб_avl( Дер, X, НовДер)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где оба дерева Дер и НовДер — это AVL-деревья, причем НовДер получено из Дер вставлением элемента X. AVL-деревья будем представлять как термы вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 д( Лев, А, Прав)/Глуб\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где А — корень, Лев и Прав — поддеревья, а Глуб — глубина дерева. Пустое дерево изображается как nil/0. Теперь рассмотрим вставление элемента X в непустой AVL-справочник\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер = д( L, A, R)/H\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 10.8.\b0   Задача вставления элемента в AVL-справочник (a) AVL-дерево перед вставлением X, X > А; (b) AVL-дерево после вставления X в R; (с) составные части, из которых следует построить новое дерево.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Начнем со случая, когда X больше А. X необходимо вставить в R, поэтому имеем следующее отношение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб_аv1( R, X, д( R1, В, R2)/Hb)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 10.8 показаны составные части, из которых строится дерево НовДер:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 L, А, R1, В, R2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Какова глубина деревьев L, R, R1 и R2?  L и R могут отличаться по глубине не более, чем на 1. На рис. 10.8 видно, какую глубину могут иметь R1 и R2. Поскольку в R был добавлен только один элемент X, только одно из поддеревьев R1, R2 может иметь глубину h+1.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 10.9.\b0   Три правила построения нового AVL-дepевa.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В случае, когда X меньше, чем А, имеем аналогичную ситуацию, причем левое и правое поддеревья меняются местами. Таким образом, в любом случае мы должны построить дерево НовДер, используя три дерева (назовем их Дер1, Дер2 и Дер3) и два отдельных элемента А и В. Теперь рассмотрим вопрос: как соединить между собой эти пять составных частей, чтобы дерево НовДер было AVL-справочником? Ясно, что они должны располагаться внутри НовДер в следующем порядке (слева направо):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер1, А, Дер2, В, Дер3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим три случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Среднее дерево Дер2 глубже остальных двух деревьев.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Дер1 имеет глубину не меньше, чем Дер2 и Дер3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Дер3 имеет глубину не меньше, чем Дер2 и Дер1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 10.9 видно, как можно построить дерево НовДер в каждом из этих трех случаев. Например, в случае 1 среднее дерево Дер2 следует разбить на два части, а затем включить их в состав НовДер. Три правила, показанные на pис.10.9, нетрудно запасать на Прологе в виде отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соединить( Дер, А, Дер2, В, Дер3, НовДер)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Последний аргумент НовДер — это AVL-дерево, построенное из пяти составных частей, пяти первых аргументов. Правило 1, например, принимает вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соединить( Д1/Н1, А, д( Д21, В, Д22)/Н2, С, Д3/Н3,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Пять частей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  д( д( Д1/Н1, А, Д21)/На, В, д( Д22, С, Д3/Н3)/Нс)/Нb) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Результат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  H2 > H1, H2 > Н3, % Среднее дерево глубже остальных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  На is Н1 + 1,     % Глубина левого поддерева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Нс is Н3 + 1,     % Глубина правого поддерева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Hb is На + 1,     % Глубина всего дерева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа доб_аvl, вычисляющая также глубину дерева и его поддеревьев, показана полностью на рис. 10.10.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 10.3.\b0   Определите отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 avl( Дер)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 для проверки того, является ли Дер AVL-деревом, т.е. верно ли, что любые два его поддерева, подсоединенные к одной и той же вершине, отличаются по глубине не более чем на 1. Двоичные деревья представляйте в виде термов д( Лев, Кор, Прав) или nil\b .\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Вставление элемента в AVL-справочник\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб_аvl( nil/0, X, д( nil/0, X, nil/0)/1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Добавить X к пустому дереву\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб_аvl( д( L, Y, R)/Ну, X, НовДер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Добавить X к непустому дереву\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( Y, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  доб_аvl( L, X, д( L1, Z, L2)/ _ ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Добавить к левому поддереву\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  соединить( L1, Z, L2, Y, R, НовДер).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Сформировать новое дерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 доб_avl( д( L, Y, R)/Ну, X, НовДер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  доб_avl( R, X, д( R1, Z, R2)/ _ ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Добавить к правому поддереву\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  соединить( L1, Y, Rl, Z, R2, НовДер).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соединить( Д1/Н1, А, д( Д21, В, Д22)/Н2, С, Д3/Н3,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  д( д( Д1/Н1, А, Д21)/На, В, д( Д22, С, L3/Н3)/Нс)/Нb) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Н2 > H1, H2 > Н3,     % Среднее дерево глубже остальных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  На is H1 + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Hс is Н3 + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Нb is На + 1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соединить( Д1/Н1, А, д( Д2/Н2, С, Д3/Н3,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  д( Д1/Н1, А, д( Д2/Н2, С, Д3/Н3)/Нс)/На) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  H1 >= H2, H1 >= Н3,   % "Глубокое" левое дерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  max1( H2, Н3, Нс),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  max1( H1, Нс, На).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соединить( Д1/Н1, А, Д2/Н2, С, Д3/Н3,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  д( д( Д1/Н1, А, Д2/Н2)/На, С, Д3/Н3)/Нс) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Н3 >= H2, Н3 >= H1,   % "Глубокое" правое дерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  max1( H1, H2, На),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  max1( На, Н3, Нс).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 max1( U, V, М) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  U > V, !, М is U + 1; % М равно 1 плюс max( U, V)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  М is V + 1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 10.10.\b0   Вставление элемента в AVL-справочник. В этой программе предусмотрено, что попытка повторного вставления элемента терпит неудачу. По поводу процедуры соединить см. рис. 10.9.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • 2-3 деревья и AVL-деревья, представленные в настоящей главе, — это примеры \i сбалансированных\i0   деревьев.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Сбалансированные или приближенно сбалансированные деревья гарантируют эффективное выполнение трех основных операций над деревьями: поиск, добавление и удаление элемента. Время выполнения этих операций пропорционально log \i n\i0  , где \i n\i0   — число вершин дерева.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2-3 деревья детально описаны, например, в Aho, Hopcroft and Ullman (1974, 1983). В книге этих авторов, вышедшей в 1983 г., дается также реализация соответствующих алгоритмов на языке Паскаль. H.Вирт (см. Wirth (1976)) приводит программу на Паскале для работы с AVL-деревьями. 2-3 деревья являются частным случаем более общего понятия В-деревьев. В-деревья, а также несколько других вариантов структур данных, имеющих отношение к 2-3 деревьям в AVL-деревьям, рассматриваются в книге Gonnet (1984). В этой книге, кроме того, даны результаты анализа поведения этих структур.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа вставления элемента в AVL-дерево, использующая только величину "перекоса" дерева (т.е. значение разности глубин поддеревьев, равной -1, 0 или 1, вместо самой глубины) опубликована ван Эмденом (1981).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Aho А. V., Hopcroft J. E. and Ullman J. D. (1974). \i The Design and Analysis of Computer Algorithms.\i0   Addison-Wesley. [Имеется перевод: Ахо А., Хопкрофт Дж. Построение и анализ вычислительных алгоритмов. Пер. с англ. — М.: Мир, 1979.]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Aho А. V., Hopcroft J. E. and Ullman J. D. (1983). \i Data Structures and Algorithms.\i0   Addison-Wesley.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Gonnet G. H. (1984). \i Handbook of Algorithms + Data Structures.\i0   Addison-Wesley.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 van Emden M. (1981). \i Logic Programming Newsletter 2.\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Wirth N. (1976). \i Algorithms + Data Structures = Programs.\i0   Prentice-Hall. [Имеется перевод: Вирт H. Алгоритмы + структуры данных = программы. — M.: Мир, 1985.] \par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 11.\par
Основные стратегии решения задач\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В данной главе мы сосредоточим свое внимание на одной общей схеме для представления задач, называемой \i пространством состояний\i0  . Пространство состояний — это граф, вершины которого соответствуют ситуациям, встречающимся в задаче ("проблемные ситуации"), а решение задачи сводится к поиску пути в этом графе. Мы изучим на примерах, как формулируются задачи в терминах пространства состояний, а также обсудим общие методы решения задач, представленных в рамках этого формализма. Процесс решения задачи включает в себя поиск в графе, при этом, как правило, возникает проблема, как обрабатывать альтернативные пути поиска. В этой главе будут представлены две основные стратегии перебора альтернатив, а именно поиск в глубину и поиск в ширину.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 11.1. Предварительные понятия и примеры\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим пример, представленный на рис. 11.1. Задача состоит в выработке плана переупорядочивания кубиков, поставленных друг на друга, как показано на рисунке. На каждом шагу разрешается переставлять только один кубик. Кубик можно взять только тогда, когда его верхняя поверхность свободна. Кубик можно поставить либо на стол, либо на другой кубик. Для того, чтобы построить требуемый план, мы должны отыскать последовательность ходов, реализующую заданную трансформацию.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эту задачу можно представлять себе как задачу выбора среди множества возможных альтернатив. В исходной ситуации альтернатива всего одна: поставить кубик С на стол. После того как кубик С поставлен на стол, мы имеем три альтернативы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • поставить А на стол или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • поставить А на С, или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • поставить С на А.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.1.\b0   Задача перестановки кубиков.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ясно, что альтернативу "поставить С на стол" не имело смысла рассматривать всерьез, так как этот ход никак не влияет на ситуацию.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как показывает рассмотренный пример, с задачами такого рода связано два типа понятий:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Проблемные ситуации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Разрешенные ходы или действия, преобразующие одни проблемные ситуации в другие.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проблемные ситуации вместе с возможными ходами образуют направленный граф, называемый \i пространством состояний\i0  . Пространство состояний для только что рассмотренного примера дано на рис. 11.2. Вершины графа соответствуют проблемным ситуациям, дуги — разрешенным переходам из одних состояний в другие. Задача отыскания плана решения задачи эквивалентна задаче построения пути между заданной начальной ситуацией ("стартовой" вершиной) и некоторой указанной заранее конечной ситуацией, называемой также \i целевой вершиной\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 11.3 показан еще один пример задачи: головоломка "игра в восемь" в ее представление в виде задачи поиска пути. В головоломке используется восемь перемещаемых фишек, пронумерованных цифрами от 1 до 8. Фишки располагаются в девяти ячейках, образующих матрицу 3 на 3. Одна из ячеек всегда пуста, и любая смежная с ней фишка может быть передвинута в эту пустую ячейку. Можно сказать и по-другому, что пустой ячейке разрешается перемещаться, меняясь местами с любой из смежных с ней фишек. Конечная ситуация — это некоторая заранее заданная конфигурация фишек, как показано на рис. 11.3.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.2.\b0   Графическое представление задачи манипулирования кубиками. Выделенный путь является решением задачи рис. 11.1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нетрудно построить аналогичное представление в виде графа и для других популярных головоломок. Наиболее очевидные примеры — это задача о "ханойской башне" и задача о перевозке через реку волка, козы и капусты. Во второй из этих задач предполагается, что вместе с человекам в лодке помещается только один объект и что человеку приходится охранять козу от волка и капусту от козы. С описанной парадигмой согласуются также многие задачи, имеющие практическое значение. Среди них — задача о коммивояжере, которая может служить моделью для многих практических оптимизационных задач. В задаче дается карта с \i n\i0   городами в указываются расстояния, которые надо преодолеть по дорогам при переезде из города в город. Необходимо найти маршрут, начинающийся в некотором городе, проходящий через все города и заканчивающиеся в том же городе. Ни один город, за исключением начального, не разрешается посещать дважды.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.3.\b0   "Игра в восемь" и ее представление в форме графа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте подытожим те понятия, которые мы ввели, рассматривая примеры. Пространство состояний некоторой задачи определяет "правила игры": вершины пространства состояния соответствуют ситуациям, а дуги — разрешенным ходам или действиям, или шагам решения задачи. Конкретная задача определяется\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • пространством состояний\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • стартовой вершиной\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • целевым условием (т.е. условием, к достижению которого следует стремиться); "целевые вершины" — это вершины, удовлетворяющие этим условиям.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждому разрешенному ходу или действию можно приписать его стоимость. Например, в задаче манипуляции кубиками стоимости, приписанные тем или иным перемещениям кубиков, будут указывать нам на то, что некоторые кубики перемещать труднее, чем другие. В задаче о коммивояжере ходы соответствуют переездам из города в город. Ясно, что в данном случае стоимость хода — это расстояние между соответствующими городами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В тех случаях, когда каждый ход имеет стоимость, мы заинтересованы в отыскании решения минимальной стоимости. Стоимость решения — это сумма стоимостей дуг, из которых состоит "решающий путь" — путь из стартовой вершины в целевую. Даже если стоимости не заданы, все равно может возникнуть оптимизационная задача: нас может интересовать кратчайшее решение.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде тем будут рассмотрены некоторые программы, реализующие классический алгоритм поиска в пространстве состоянии, давайте сначала обсудим. как пространство состояний может быть представлено в прологовской программе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы будем представлять пространство состояний при помощи отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 после( X, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которое истинно тогда, когда в пространстве состояний существует разрешенный ход из вершины X в вершину Y. Будем говорить, что Y — это \i преемник\i0   вершины X. Если с ходами связаны их стоимости, мы добавим третий аргумент, стоимость хода:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 после( X, Y, Ст)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти отношения можно задавать в программе явным образом при помощи набора соответствующих фактов. Однако такой принцип оказывается непрактичным и нереальным для тех типичных случаев, когда пространство состояний устроено достаточно сложно. Поэтому отношение следования после обычно определяется неявно, при помощи правил вычисления вершин-преемников некоторой заданной вершины. Другим вопросом, представляющим интерес с самой общей точки зрения, является вопрос о способе представления состояний, т.е. самих вершин. Это представление должно быть компактным, но в то же время оно должно обеспечивать эффективное выполнение необходимых операций, в частности операции вычисления вершин-преемников, а возможно и стоимостей соответствующих ходов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим в качестве примера задачу манипулирования кубиками, проиллюстрированную на рис. 11.1. Мы будем рассматривать более общий случай, когда имеется произвольное число кубиков, из которых составлены столбики, — один или несколько. Число столбиков мы ограничим некоторым максимальным числом, чтобы задача была интереснее. Такое ограничение, кроме того, является вполне реальным, поскольку рабочее пространство, которым располагает робот, манипулирующий кубиками, ограничено.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проблемную ситуацию можно представить как список столбиков. Каждый столбик в свою очередь представляется списком кубиков, из которых он составлен. Кубики упорядочены в списке таким образом, что самый верхний кубик находится в голове списка. "Пустые" столбики изображаются как пустые списки. Таким образом, исходную ситуацию рис. 11.1 можно записать как терм\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ [с, а, b], [], [] ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Целевая ситуация — это любая конфигурация кубиков, содержащая, столбик, составленный из всех имеющихся кубиков в указанном порядке. Таких ситуаций три:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ [a, b, c], [], [] ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ [], [а, b, с], [] ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ [], [], [a, b, c] ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношение следования можно запрограммировать, исходя из следующего правила: ситуация Сит2 есть преемник ситуации Сит1, если в Сит1 имеется два столбика Столб1 и Столб2, такие, что верхний кубик из Столб1 можно поставить сверху на Столб2 и получить тем самым Сит2. Поскольку все ситуации - это списки столбиков, правило транслируется на Пролог так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 после( Столбы, [Столб1, [Верх1 | Столб2], Остальные]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Переставить Верх1 на Столб2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( [Верх1 | Столб1], Столб1, Столб1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Найти первый столбик\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( Столб2, Столбы1, Остальные).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Найти второй столбик\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( X, [X | L], L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( X, [Y | L], [Y | L1] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( L, X, L1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нашем примере целевое условие имеет вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 цель( Ситуация) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит [а,b,с], Ситуация)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Алгоритм поиска мы запрограммируем как отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Старт, Решение)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Старт — стартовая вершина пространства состояний, а Решение — путь, ведущий из вершины Старт в любую целевую вершину. Для нашего конкретного примера обращение к пролог-системе имеет вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- решить( [ [с, а, b], [], [] ], Решение).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В результате успешного поиска переменная Решение конкретизируется и превращается в список конфигураций кубиков. Этот список представляет собой план преобразования исходного состояния в состояние, в котором все три кубика поставлены друг на друга в указанном порядке [а, b, с].\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 11.2. Стратегия поиска в глубину\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует много различных подходов к проблеме поиска решающего пути для задач, сформулированных в терминах пространства состояний. Основные две стратегии поиска — это поиск \i в глубину\i0   и \i поиск в ширину\i0  . В настоящем разделе мы реализуем первую из них.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы начнем разработку алгоритма и его вариантов со следующей простой идеи:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Для того, чтобы найти решающий путь Реш из заданной вершины В в некоторую целевую вершину, необходимо:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • если В — это целевая вершина, то положить Реш = [В], или\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • если для исходной вершины В существует вершина-преемник В1, такая, что можно провести путь Реш1 из В1 в целевую вершину, то положить Реш = [В | Peш1].\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.4.\b0   Пример простого пространства состояний: \i а\i0   — стартовая вершина,\i  f\i0   и\i  j\i0   — целевые вершины. Порядок, в которой происходит проход по вершинам пространства состояний при поиске в глубину: \i а\i0  , \i b\i0  , \i d\i0  , \i h\i0  , \i e\i0  ,\i  i\i0  , \i j\i0  . Найдено решение [a, b, e, j]. После возврата обнаружено другое решение: [а, с, f].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На Пролог это правило транслируется так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( В, [В] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( В).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( В, [В | Реш1] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  после( В, В1 ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решить( В1, Реш1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта программа и есть реализация поиска в глубину. Мы говорим "в глубину", имея в виду тот порядок, в котором рассматриваются альтернативы в пространстве состояний. Всегда, когда алгоритму поиска в глубину надлежит выбрать из нескольких вершин ту, в которую следует перейти для продолжения поиска, он предпочитает самую "глубокую" из них. Самая глубокая вершина — это вершина, расположенная дальше других от стартовой вершины. На рис. 11.4 мы видим на примере, в каком порядке алгоритм проходит по вершинам. Этот порядок в точности соответствует результату трассировки процесса вычислений в пролог-системе при ответе на вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- решить( а, Реш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поиск в глубину наиболее адекватен рекурсивному стилю программирования, принятому в Прологе. Причина этого состоит в том, что, обрабатывая цели, пролог-система сама просматривает альтернативы именно в глубину.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поиск в глубину прост, его легко программировать и он в некоторых случаях хорошо работает. Программа для решения задачи о восьми ферзях (см. гл. 4) фактически была примером поиска в глубину. Для того, чтобы можно было применить к этой задаче описанную выше процедуру решить, необходимо сформулировать задачу в терминах пространства состояний. Это можно сделать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • вершины пространства состояний — позиции, в которых поставлено 0 или более ферзей на нескольких последовательно расположенных горизонтальных линиях доски;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • вершина-преемник данной вершины может быть получена из нее после того, как в соответствующей позиции на следующую горизонтальную линию доски будет поставлен еще один ферзь, причем таким образом, чтобы ни один из уже поставленных ферзей не оказался под боем;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • стартовая вершина — пустая доска (представляется пустым списком);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • целевая вершина — любая позиция с восемью ферзями (правило получения вершины-преемника гарантирует, что ферзи не бьют друг друга).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Позицию на доске будем представлять как список Y-координат поставленных ферзей. Получаем программу:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 после( Ферзи, [Ферзь | Ферзи] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Ферзь, [1, 2, 3, 4, 5, 6, 7, 8] ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Поместить ферзя на любую вертикальную линию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  небьет( Ферзь, Ферзи).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 цель( [ _, _, _, _, _, _, _, _ ] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Позиция с восемью ферзями\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношение небьет означает, что Ферзь не может поразить ни одного ферзя из списка Ферзи. Эту процедуру можно легко запрограммировать так же, как это сделано в гл. 4. Ответ на вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- решить( [], Решение)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 будет выглядеть как список позиций с постепенно увеличивающимся количеством поставленных ферзей. Список завершается "безопасной" конфигурацией из восьми ферзей. Механизм возвратов позволит получить и другие решения задачи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поиск в глубину часто работает хорошо, как в рассмотренном примере, однако наша простая процедура решить может попасть в затруднительное положение, причем многими способами. Случится ли это или нет — зависит от структуры пространства состояний. Для того, чтобы затруднить работу процедуры решить в примере рис. 11.4, достаточно внести в задачу совсем небольшое изменение: добавить дугу, ведущую из \i h \i0  в \i d\i0  , чтобы получился цикл (рис. 11.5). В этом случае поиск будет выглядеть так: начиная с вершины \i а\i0  , спускаемся вплоть до \i h\i0  , придерживаясь самой левой ветви графа. На этот раз, в отличие от рис. 11.4, у вершины \i h \i0  будет преемник \i d\i0  . Поэтому произойдет \i не возврат\i0   из \i h\i0  , а \i переход\i0   к \i d\i0  . Затем мы найдем преемника вершины \i d\i0  , т.е. вершину \i h\i0  , и т.д., в результате программа зациклится между \i h\i0   и \i d\i0  .\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.5.\b0   Начинаясь в \i а\i0  , поиск в глубину заканчивается бесконечным циклом между \i d\i0   и \i h\i0  : \i a\i0  , \i b\i0  , \i d\i0  , \i h\i0  , \i d\i0  , \i h\i0  , \i d\i0   ….\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очевидное усовершенствование нашей программы поиска в глубину — добавление к ней механизма обнаружения циклов. Ни одну из вершин, уже содержащихся в пути, построенном из стартовой вершины в текущую вершину, не следует вторично рассматривать в качестве возможной альтернативы продолжения поиска. Это правило можно сформулировать в виде отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вглубину( Путь, Верш, Решение)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как видно из рис. 11.6, Верш — это состояние, из которого необходимо найти путь до цели; Путь — путь (список вершин) между стартовой вершиной и Верш; Решение — Путь, продолженный до целевой вершины.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.6.\b0   Отношение вглубину( Путь, В, Решение).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для облегчения программирования вершины в списках, представляющих пути, будут расставляться в обратном порядке. Аргумент Путь нужен для того,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) чтобы не рассматривать тех преемников вершины Верш, которые уже встречались раньше (обнаружение циклов);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) чтобы облегчить построение решающего пути Решение. Соответствующая программа поиска в глубину показана на рис. 11.7.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Верш, Решение) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вглубину( [], Верш, Решение).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вглубину( Путь, Верш, [Верш | Путь] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( Верш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вглубину( Путь, Верш, Реш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  после( Верш, Верш1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not принадлежит( Верш1, Путь), % Цикл?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вглубину( [Верш | Путь], Верш1, Реш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.7.\b0   Программа поиска в глубину без зацикливания.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь наметим один вариант этой программы. Аргументы Путь и Верш процедуры вглубину можно объединить в один список [Верш | Путь]. Тогда, вместо вершины-кандидата Верш, претендующей на то, что она находится на пути, ведущем к цели, мы будем иметь \i путь\i0  -кандидат П = [Верш | Путь], который претендует на то, что его можно продолжить вплоть до целевой вершины. Программирование соответствующего предиката\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вглубину( П, Решение)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 оставим читателю в качестве упражнения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша процедура поиска в глубину, снабженная механизмом обнаружения циклов, будет успешно находить решающие пути в пространствах состояний, подобных показанному на рис. 11.5. Существуют, однако, такие пространства состоянии, в которых наша процедура не дойдет до цели. Дело в том, что многие пространства состояний бесконечны. В таком пространстве алгоритм поиска в глубину может "потерять" цель, двигаясь вдоль бесконечной ветви графа. Программа будет бесконечно долго обследовать эту бесконечную область пространства, так и не приблизившись к цели. Пространство состояний задачи о восьми ферзях, определенное так, как это сделано в настоящем разделе, на первый взгляд содержит ловушку именно такого рода. Но оказывается, что оно все-таки конечно, поскольку Y-координаты выбираются из ограниченного множества, и поэтому на доску можно поставить "безопасным образом" не более восьми ферзей.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вглубину2( Верш, [Верш], _ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( Верш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вглубину2( Верш, [Верш | Реш], МаксГлуб) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  МаксГлуб > 0,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  после( Верш, Верш1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Maкс1 is МаксГлуб - 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вглубину2( Верш1, Реш, Maкс1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.8.\b0   Программа поиска в глубину с ограничением по глубине.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы предотвратить бесцельное блуждание по бесконечным ветвям, мы можем добавить в базовую процедуру поиска в глубину еще одно усовершенствование, а именно, ввести ограничение на глубину поиска. Процедура поиска в глубину будет тогда иметь следующие аргументы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вглубину2( Верш, Решение, МаксГлуб)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Не разрешается вести поиск на глубине большей, чем МаксГлуб. Программная реализация этого ограничения сводится к уменьшению на единицу величины предела глубины при каждом рекурсивном обращений к вглубину2 и к проверке, что этот предел не стал отрицательным. В результате получаем программу, показанную на рис. 11.8.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 11.1.\b0   Напишите процедуру поиска в глубину (с обнаружением циклов)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вглубину1( ПутьКандидат, Решение)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отыскивающую решающий путь Решение как продолжение пути ПутьКандидат. Оба пути представляйте списками вершин, расположенных в обратном порядке так, что целевая вершина окажется в голове списка Решение.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 11.2.\b0   Напишите процедуру поиска в глубину, сочетающую в себе обнаружение циклов с ограничением глубины, используя рис. 11.7 и 11.8.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 11.3.\b0   Проведите эксперимент по применению программы поиска в глубину к задаче планирования в "мире кубиков" (рис. 11.1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 11.4.\b0   Напишите процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( Ситуация)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 для отображения состояния задачи "перестановки кубиков". Пусть Ситуация — это список столбиков, а столбик, в свою очередь, — список кубиков. Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( [ [a], [e, d], [с, b] ] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 должна отпечатать соответствующую ситуацию, например так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       e      с\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 a     d      b\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ==============\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 11.3. Поиск в ширину\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В противоположность поиску в глубину стратегия поиска в ширину предусматривает переход в первую очередь к вершинам, ближайший к стартовой вершине. В результате процесс поиска имеет тенденцию развиваться более в ширину, чем в глубину, что иллюстрирует рис. 11.9.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.9.\b0   Простое пространство состояний: а — стартовая вершина, f и j — целевые вершины. Применение стратегии поиска в ширину дает следующий порядок прохода по вершинам: а, b, c, d, e, f. Более короткое решение [a, c, f] найдено раньше, чем более длинное [а, b, e, j]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поиск в ширину программируется не так легко, как поиск в глубину. Причина состоят в том, что нам приходится сохранять все множество альтернативных вершин-кандидатов, а не только одну вершину, как при поиске в глубину. Более того, если мы желаем получить при помощи процесса поиска решающий путь, то одного множества вершин недостаточно. Поэтому мы будем хранить не множество вершин-кандидатов, а множество \i путей\i0  -кандидатов. Таким образом, цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вширину( Пути, Решения)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинна только тогда, когда существует путь из множества кандидатов Пути, который может быть продолжен вплоть до целевой вершины. Этот продолженный путь и есть Решение.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 11.3.1. Списковое представление множества кандидатов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нашей первой реализации этой идеи мы будем использовать следующее представление для множества путей-кандидатов. Само множество будет списком путей, а каждый путь - списком вершин, перечисленных в обратном порядке, т.е. головой списка будет самая последняя из порожденных вершин, а последним элементом списка будет стартовая вершина. Поиск начинается с одноэлементного множества кандидатов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ [СтартВерш] ]\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Старт, Решение) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вширину( [ [Старт] ], Решение).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вширину( [ [Верш | Путь] | _ ], [Верш | Путь] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( Верш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вширину( [ [В | Путь] | Пути], Решение ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  bagof( [B1, В | Путь ],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( после( В, В1), not принадлежит( В1, [В | Путь])),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    НовПути),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     % НовПути - ациклические продолжения пути [В | Путь]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Пути, НовПути, Пути1), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вширину( Путь1, Решение);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вширину( Пути, Решение).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Случай, когда у В нет преемника\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.10.\b0   Реализации поиска в ширину.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Общие принципы поиска в ширину таковы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы выполнить поиск в ширину при заданном множестве путей-кандидатов, нужно:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • если голова первого пути — это целевая вершина, то взять этот путь в качестве решения, иначе\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • удалить первый путь из множества кандидатов и породить множество всех возможных продолжений этого пути на один шаг; множество продолжений добавить в конец множества кандидатов, а затем выполнить поиск в ширину с полученным новым множеством.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Старт, Решение) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вширь( [ [Старт] | Z ]-Z, Решение).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вширь( [ [Верш | Путь] | _ ]-_, [Верш | Путь] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( Верш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вширь( [ [В | Путь] | Пути]-Z, Решение ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  bagof( [B1, В | Путь ],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( после( В, В1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    not принадлежит( В1, [В | Путь]) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Нов ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Нов, ZZ, Z), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вширь( Пути-ZZ, Решение);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Пути \\== Z, % Множество кандидатов не пусто\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вширь( Пути-Z, Решение).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.11.\b0   Программа поиска в ширину более эффективная, чем программа рис. 11.10. Усовершенствование основано на разностном представлении списка путей-кандидатов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В случае примера рис.11.9 этот процесс будет развиваться следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Начинаем с начального множества кандидатов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ [а] ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Порождаем продолжения пути [а]:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ [b, а], [с, а] ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (Обратите внимание, что пути записаны в обратном порядке.)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Удаляем первый путь из множества кандидатов и порождаем его продолжения:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ [d, b, a], [e, b, а] ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Добавляем список продолжений в конец списка кандидатов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ [с, а], [d, b, a], [e, b, а] ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (4) Удаляем [с, а], а затем добавляем все его продолжения в конец множества кандидатов. Получаем:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ [d, b, a], [e, b, а], [f, c, a], [g, c, a] ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее, после того, как пути [d, b, a] и [e, b, а] будут продолжены, измененный список кандидатов примет вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [[f, c, a], [g, c, a], [h, d, b, a], [i, e, b, a], [j, e, b, a]]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этот момент обнаруживается путь [f, c, a], содержащий целевую вершину f. Этот путь выдается в качестве решения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа, порождающая этот процесс, показана на рис. 11.10. В этой программе все продолжения пути на один шаг генерируются встроенной процедурой bagof. Кроме того, делается проверка, предотвращающая порождение циклических путей. Обратите внимание на то, что в случае, когда путь продолжить невозможно, и цель bagof терпит неудачу, обеспечивается альтернативный запуск процедуры вширину. Процедуры принадлежит и конк реализуют отношения принадлежности списку и конкатенации списков соответственно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Недостатком этой программы является неэффективность операции конк. Положение можно исправить, применив разностное представление списков (см. гл. 8). Тогда множество путей-кандидатов будет представлено парой списков Пути и Z, записанной в виде\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пути-Z\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При введении этого представления в программу рис. 11.10 ее можно постепенно преобразовать в программу, показанную на рис. 11.11. Оставим это преобразование читателю в качестве упражнения.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 11.3.2. Древовидное представление множества кандидатов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим теперь еще одно изменение нашей программы поиска в ширину. До сих пор мы представляли множества путей-кандидатов как списки путей. Это расточительный способ, поскольку начальные участки путей являются общими для нескольких из них. Таким образом, эти общие части путей приходится хранить во многих экземплярах. Избежать избыточности помогло бы более компактное представление множества кандидатов. Таким более компактным представлением является дерево, в котором общие участки путей хранятся в его верхней части без дублирования. Будем использовать в программе следующее представление дерева. Имеется два случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Случай 1:\i0   Дерево состоит только из одной вершины В; В этом случае оно имеет вид терма л( В); Функтор л указывает на то, что В — это лист дерева.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Случай 2:\i0   Дерево состоит из корневой вершины В и множества поддеревьев Д1, Д2, …. Такое дерево представляется термом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 д( В, Пд)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Пд — список поддеревьев:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пд = [ Д1, Д2, ...]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве примера рассмотрим ситуацию, которая возникает после того, как порождены три уровня дерева рис. 11.9. Множество путей-кандидатов в случае спискового представления имеет вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ [d, b, a], [e, b, а], [f, c, a], [g, c, a] ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В виде дерева это множество выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 д( а, [д( b, [л( d), л( e)] ), д( с, [л( f), л( g)] )] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На первый взгляд древовидное представление кажется еще более расточительным, чем списковое, однако это всего лишь поверхностное впечатление, связанное с компактностью прологовской нотации для списков.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В случае спискового представления множества кандидатов эффект распространения процесса в ширину достигался за счет перемещения продолженных путей в конец списка. В нашем случае мы уже не можем использовать этот прием, поэтому программа несколько усложняется. Ключевую роль в нашей программе будет играть отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( Путь, Дер, Дер1, ЕстьРеш, Решение)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 11.12 показано, как связаны между собой аргументы отношения расширить. При каждом обращении к расширить переменные Путь и Дер будут уже конкретизированы. Дер — поддерево всего дерева поиска, одновременно оно служит для представления множества путей-кандидатов внутри этого поддерева. Путь — это путь, ведущий из стартовой вершины в корень поддерева Дер. Самая общая идея алгоритма — получить поддерево Дер1 как результат расширения Дер на один уровень. Но в случае, когда в процессе расширения поддерева Дер встретится целевая вершина, процедура расширить должна сформировать соответствующий решающий путь.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.12.\b0   Отношение paсширить( Путь, Дер, Дер1, ЕстьРеш, Решение):  s — стартовая вершина, g — целевая вершина. Решение — это Путь, продолженный вплоть до g. Дер1 — результат расширения дерева Дер на один уровень вниз.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, процедура расширить будет порождать два типа результатов. На конкретный вид результата будет указывать значение переменной ЕстьРеш:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) ЕстьРеш = да\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решение = решающий путь, т.е. Путь, продолженный до целевой вершины.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер1 = неконкретизировано.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Разумеется, такой тип результата получится только в том случае, когда Дер будет содержать целевую вершину. Добавим также, что эта целевая вершина обязана быть листом поддерева Дер.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) ЕстьРеш = нет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер1 = результат расширения поддерева Дер на один уровень вниз от своего "подножья". Дер1 не содержит ни одной "тупиковой" ветви из Дер, т.е. такой ветви, что она либо не может быть продолжена из-за отсутствия преемников, либо любое ее продолжение приводит к циклу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решение = неконкретизировано.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если в дереве Дер нет ни одной целевой вершины и, кроме того, оно не может быть расширено, то процедура расширить терпит неудачу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура верхнего уровня для поиска в ширину\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вширину( Дер, Решение)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отыскивает Решение либо среди множества кандидатов Дер, либо в его расширении. На рис. 11.3 показано, как выглядит программа целиком. В этой программе имеется вспомогательная процедура расширитьвсе. Она расширяет все деревья из некоторого \i списка\i0  , и затем, выбросив все "тупиковые" деревья", собирает все полученные расширенные деревья в один новый список. Используя механизм возвратов, она также порождает все решения, обнаруженные в деревьях из списка. Имеется одна дополнительная деталь: по крайней мере одно из деревьев должно "вырасти". Если это не так, то процедуре расширитьвсе не удается получить ни одного расширенного дерева - все деревья из списка оказываются "тупиковыми".\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % ПОИСК В ШИРИНУ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Множество кандидатов представлено деревом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Старт, Решение) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вширину( л( Старт), Решение).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вширину( Дер, Решение) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширить( [], Дер, Дер1, ЕстьРеш, Решение),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( ЕстьРеш = да;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    ЕстьРеш = нет, вширину( Дер1, Решение) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( П, Л( В), _, да, [В | П] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( В).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( П, Л( В), д( В, Пд), нет, _ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  bagof( л( B1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( после( В, B1), not принадлежит( В1, П)), Пд).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( П, д( В, Пд), д( В, Пд1), ЕстьРеш, Реш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширитьвсе( [В | П], Пд, [ ], Пд1, ЕстьРеш, Реш).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширитьвсе( _, [ ], [Д | ДД], [Д | ДД], нет, _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % По крайней мере одно дерево должно вырасти\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширитьвсе( П, [Д | ДД], ДД1, Пд1, ЕстьРеш, Реш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширить ( П, Д, Д1, ЕстьРеш1, Реш),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( ЕстьРеш 1= да, ЕстьРеш = да;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    ЕстьРеш1 = нет, !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    расширитьвсе( П, ДД, [Д1 | ДД1], Пд1, ЕстьРеш, Реш));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширитьвсе( П, ДД, ДД1, Пд1, ЕстьРеш, Реш ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.13.\b0   Реализация поиска в ширину с использованием древовидного представления множества путей-кандидатов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы разработали эту более сложную реализацию поиска в ширину не только для того, чтобы получать программу более экономичную по сравнению с предыдущей версией, но также и потому, что такое решение задачи может послужить хорошим стартом для перехода к усложненным программам поиска, управляемым эвристиками, таким как программа поиска с предпочтением из гл. 12.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 11.5.\b0   Перепишите программу поиска в ширину рис. 11.10, используя разностное представление для списка путей-кандидатов и покажите, что в результате получится программа, приведенная на рис. 11.11. Зачем в программу рис. 11.11 включена цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пути \\== Z\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проверьте, что случится при поиске в пространстве состояний рис. 11.9, если эту цель опустить. Различие в выполнении программы, возникнет только при попытке найти новые решения в ситуации, когда не осталось больше ни одного решения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 11.6.\b0   Как программы настоящего раздела можно использовать для поиска, начинающегося от \i стартового множества\i0   вершин, вместо одной стартовой вершины?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 11.7.\b0   Как программы этой главы можно использовать для поиска в обратном направлении, т.е. от целевой вершины к стартовой вершине (или к одной из стартовых вершин, если их несколько). Указание: переопределите отношение после. В каких ситуациях обратный поиск будет иметь преимущества перед прямым поиском?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 11.8.\b0   Иногда выгодно сделать поиск \i двунаправленным\i0  , т.е. продвигаться одновременно с двух сторон от стартовой и целевой вершин. Поиск заканчивается, когда оба пути "встречаются". Определите пространство поиска (отношение после) и целевое отношение для заданного графа таким образом, чтобы наши процедуры поиска в действительности выполняли двунаправленный поиск.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 11.9.\b0   Проведите эксперименты с различными методами поиска применительно к задаче планирования в "мире кубиков".\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 11.4.  Замечания относительно поиска в графах, оптимальности к сложности\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сейчас уместно сделать ряд замечаний относительно программ поиска, разработанных к настоящему моменту: во-первых, о поиске в графах, во-вторых, об оптимальности полученных решений и, в-третьих, о сложности поиска.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Приведенные примеры могли создать ложное впечатление, что наши программы поиска в ширину способны работать только в пространствах состояний, являющихся деревьями, а не графами общего вида. На самом деле, тот факт, что в одной из версий множество путей-кандидатов представлялось деревом, совсем не означает, что и само пространство состояний должно было быть деревом. Когда поиск проводится в графе, граф фактически разворачивается в дерево, причем некоторые пути, возможно, дублируются в разных частях этого дерева (см. рис. 11.14).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наши программы поиска в ширину порождают решающие пути один за другим в порядке увеличения их длин — самые короткие решения идут первыми. Это является важным обстоятельством, если нам необходима оптимальность (в отношении длины решения). Стратегия поиска в ширину гарантирует получение кратчайшего решения первым. Разумеется, это неверно для поиска в глубину.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 11.14.\b0   (а) Пространство состояний; а — стартовая вершина. (b) Дерево всех возможных ациклических путей, ведущих из а, порожденное программой поиска в ширину.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наши программы, однако, не учитывают стоимости, приписанные дугам в пространстве состояний. Если критерием оптимальности является минимум стоимости решающего пути (а не его длина), то в этом случае поиска в ширину недостаточно. Поиск с предпочтением из гл. 12 будет направлен на оптимизацию стоимости.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще одна типичная проблема, связанная с задачей поиска, — это проблема \i комбинаторной сложности\i0  . Для нетривиальных предметных областей число альтернатив столь велико, что проблема сложности часто принимает критический характер. Легко понять, почему это происходит: если каждая вершина имеет b преемников, то число путей длины l, ведущих из стартовой вершины, равно b\super l\nosupersub  (в предположении, что циклов нет). Таким образом, вместе с увеличением длин путей наблюдается \i экспоненциальный\i0   рост объема множества путей-кандидатов, что приводит к ситуации, называемой \i комбинаторным взрывом\i0  . Стратегии поиска в глубину и ширину недостаточно "умны" для борьбы с такой степенью комбинаторной сложности: отсутствие селективности приводит к тому, что все пути рассматриваются как одинаково перспективные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 По-видимому, более изощренные процедуры поиска должны использовать какую-либо информацию, отражающую специфику данной задачи, с тем чтобы на каждой стадии поиска принимать решения о наиболее перспективных путях поиска. В результате процесс будет продвигаться к целевой вершине, обходя бесполезные пути. Информация, относящаяся к конкретной решаемой задаче и используемая для управления поиском, называется \i эвристикой\i0  . Про алгоритмы, использующие эвристики, говорят, что они \i руководствуются эвристиками\i0  : они выполняют \i эвристический поиск\i0  . Один из таких методов изложен в следующей главе.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Пространство состояний\i0   есть формализм для представления задач.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Пространство состояний — это направленный граф, вершины которого соответствуют проблемным ситуациям, а дуги — возможным ходам. Конкретная задача определяется \i стартовой вершиной\i0   и \i целевым условием\i0  . Решению задачи соответствует путь в графе. Таким образом, решение задачи сводится к поиску пути в графе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Оптимизационные задачи моделируются приписыванием каждой дуге пространства состояний некоторой стоимости.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Имеются две основных стратегии поиска в пространстве состояний — \i поиск в глубину\i0   и \i поиск в ширину\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Поиск в глубину программируется наиболее легко, однако подвержен зацикливаниям. Существуют два простых метода предотвращения зацикливания: ограничить глубину поиска и не допускать дублирования вершин.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Реализация поиска в ширину более сложна, поскольку требуется сохранять множество кандидатов. Это множество может быть с легкостью представлено списком списков, но более экономное представление — в виде дерева.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Поиск в ширину всегда первым обнаруживает самое короткое решение, что не верно в отношении стратегии поиска в глубину.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В случае обширных пространств состояний существует опасность \i комбинаторного взрыва\i0  . Обе стратегии плохо приспособлены для борьбы с этой трудностью. В таких случаях необходимо руководствоваться эвристиками.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В этой главе были введены следующие понятия:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   пространство состояний\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   стартовая вершина, целевое условие,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   решающий путь\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   стратегия поиска\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   поиск в глубину, поиск в ширину\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   эвристический поиск.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поиск в глубину и поиск в ширину — базовые стратегии поиска, они описаны в любом учебнике по искусственному интеллекту, см., например, Nilsson (1971, 1980) или Winston (1984). P. Ковальский в своей книге Kowalski (1980) показывает, как можно использовать аппарат математической логики для реализации этих принципов.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Kowalski R. (1980). \i Logic for Problem Solving.\i0   North-Holland.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Nilsson N. J. (1971). \i Problem Solving Methods in Artificial Intelligence.\i0   McGraw-Hill.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Nilsson N. J. (1980). \i Principles of Artificial Intelligence.\i0   Tioga; also Springer-Verlag, 1981.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Winston P. H. (1984). \i Artificial Intelligence (second edition).\i0   Addison-Wesley. [Имеется перевод первого издания: Уинстон П. Искусственный интеллект. — М.: Мир, 1980.]\par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 12\par
Поиск с предпочтением: эвристический поиск\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поиск в графах при решении задач, как правило, невозможен без решения проблемы комбинаторной сложности, возникающей из-за быстрого роста числа альтернатив. Эффективным средством борьбы с этим служит эвристический поиск.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Один из путей использования эвристической информации о задаче — это получение численных \i эвристических оценок\i0   для вершин пространства состояний. Оценка вершины указывает нам, насколько данная вершина перспективна с точки зрения достижения цели. Идея состоит в том, чтобы всегда продолжать поиск, начиная с наиболее перспективной вершины, выбранной из всего множества кандидатов. Именно на этом принципе основана программа поиска с предпочтением, описанная в данной главе. \par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 12.1. Поиск с предпочтением\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программу поиска с предпочтением можно получить как результат усовершенствования программы поиска в ширину (рис. 11.13). Подобно поиску в ширину, поиск с предпочтением начинается со стартовой вершины и использует множество путей-кандидатов. В то время, как поиск в ширину всегда выбирает для продолжения самый короткий путь (т.е. переходит в вершины наименьшей глубины), поиск с предпочтением вносит в этот принцип следующее усовершенствование: для каждого кандидата вычисляется оценка и для продолжения выбирается кандидат с наилучшей оценкой.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 12.1.\b0   Построение эвристической оценки \i f\i0  (\i n\i0  ) стоимости самого дешевого пути из \i s\i0   в \i t\i0  , проходящего через \i n\i0  : \i f\i0  (\i n\i0  ) = \i g\i0  (\i n\i0  ) \i + h\i0  (\i n\i0  ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы будем в дальнейшем предполагать, что для дуг пространства состояний определена функция стоимости \i с\i0  (\i n\i0  , \i n'\i0  ) — стоимость перехода из вершины \i n\i0    к вершине-преемнику \i n'\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пусть \i f\i0   — это эвристическая оценочная функция, при помощи которой мы получаем для каждой вершины \i n\i0   оценку \i f\i0  (\i n\i0  ) трудности" этой вершины. Тогда наиболее перспективной вершиной-кандидатом следует считать вершину, для которой \i f\i0   принимает минимальное значение. Мы будем использовать здесь функцию \i f\i0   специального вида, приводящую к хорошо известному А*-алгоритму. Функция \i f\i0  (\i n\i0  ) будет построена таким образом, чтобы давать оценку стоимости оптимального решающего пути из стартовой вершины \i s\i0   к одной из целевых вершин при условии, что этот путь проходит через вершину \i n\i0  . Давайте предположим, что такой путь существует и что \i t\i0   — это целевая вершина, для которой этот путь минимален. Тогда оценку \i f\i0  (\i n\i0  ) можно представить в виде суммы из двух слагаемых (рис. 12.1):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  f\i0  (\i n\i0  ) = \i g\i0  (\i n\i0  ) + \i h\i0  (\i n\i0  )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь \i g\i0  (\i n\i0  ) — оценка оптимального пути из \i s\i0   в \i n\i0  ; \i h\i0  (\i n\i0  ) — оценка оптимального пути из \i n\i0   в \i t\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда в процессе поиска мы попадаем в вершину \i n\i0  , мы оказываемся в следующей ситуация: путь из \i s\i0   в \i n\i0   уже найден, и его стоимость может быть вычислена как сумма стоимостей составляющих его дуг. Этот путь не обязательно оптимален (возможно, существует более дешевый, еще не найденный путь из \i s\i0   в \i n\i0  ), однако стоимость этого пути можно использовать в качестве оценки \i g\i0  (\i n\i0  ) минимальной стоимости пути из \i s\i0   в \i n\i0  . Что же касается второго слагаемого \i h\i0  (\i n\i0  ), то о нем трудно что-либо сказать, поскольку к этому моменту область пространства состояний, лежащая между \i n\i0   и \i t\i0  , еще не "изучена" программой поиска. Поэтому, как правило, о значении \i h\i0  (\i n\i0  ) можно только строить догадки на основании эвристических соображений, т.е. на основании тех знаний о конкретной задаче, которыми обладает алгоритм. Поскольку значение \i h\i0   зависит от предметной области, универсального метода для его вычисления не существует. Конкретные примеры того, как строят эти "эвристические догадки", мы приведем позже. Сейчас же будем считать, что тем или иным способом функция \i h\i0   задана, и сосредоточим свое внимание на деталях нашей программы поиска с предпочтением.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно представлять себе поиск с предпочтением следующим образом. Процесс поиска состоит из некоторого числа конкурирующих между собой подпроцессов, каждый из которых занимается своей альтернативой, т.е. просматривает свое поддерево. У поддеревьев есть свои поддеревья, их просматривают подпроцессы подпроцессов и т.д. В каждый данный момент среди всех конкурирующих процессов активен только один — тот, который занимается наиболее перспективной к настоящему моменту альтернативой, т.е. альтернативой с наименьшим значением \i f\i0  . Остальные процессы спокойно ждут того момента, когда \i f\i0  -оценки изменятся и в результате какая-нибудь другая альтернатива станет наиболее перспективной. Тогда производится переключение активности на эту альтернативу. Механизм активации-дезактивации процессов функционирует следующим образом: процесс, работающий над текущей альтернативой высшего приоритета, получает некоторый "бюджет" и остается активным до тех пор, пока его бюджет не исчерпается. Находясь в активном состоянии, процесс продолжает углублять свое поддерево. Встретив целевую вершину, он выдает соответствующее решение. Величина бюджета, предоставляемого процессу на данный конкретный запуск, определяется эвристической оценкой конкурирующей альтернативы, ближайшей к данной.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 12.2.\b0   Поиск кратчайшего маршрута из \i s\i0   в \i t\i0  . (а) Карта со связями между городами; связи помечены своими длинами; в квадратиках указаны расстояния по прямой до цели \i t\i0  . (b) Порядок, в котором при поиске с предпочтением происходит обход городов. Эвристические оценки основаны на расстояниях по прямой. Пунктирной линией показано переключение активности между альтернативными путями. Эта линия задает тот порядок, в котором вершины принимаются для \i продолжения\i0   пути, а не тот порядок, в котором они порождаются.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 12.2 показан пример поведения конкурирующих процессов. Дана карта, задача состоит в том, чтобы найти кратчайший маршрут из стартового города \i s\i0   в целевой город \i t\i0  . В качестве оценки стоимости остатка маршрута из города \i X\i0   до цели мы будем использовать расстояние по прямой \i расст( X, t)\i0   от \i X\i0   до \i t\i0  . Таким образом,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  f( X) = g( X) + h( X) = g( X) + расст( X, t)\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы можем считать, что в данном примере процесс поиска с предпочтением состоит из двух процессов. Каждый процесс прокладывает свой путь — один из двух альтернативных путей: Процесс 1 проходит через \i а\i0  . Процесс 2 — через \i e\i0  . Вначале Процесс 1 более активен, поскольку значения \i f\i0   вдоль выбранного им пути меньше, чем вдоль второго пути. Когда Процесс 1 достигает города \i с\i0  , а Процесс 2 все еще находится в \i e\i0  , ситуация меняется:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  f( с) = g( c) + h( c) = 6 + 4 = 10\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  f( e) = g( e) + h( e) = 2 + 7 = 9\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поскольку \i f( e) < f( c)\i0  , Процесс 2 переходит к \i f\i0  , a Процесс 1 ждет. Однако\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  f( f) = 7 + 4 = 11\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  f( c) = 10\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  f( c) < f( f)\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поэтому Процесс 2 останавливается, а Процессу 1 дается разрешение продолжать движение, но только до \i d\i0  , так как \i f( d) = 12 > 11\i0  . Происходит активация Процесса 2, после чего он, уже не прерываясь, доходит до цели \i t\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы реализуем этот механизм программно при помощи усовершенствования программы поиска в ширину (рис. 11.13). Множество путей-кандидатов представим деревом. Дерево будет изображаться в программе в виде терма, имеющего одну из двух форм:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) л( В, F/G) — дерево, состоящее из одной вершины (листа); В — вершина пространства состояний, G — \i \i g\i0  ( B)\i0   (стоимость уже найденного пути из стартовой вершины в В); F - \i f\i0  ( В) = G + \i h\i0  ( В).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) д( В, F/G, Пд) — дерево с непустыми поддеревьями; В — корень дерева, Пд — список поддеревьев; G — \i \i g\i0  ( B)\i0  ; F —  \i уточненное\i0   значение \i \i f\i0  ( В)\i0  , т.е. значение \i f\i0   для наиболее перспективного преемника вершины В; список Пд упорядочен в порядке возрастания \i f\i0  -оценок поддеревьев.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Уточнение значения \i f\i0   необходимо для того, чтобы дать программе возможность распознавать наиболее перспективное поддерево (т.е. поддерево, содержащее наиболее перспективную концевую вершину) на любом уровне дерева поиска. Эта модификация \i f\i0  -оценок на самом деле приводит к обобщению, расширяющему область определения функции \i f\i0  . Теперь функция \i f\i0   определена не только на вершинах, но и на деревьях. Для одновершинных деревьев (листов) \i n\i0   остается первоначальное определение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  f( n) = g( n) + h( n)\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для дерева \i T\i0   с корнем \i n\i0  , имеющем преемников \i m\i0  \sub 1\nosupersub , \i m\i0  \sub 2\nosupersub , …, получаем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \qc\par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа поиска с предпочтением, составленная в соответствии с приведенными выше общими соображениями, показана на рис 12.3. Ниже даются некоторые дополнительные пояснения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так же, как и в случае поиска в ширину (рис. 11.13), ключевую роль играет процедура расширить, имеющая на этот раз шесть аргументов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( Путь, Дер, Предел, Дер1, ЕстьРеш, Решение)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта процедура расширяет текущее (под)дерево, пока  \i f\i0  -оценка остается равной либо меньшей, чем Предел.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Поиск с предпочтением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 эврпоиск( Старт, Решение) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  макс_f( Fмакс).         % Fмакс > любой  f-оценки\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( [], л( Старт, 0/0), Fмакс, _, да, Решение).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( П, л( В, _ ), _, _, да, [В | П] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( В).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( П, л( В, F/G), Предел, Дер1, ЕстьРеш, Реш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  F <= Предел,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( bagof( B1/C, ( после( В, В1, С), not принадлежит( В1, П)),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Преемники), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  преемспис( G, Преемники, ДД),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  опт_f( ДД, F1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширить( П, д( В, F1/G, ДД), Предел, Дер1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   ЕстьРеш, Реш);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ЕстьРеш = никогда).     % Нет преемников - тупик\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( П, д( В, F/G, [Д | ДД]), Предел, Дер1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ЕстьРеш, Реш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  F <= Предел,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  опт_f( ДД, OF), мин( Предел, OF, Предел1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширить( [В | П], Д, Предел1, Д1, ЕстьРеш1, Реш),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  продолжить( П, д( В, F/G, [Д1, ДД]), Предел, Дер1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ЕстьРеш1, ЕстьРеш, Реш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( _, д( _, _, []), _, _, никогда, _ ) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Тупиковое дерево - нет решений\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( _, Дер, Предел, Дер, нет, _ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  f( Дер, F), F > Предел. % Рост остановлен\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 продолжить( _, _, _, _, да, да, Реш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 продолжить( П, д( В, F/G, [Д1, ДД]), Предел, Дер1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ЕстьРеш1, ЕстьРеш, Реш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( ЕстьРеш1 = нет, встав( Д1, ДД, НДД);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    ЕстьРеш1 = никогда, НДД = ДД),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  опт_f( НДД, F1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширить( П, д( В, F1/G, НДД), Предел, Дер1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   ЕстьРеш, Реш).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преемспис( _, [], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преемспис( G0, [В/С | ВВ], ДД) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  G is G0 + С,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  h( В, H),               % Эвристика h(B)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  F is G + H,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  преемспис( G0, ВВ, ДД1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( л( В, F/G), ДД1, ДД).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Вставление дерева Д в список деревьев ДД с сохранением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % упорядоченности по f-оценкам\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Д, ДД, [Д | ДД] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  f( Д, F), опт_f( ДД, F1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  F =< F1, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Д, [Д1 | ДД], [Д1 | ДД1] ) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д, ДД, ДД1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Получение f-оценки\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( л( _, F/_ ), F).      % f-оценка листа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( д( _, F/_, _ ) F).    % f-оценка дерева\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 опт_f( [Д | _ ], F) :-   % Наилучшая f-оценка для\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  f( Д, F).               % списка деревьев\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 опт_f( [], Fмакс) :-     % Нет деревьев:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  мaкс_f( Fмакс).         % плохая f-оценка\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мин( X, Y, X) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X =< Y, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мин( X, Y, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 12.3.\b0   Программа поиска с предпочтением.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Аргументы процедуры расширить имеют следующий смысл:\par
\par { \trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Путь\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Путь между стартовой вершиной и корнем дерева Дер.\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Дер\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Текущее (под)дерево поиска.\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Предел\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Предельное значение \i f\i0  -оценки, при котором допускается расширение.\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Дер1\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Дерево Дер, расширенное в пределах ограничения Предел; \i f\i0  -оценка дерева Дер1 больше, чем Предел (если только при расширении не была обнаружена целевая вершина).\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ЕстьРеш\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Индикатор, принимающий значения "да", "нет" и "никогда".\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Решение\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Решающий путь, ведущий из стартовой вершины через дерево Дер1 к целевой вершине и имеющий стоимость, не превосходящую ограничение Предел (если такая целевая вершина была обнаружена).\b0\cell

}\row }\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переменные Путь, Дер, и Предел — это "входные" параметры процедуры расширить в том смысле, что при каждом обращении к расширить они всегда конкретизированы. Процедура расширить порождает результаты трех видов. Какой вид результата получен, можно определить по значению индикатора ЕстьРеш следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) ЕстьРеш = да\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решение = решающий путь, найденный при расширении дерева Дер с учетом ограничения Предел.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер1 = неконкретизировано.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) ЕстьРеш = нет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер1 = дерево Дер, расширенное до тех пор, пока его \i f\i0  -оценка не превзойдет Предел (см. рис. 12.4).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решение = неконкретизировано.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) ЕстьРеш = никогда\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер1 и Решение = неконкретизированы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В последнем случае Дер является "тупиковой" альтернативой, и соответствующий процесс никогда не будет реактивирован для продолжения просмотра этого дерева. Случай этот возникает тогда, когда \i f\i0  -оценка дерева Дер не превосходит ограничения Предел, однако дерево не может "расти" потому, что ни один его лист не имеет преемников, или же любой преемник порождает цикл.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Некоторые предложения процедуры расширить требуют пояснений. Предложение, относящееся к наиболее сложному случаю, когда Дер имеет поддеревья, т.е.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер = д( В, F/G, [Д | ДД ] )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает следующее. Во-первых, расширению подвергается наиболее перспективное дерево Д. В качестве ограничения этому дереву выдается не Предел, а некоторое, возможно, меньшее значение Предел1, зависящее от \i f\i0  -оценок других конкурирующих поддеревьев ДД. Тем самым гарантируется, что "растущее" дерево — это всегда наиболее перспективное дерево, а переключение активности между поддеревьями происходит в соответствии с их  \i f\i0  -оценками. После того, как самый перспективный кандидат расширен, вспомогательная процедура продолжить решает, что делать дальше, а это зависит от типа результата, полученного после расширения. Если найдено решение, то оно и выдается, в противном случае процесс расширения деревьев продолжается.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 12.4.\b0   Отношение расширить: расширение дерева Дер до тех пор, пока \i f\i0  -оценка не превзойдет Предел, приводит к дереву Дер1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предложение, относящееся к случаю\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер = л( В, F/G)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 порождает всех преемников вершины В вместе со стоимостями дуг, ведущих в них из В. Процедура преемспис формирует список поддеревьев, соответствующих вершинам-преемникам, а также вычисляет их \i g-\i0   и \i f-\i0  оценки, как показано на рис. 12.5. Затем полученное таким образом дерево подвергается расширению с учетом ограничения Предел. Если преемников нет, то переменной ЕстьРеш придается значение "никогда" и в результате лист В покидается навсегда.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другие отношения:\par
\par { \trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 после( В, В1, С)\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 В1 — преемник вершины В; С — стоимость дуги, ведущей из В в В1.\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 h( В, H)\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 H — эвристическая оценка стоимости оптимального пути из вершины В в целевую вершину.\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 макс_f( Fмакс)\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 Fмакс — некоторое значение, задаваемое пользователем, про которое известно, что оно больше любой возможной \i f\i0  -оценки.\b0\cell

}\row }\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 12.5.\b0   Связь между \i g-\i0  оценкой вершины \i В\i0   и \i f-\i0   и \i g-\i0  оценками ее "детей" в пространстве состояний.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В следующих разделах мы покажем на примерах, как можно применить нашу программу поиска с предпочтением к конкретным задачам. А сейчас сделаем несколько заключительных замечаний общего характера относительно этой программы. Мы реализовали один из вариантов эвристического алгоритма, известного в литературе как А*-алгоритм (ссылки на литературу см. в конце главы). А*-алгоритм привлек внимание многих исследователей. Здесь мы приведем один важный результат, полученный в результате математического анализа А*-алгоритма:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Алгоритм поиска пути называют \i допустимым\i0  , если он всегда отыскивает оптимальное решение (т.е. путь минимальной стоимости) при условии, что такой путь существует. Наша реализация алгоритма поиска, пользуясь механизмом возвратов, выдает все существующие решения, поэтому, в нашем случае, условием допустимости следует считать оптимальность \i первого\i0   из найденных решений. Обозначим через \i h*(n)\i0   стоимость оптимального пути из произвольной вершины \i n\i0   в целевую вершину. Верна следующая теорема о допустимости А*-алгоритма: А*-алгоритм, использующий эвристическую функцию \i h\i0  , является допустимым, если\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 \i  h\i0  (\i n\i0  ) &#8804; \i h\i0  *(\i n\i0  )\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 для всех вершин \i n\i0   пространства состояний.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот результат имеет огромное практическое значение. Даже если нам не известно точное значение \i h\i0  *, нам достаточно найти какую-либо нижнюю грань \i h\i0  * и использовать ее в качестве \i h\i0   в А*-алгоритме — оптимальность решения будет гарантирована.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует тривиальная нижняя грань, а именно:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i h\i0  (\i n\i0  ) = 0,   для всех вершин \i n\i0   пространства состояний.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И при таком значении \i h\i0   допустимость гарантирована. Однако такая оценка не имеет никакой эвристической силы и ничем не помогает поиску. А*-алгоритм при \i h\i0  =0 ведет себя аналогично поиску в ширину. Он, действительно, превращается в поиск в ширину, если, кроме того, положить \i с\i0  (\i n\i0  , \i n'\i0  )=1 для всех дуг (\i n\i0  , \i n'\i0  ) пространства состояний. Отсутствие эвристической силы оценки приводит к большой комбинаторной сложности алгоритма. Поэтому хотелось бы иметь такую оценку \i h\i0  , которая была бы нижней гранью \i h\i0  * (чтобы обеспечить допустимость) и, кроме того, была бы как можно ближе к \i h\i0  * (чтобы обеспечить эффективность). В идеальном случае, если бы нам была известна сама точная оценка \i h\i0  *, мы бы ее и использовали: А*-алгоритм, пользующийся \i h\i0  *, находит оптимальное решение сразу, без единого возврата.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 12.1.\b0   Определите отношения после, цель и h для задачи поиска маршрута рис. 12.2. Посмотрите, как наш алгоритм поиска с предпочтением будет вести себя при решении этой задачи. \par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 12.2. Поиск c предпочтением применительно к головоломке "игра в восемь"\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы хотим применить программу поиска с предпочтением, показанную на  рис. 12.3, к какой-нибудь задаче, мы должны добавить к нашей программе отношения, отражающие специфику этой конкретной задачи. Эти отношения определяют саму задачу ("правила игры"), а также вносят в алгоритм эвристическую информацию о методе ее решения. Эвристическая информация задается в форме эвристической функции.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* Процедуры, отражающие специфику головоломки\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 "игра в восемь".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Текущая ситуация представлена списком положений фишек;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 первый элемент списка соответствует пустой клетке.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пример:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  &#9484;&#9472;&#9472;&#9472;&#9488;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 3&#9474;123&#9474; Эта позиция представляется так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 2&#9474;8 4&#9474; [2/2, 1/3, 2/3, 3/3, 3/2, 3/1, 2/1, 1/1, 1/2]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 1&#9474;765&#9474;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  &#9492;&#9472;&#9472;&#9472;&#9496;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   123\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 "Пусто" можно перемещать в любую соседнюю клетку,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 т.е. "Пусто" меняется местами со своим соседом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 */\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 после( [Пусто | Спис], [Фшк | Спис1], 1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Стоимости всех дуг равны 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перест( Пусто, Фшк, Спис, Спис1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Переставив Пусто и Фшк, получаем СПИС1\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перест( П, Ф, [Ф | С], [П | С] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расст( П, Ф, 1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перест( П, Ф, [Ф1 | С], [Ф1 | C1] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перест( П, Ф, С, C1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расст( X/Y, X1/Y1, P) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Манхеттеновское расстояние между клетками\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расст1( X, X1, Рx),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расст1( Y, Y1, Рy),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  P is Рх + Py.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расст1( А, В, P) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  P is А-В, P >= 0, ! ;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  P is B-A.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Эвристическая оценка h равна сумме расстояний фишек\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % от их "целевых" клеток плюс "степень упорядоченности",\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % умноженная на 3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 h( [ Пусто | Спис], H) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( [Пусто1 | Цспис] ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сумрасст( Спис, ЦСпис, P),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  упоряд( Спис, Уп),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  H is P + 3*Уп.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумрасст( [], [], 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумрасст( [Ф | С], [Ф1 | C1], P) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расст( Ф, Ф1, P1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сумрасст( С, Cl, P2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  P is P1 + Р2.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 упоряд( [Первый | С], Уп) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  упоряд( [Первый | С], Первый, Уп).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 упоряд( [Ф1, Ф2 | С], Первый, Уп) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  очки( Ф1, Ф2, Уп1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  упоряд( [Ф2 | С], Первый, Уп2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Уп is Уп1 + Уп2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 упоряд( [Последний], Первый, Уп) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  очки( Последний, Первый, Уп).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 очки( 2/2, _, 1) :- !. % Фишка в центре - 1 очко\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 очки( 1/3, 2/3, 0) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Правильная последовательность - 0 очков\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 очки( 2/3, 3/3, 0) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 очки( 3/3, 3/2, 0) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 очки( 3/2, 3/1, 0) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 очки( 3/1, 2/1, 0) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 очки( 2/1, 1/1, 0) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 очки( 1/1, 1/2, 0) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 очки( 1/2, 1/3, 0) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 очки( _, _, 2).        % Неправильная последовательность\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 цель( [2/2, 1/3, 2/3, 3/3, 3/2, 3/1, 2/1, 1/1, 1/2] ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Стартовые позиции для трех головоломок\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 старт1( [2/2, 1/3, 3/2, 2/3, 3/3, 3/1, 2/1, 1/1, 1/2] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Требуется для решения 4 шага\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 старт2( [2/1, 1/2, 1/3, 3/3, 3/2, 3/1, 2/2, 1/1, 2/3] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % 5 шагов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 старт3( [2/2, 2/3, 1/3, 3/1, 1/2, 2/1, 3/3, 1/1, 3/2] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % 18 шагов\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Отображение решающего пути в виде списка позиций на доске\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 показреш( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 показреш( [ Поз | Спис] :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  показреш( Спис),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( '---'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  показпоз( Поз).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Отображение позиции на доске\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 показпоз( [S0, S1, S2, S3, S4, S5, S6, S7, S8] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит Y, [3, 2, 1] ),     % Порядок Y-координат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, принадлежит X, [1, 2, 3] ), % Порядок X-координат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Фшк-X/Y,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [' '-S0, 1-S1, 2-S2, 3-S3, 4-S4, 5-S5, 6-S6, 7-S7, 8-S8]),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Фшк),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  fail. %Возврат с переходом к следующей клетке\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 показпоз(_).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 12.6.\b0   Процедуры для головоломки "игра в восемь", предназначенные для использования программой поиска с предпочтением рис. 12.3.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существуют три отношения, отражающих специфику конкретной задачи:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 после( Верш, Верш1, Ст)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это отношение истинно, когда в пространстве состояний существует дуга стоимостью Ст между вершинами Верш и Верш1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 цель( Верш)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это отношение истинно, если Верш — целевая вершина.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 h( Верш, H)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь H — эвристическая оценка стоимости самого дешевого пути из вершины Верш в целевую вершину.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В данном и следующих разделах мы определим эти отношения для двух примеров предметных областей: для головоломки "игра в восемь" (описанной в разделе 11.1) и планирования прохождения задач в многопроцессорной системе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношения для "игры в восемь" показаны на рис. 12.6. Вершина пространства состояний — это некоторая конфигурация из фишек на игровой доске. В программе она задается списком текущих положений фишек. Каждое положение определяется парой координат X/Y. Элементы списка располагаются в следующем порядке:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) текущее положение пустой клетки,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) текущее положение фишки 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) текущее положение фишки 2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 …\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Целевая ситуация (см. рис. 11.3) определяется при помощи предложения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 цель( [2/2, 1/3, 2/3, 3/3, 3/2, 3/1, 2/1, 1/1, 1/2] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имеется вспомогательное отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расст( K1, K2, P)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 P — это "манхеттеновское расстояние" между клетками K1 и K2, равное сумме двух расстояний между K1 и K2: расстояния по горизонтали и расстояния по вертикали.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 12.7.\b0   Три стартовых позиции для "игры в восемь": (а) решение требует 4 шага; (b) решение требует 5 шагов; (с) решение требует 18 шагов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша задача — минимизировать \i длину\i0   решения, поэтому мы положим стоимости всех дуг пространства состояний равными 1. В программе рис. 12. 6. даны также определения трех начальных позиций (см. рис. 12.7).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эвристическая функция \i h\i0  , запрограммирована как отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 h( Поз, H)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поз — позиция на доске; H вычисляется как комбинация из двух оценок:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) сумрасст — "суммарное расстояние" восьми фишек, находящихся в позиции Поз, от их положений в целевой позиции. Например, для начальной позиции, показанной на рис. 12.7(а), сумрасст = 4.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) упоряд — степень упорядоченности фишек в текущей позиции по отношению к тому порядку, в котором они должны находиться в целевой позиции. Величина упоряд вычисляется как сумма очков, приписываемых фишкам, согласно следующим правилам:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  • фишка в центральной позиции — 1 очко;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  • фишка не в центральной позиции, и непосредственно за ней следует (по часовой стрелке) та фишка, какая и должна за ней следовать в целевой позиции — 0 очков.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  • то же самое, но за фишкой следует "не та" фишка — 2 очка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, для начальной позиции рис.12.7(а),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 упоряд = 6.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эвристическая оценка H вычисляется как сумма\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 H = сумрасст + 3 * упоряд\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта эвристическая функция хорошо работает в том смысле, что она весьма эффективно направляет поиск к цели. Например, при решении головоломок   рис. 12.7(а) и (b) первое решение обнаруживается без единого отклонения от кратчайшего решающего пути. Другими словами, кратчайшие решения обнаруживаются сразу, без возвратов. Даже трудная головоломка  рис. 12.7 (с) решается почти без возвратов. Но данная эвристическая функция страдает тем недостатком, что она не является допустимой: нет гарантии, что более короткие пути обнаруживаются раньше более длинных. Дело в том, что для функции \i h\i0   условие \i h \i0  &#8804;\i  h\i0  * выполнено не для всех вершин пространства состояний. Например, для начальной позиции рис. 12.7 (а)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i h\i0   = 4 + 3 * 6 = 22,    \i h\i0  * = 4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С другой стороны, оценка "суммарное расстояние" допустима: для всех позиций\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумрасст &#8804;\i  h\i0  *\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Доказать это неравенство можно при помощи следующего рассуждения: если мы ослабим условия задачи и разрешим фишкам взбираться друг на друга, то каждая фишка сможет добраться до своего целевого положения по траектории, длина которой в точности равна манхеттеновскому расстоянию между ее начальным и целевым положениями. Таким образом, длина оптимального решения упрощенной задачи будет в точности равна сумрасст. Однако в исходном варианте задачи фишки взаимодействуют друг с другом и мешают друг другу, так что им уже трудно идти по своим кратчайшим траекториям. В результате длина оптимального решения окажется больше либо равной сумрасст.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 12.2.\b0   Введите в программу поиска с предпочтением, приведенную на рис. 12.3, подсчет числа вершин, порожденных в процессе поиска. Один из простых способов это сделать — хранить текущее число вершин в виде факта, устанавливаемого при помощи assert. Всегда, когда порождаются новые вершины, уточнять это значение при помощи retract и assert. Проведите эксперименты с различными эвристическими функциями задачи "игра в восемь" с целью оценить их эвристическую силу. Используйте для этого вычисленное количество порожденных вершин. \par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 12.3. Применение поиска с предпочтением к планированию выполнения задач\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим следующую задачу планирования. Дана совокупность \i задач t\i0  \sub 1\nosupersub , \i t\i0  \sub 2\nosupersub , …, имеющих времена выполнения соответственно \i T1\i0  , \i Т2\i0  , …. Все эти задачи нужно решить на  \i m\i0     идентичных процессорах. Каждая задача может быть решена на любом процессоре, но в каждый данный момент каждый процессор решает только одну из задач. Между задачами существует отношение предшествования, определяющее, какие задачи (если таковые есть) должны быть завершены, прежде чем данная задача может быть запущена. Необходимо распределить задачи между процессорами без нарушения отношения предшествования, причем таким образом, чтобы вся совокупность задач была решена за минимальное время. Время, когда последняя задача в соответствии с выработанным планом завершает свое решение, называется \i временем окончания\i0   плана. Мы хотим минимизировать время окончания по всем возможным планам.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 12.8 показан пример задачи планирования, а также приведено два корректных плана, один из которых оптимален. Из примера видно, что оптимальный план обладает одним интересным свойством, а именно в нем может предусматриваться "время простоя" процессоров. В оптимальном плане рис. 12.8 процессор 1, выполнив задачу \i t\i0  , ждет в течение двух квантов времени, несмотря на то, что он мог бы начать выполнение задачи \i t\i0  .\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 12.8.\b0   Планирование прохождения задач в многопроцессорной системе для 7 задач и 3 процессоров. Вверху показано предшествование задач и величины продолжительности их решения. Например, задача \i t\i0  \sub 5\nosupersub  требует 20 квантов времени, причем ее выполнение может начаться только после того, как будет завершено решение трех других задач \i t\i0  \sub 1\nosupersub , \i t\i0  \sub 2\nosupersub  и \i t\sub 3\nosupersub \i0  . Показано два корректных плана: оптимальный план с временем окончания 24 и субоптимальный — с временем окончания 33. В данной задаче любой оптимальный план должен содержать время простоя. Coffman/ Denning, \i Operating Systems Theory\i0  , © 1973, p.86. Приведено с разрешения Prentice-Hall, Englewood Cliffs, New Jersey.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Один из способов построить план можно грубо сформулировать так. Начинаем с пустого плана (с незаполненными временными промежутками для каждого процессора) и постепенно включаем в него задачи одну за другой, пока все задачи не будут исчерпаны. Как правило, на каждом шагу мы будем иметь несколько различных возможностей, поскольку окажется, что одновременно несколько задач-кандидатов ждут своего выполнения. Таким образом, для составления плана потребуется перебор. Мы можем сформулировать задачу планирования в терминах пространства состояний следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • состояния — это частично составленные планы;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • преемник частичного плана получается включением в план еще одной задачи; другая возможность — оставить процессор, только что закончивший свою задачу, в состоянии простоя;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • стартовая вершина — пустой план;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • любой план, содержащий все задачи, — целевое состояние;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • стоимость решения (подлежащая минимизации) — время окончания целевого плана;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • стоимость перехода от одного частичного плана к другому равна \i К\i0  \sub 2\nosupersub –\i К\i0  \sub 1\nosupersub  где \i К\i0  \sub 1\nosupersub , \i К\i0  \sub 2\nosupersub  — времена окончания этих планов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот грубый сценарий требует некоторых уточнений. Во-первых, мы решим заполнять план в порядке возрастания времен, так что задачи будут включаться в него слева направо. Кроме того, при добавлении каждой задачи следует проверять, выполнены ли ограничения, связанные с отношениями предшествования. Далее, не имеет смысла оставлять процессор бездействующим на неопределенное время, если имеются задачи, ждущие своего запуска. Поэтому мы разрешим процессору простаивать только до того момента, когда какой-нибудь другой процессор завершит выполнение своей задачи. В этот момент мы еще раз вернемся к свободному процессору с тем, чтобы рассмотреть возможность приписывания ему какой-нибудь задачи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь нам необходимо принять решение относительно представления проблемных ситуаций, т.е. частичных планов. Нам понадобится следующая информация:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) список ждущих задач вместе с их временами выполнения;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) текущая загрузка процессоров задачами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Добавим также для удобства программирования\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) время окончания (частичного) плана, т.е. самое последнее время окончания задачи среди всех задач, приписанных процессорам.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список ждущих задач вместе с временами их выполнения будем представлять в программе при помощи списка вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ Задача1/Т1, Задача2/Т2, ... ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Текущую загрузку процессоров будем представлять как список решаемых задач, т.е. список пар вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ Задача/ВремяОкончания ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В списке \i m\i0   таких пар, по одной на каждый процессор. Новая задача будет добавляться к плану в момент, когда закончится первая задача из этого списка. В связи с этим мы должны постоянно поддерживать упорядоченность списка загрузки по возрастанию времен окончания. Эти три компоненты частичного плана (ждущие задачи, текущая загрузка и время окончания плана) будут объединены в одно выражение вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ждущие * Активные * ВремяОкончания\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Кроме этой информации у нас есть ограничения, налагаемые отношениями предшествования, которые в программе будут выражены в форме отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 предш( ЗадачаX, ЗадачаY)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим теперь эвристическую оценку. Мы будем использовать довольно примитивную эвристическую функцию, которая не сможет обеспечить высокую эффективность управления алгоритмом поиска. Эта функция допустима, так что получение оптимального плана будет гарантировано. Однако следует заметить, что для решения более серьезных задач планирования потребуется более мощная эвристика.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нашей эвристической функцией будет оптимистическая оценка времени окончания частичного плана с учетом всех ждущих задач. Оптимистическая оценка будет вычисляться в предположении, что два из ограничений, налагаемых на действительно корректный план, ослаблены:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) не учитываются отношения предшествования;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) делается (не реальное) допущение, что возможно распределенное выполнение задачи одновременно на нескольких процессорах, причем сумма времен выполнения задачи на процессорах равна исходному времени выполнения этой задачи на одном процессоре.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пусть времена выполнения ждущих задач равны \i Т\i0  \sub 1\nosupersub , \i Т\i0  \sub 2\nosupersub , …, а времена окончания задач, выполняемых на процессорах — \i К\i0  \sub 1\nosupersub , \i К\i0  \sub 2\nosupersub , …. Тогда оптимистическая оценка времени \i ОбщКон\i0   окончания всех активных к настоящему моменту, а также всех ждущих задач имеет вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \qc\par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где \i m\i0   — число процессоров. Пусть время окончания текущего частичного плана равно\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \qc\par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда эвристическая оценка \i H\i0   (дополнительное время для включения в частичный план ждущих задач) определяется следующим выражением:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 if \i ОбщКон>Кон\i0   then \i H = ОбщКон-Кон\i0   else \i H=\i0  0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа, содержащая определения отношений, связанных с пространством состояний нашей задачи планирования, приведена полностью на рис. 12.9. Эта программа включает в себя также спецификацию конкретной задачи планирования, показанной на рис. 12.3. Одно из оптимальных решений, полученных в процессе поиска с предпочтением в определенном таким образом пространстве состояний, показано на рис. 12.8.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* Отношения для задачи планирования.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вершины пространства состояний - частичные планы,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 записываемые как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ Задача1/Т1, Задача2/Т2, ...]*\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ Задача1/К1, Задача2/К2, ...]* ВремяОкончания\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В первом списке указываются ждущие задачи и продолжительности их выполнения; во втором - текущие решаемые задачи и их времена окончания, упорядоченные так, чтобы выполнялись неравенства K1&#8804;K2, K2&#8804;K3, ... .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Время окончания плана - самое последнее по времени время окончания задачи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 */\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 после( Задачи1*[ _ /К | Акт1]*Кон1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Задачи2*Акт2*Кон2, Ст):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( Задача/T, Задачи1, Задачи2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Взять ждущую задачу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not( принадлежит( Здч1/_, Задачи2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  раньше( ЗДЧ, Задача) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Проверить предшествование\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not( принадлежит( Здч1/К1, Акт1), К1<К2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  раньше( К1, Задача) ),    % Активные задачи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Время is К + T,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Время окончания работающей задачи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( ЗадачаВремя, Акт1, Акт2, Кон1, Кон2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Ст is Кон2 - Кон1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 после( Задачи*[ _ /К | Акт1]*Кон, Задачи2*Акт2*Кон, 0):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вставпростой( К, Акт1, Акт2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Оставить процессор бездействующим\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 раньше( Задача1, Задача2) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % В соответствии с предшествованием\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предш( Задача1, Задача2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Задача1 раньше, чем Задача2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 раньше( Здч1, Здч2) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предш( Здч, Здч2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  раньше( Здч1, Здч).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Здч/А, [Здч1/В | Спис], [Здч/А, Здч1/В | Спис], К, К):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Список задач упорядочен\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  А =< В, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Здч/А, [Здч1/В | Спнс], [Здч1/В | Спис1], К1, К2) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Здч/А, Спис, Спис1, Kl, К2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Здч/А, [ ], [Здч/А], _, А).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вставпростой( А, [Здч/В | Спис], [простой/В, Здч/В | Спис]):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0            % Оставить процессор бездействующим\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  А < В, !. % До ближайшего времени окончания\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вставпростой( А, [Здч/В | Спис], [Здч/В | Спис1]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вставпростой( А, Спис, Спис1 ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( А, [А | Спис], Спис ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Удалить элемент из списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( А, [В | Спис], [В | Спис1] ):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( А, Спис, Спис1 ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 цель( [] *_*_ ). % Целевое состояние: нет ждущих задач\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Эвристическая оценка частичного плана основана на\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % оптимистической оценке последнего времени окончания\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % этого частичного плана,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % дополненного всеми остальными ждущими задачами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 h( Задачи * Процессоры * Кон, H) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сумвремя( Задачи, СумВремя),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Суммарная продолжительность\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % ждущих задач\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  всепроц( Процессоры, КонВремя, N),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % КонВремя - сумма времен окончания\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % для процессоров, N - их количество\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ОбщКон is ( СумВремя + КонВремя)/N,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( ОбщКон > Кон, !, H is ОбщКон - Кон; H = 0).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумвремя( [], 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумвремя( [ _ /T | Задачи], Вр) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сумвремя( Задачи, Вр1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Вр is Bp1 + T.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 всепроц( [], 0, 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 всепроц( [ _ /T | СписПроц], КонВр, N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  всепроц( СписПроц, КонВр1, N1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N is N1 + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  КонВр is КонВр1 + T.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Граф предшествования задач\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предш( t1, t4). предш( t1, t5). предш( t2, t4).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предш( t2, t5). предш( t3, t5). предш( t3, t6).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предш( t3, t7).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Стартовая вершина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 старт( [t1/4, t2/2, t3/2, t4/20, t5/20, t6/11, t7/11] *\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [простой/0, простой/0, простой/0] * 0 ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 12.9.\b0   Отношения для задачи планирования. Даны также определения отношений для конкретной задачи планирования с рис. 12.8: граф предшествования и исходный (пустой) план в качестве стартовой вершины.\par
\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Проект\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вообще говоря, задачи планирования характеризуются значительной комбинаторной сложностью. Наша простая эвристическая функция не обеспечивает высокой эффективности управления поиском. Предложите другие эвристические функции и проведите с ними эксперименты.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Для оценки степени удаленности некоторой вершины пространства состояний от ближайшей целевой вершины можно использовать эвристическую информацию. В этой главе были рассмотрены численные эвристические оценки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Эвристический принцип поиска с предпочтением направляет процесс поиска таким образом, что для продолжения поиска всегда выбирается вершина, наиболее перспективная с точки зрения эвристической оценки.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В этой главе был запрограммирован алгоритм поиска, основанный на указанном принципе и известный в литературе как А*-алгоритм.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Для того, чтобы решить конкретную задачу при помощи А*-алгоритма, необходимо определить пространство состояний и эвристическую функцию. Для сложных задач наиболее трудным моментом является подбор хорошей эвристической функции.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Теорема о допустимости\i0   помогает установить, всегда ли А*-алгоритм, использующий некоторую конкретную эвристическую функцию, находит оптимальное решение.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа поиска с предпочтением, представленная в настоящей главе, — это один из многих вариантов похожих друг на друга программ, из которых А*-алгоритм наиболее популярен. Общее описание А*-алгоритма можно найти в книгах Nillson (1971, 1980) или Winston (1984). Теорема о допустимости впервые доказана авторами статьи Hart, Nilsson, and Raphael (1968). Превосходное и строгое изложение многих разновидностей алгоритмов поиска с предпочтением и связанных с ними математических результатов дано в книге Pearl (1984). В статье Doran and Michie (1966) впервые изложен поиск с предпочтением, управляемый оценкой расстояния до цели.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Головоломка "игра в восемь" использовалась многими исследователями в области искусственного интеллекта в качестве тестовой задачи при изучении эвристических принципов (см., например, Doran and Michie (1966), Michie and Ross (1970) и Gaschnig (1979)).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задача планирования, рассмотренная в настоящей главе, также как и многие ее разновидности, возникает во многих прикладных областях в ситуации, когда необходимо спланировать обслуживание запросов на ресурсы. Один из примеров — операционные системы вычислительных машин. Задача планирования со ссылкой на это конкретное приложение изложена в книге Coffman and Denning (1973).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Найти хорошую эвристику — дело важное и трудное, поэтому изучение эвристик — одна из центральных тем в искусственном интеллекте. Существуют, однако, некоторые границы, за которые невозможно выйти, двигаясь в направлении улучшения качества эвристик. Казалось бы, все, что необходимо для эффективного решения комбинаторной задачи — это найти мощную эвристику. Однако есть задачи (в том числе многие задачи планирования), для которых не существует универсальной эвристики, обеспечивающей во всех случаях как эффективность, так и допустимость. Многие теоретические результаты, имеющие отношение к этому ограничению, собраны в работе Garey and Johnson (1979).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Coffman E.G. and Denning P.J. (1973). \i Operating Systems Theory.\i0   Prentice-Hall.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Doran J. and Michie D. (1966). Experiments with the graph traverser program. \i Proc. Royal Socieiy of London\i0   \b 294(A)\b0  : 235-259.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Garey M. R. and Johnson D. S. (1979). \i Computers and Intractability\i0  . W. H. Freeman. [Имеется перевод: Гэри M., Джонсон Д. С- Вычислительные машины и труднорешаемые задачи. — M.: Мир, 1982.]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Gaschnig J. (1979). Performance measurement and analysis of certain search algorithms. Carnegie-Mellon University: Computer Science Department-Technical Report CMU-CS-79-124 (Ph. D. Thesis).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Hart P.E., Nilsson N.J. and Raphael B. (1968). A formal basis for the heuristic determination of minimum cost paths. \i IEEE Transactions on Systems Sciences and Cybernetics\i0   \b SSC-4(2)\b0  :100-107\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Michie D. and Ross R. (1970). Experiments with the adaptive graph traverser. \i Machine Intelligence\i0   \b 5\b0  : 301–308.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Nilsson N.J. (1971). \i Problem — Solving Methods in Artificial Intelligence\i0  . McGraw-Hill. [Имеется перевод: Нильсон H. Искусственный интеллект. Методы поиска решений. — M: Мир, 1973.]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Nilsson N. J. (1980). \i Principles of Artificial Intelligence\i0  . Tioga; also Springer-Verlag.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Pearl J. (1984). \i Heuristics: Intelligent Search Strategies for Computer Problem Solving\i0  . Addison-Wesley.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Winston P. H. (1984). \i Artificial Intelligence\i0   (second edition). Addison-Wesley. [Имеется перевод первого издания: Уинстон П. Искусственный интеллект. — M.: Мир, 1980.]\par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 13\par
Сведение задач к подзадачам. И/ИЛИ-Графы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Представление в виде И/ИЛИ-графов наиболее хорошо приспособлено для задач, которые естественным образом разбиваются на взаимно независимые подзадачи. Примерами таких задач могут служить поиск маршрута, символическое интегрирование, а также игровые задачи, доказательство теорем и т.п. В этой главе мы разработаем программы для поиска в И/ИЛИ-графах, в том числе программу поиска с предпочтением, управляемого эвристиками.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 13.1. Представление задач в виде И/ИЛИ-графов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В главах 11 и 12, говоря о решении задач, мы сконцентрировали свое внимание на пространстве состояний как средстве представления этих задач. В соответствии с таким подходом решение задач сводилось к поиску пути в графе пространства состояний. Однако для некоторых категорий задач представление в форме И/ИЛИ-графа является более естественным. Такое представление основано на разбиении задач на подзадачи. Разбиение на подзадачи дает преимущества в том случае, когда подзадачи взаимно независимы, а, следовательно, и решать их можно независимо друг от друга.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проиллюстрируем это на примере. Рассмотрим задачу отыскания на карте дорог маршрута между двумя заданными городами, как показано на рис. 13.1. Не будем пока учитывать длину путей. Разумеется, эту задачу можно сформулировать как поиск пути в пространстве состояний. Соответствующее пространство состояний выглядело бы в точности, как карта рис. 13.1: вершины соответствуют городам, дуги — непосредственным связям между городами. Тем не менее давайте построим другое представление, основанное на естественном разбиении этой задачи на подзадачи.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.1.\b0   Поиск маршрута из \i а\i0   в \i z\i0   на карте дорог. Через реку можно переправиться в городах \i f\i0   и \i g\i0  . И/ИЛИ-представление этой задачи показано на рис. 13.2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На карте рис. 13.1 мы видим также реку. Допустим, что переправиться через нее можно только по двум мостам: один расположен в городе \i f\i0  , другой — в городе \i g\i0  . Очевидно, что искомый маршрут обязательно должен проходить через один из мостов, а значит, он должен пройти либо через \i f\i0  , либо через \i g\i0  . Таким образом, мы имеем две главных альтернативы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы найти путь из \i а\i0   в \i z\i0  , необходимо найти \i одно из двух\i0  :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) путь из \i а\i0   в \i z\i0  , проходящий через \i f\i0  , или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) путь из \i а\i0   в \i z\i0  , проходящий через  \i g\i0  .\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.2.\b0   И/ИЛИ-представление задачи поиска маршрута рис. 13.1. Вершины соответствуют задачам или подзадачам, полукруглые дуги означают, что все (точнее, обе) подзадачи должны быть решены.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь каждую из этих двух альтернативных задач можно, в свою очередь, разбить следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Для того, чтобы найти путь из \i a\i0   в \i z\i0   через \i f\i0  , необходимо:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    1.1 найти путь из \i а\i0   и \i f  и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    1.2 найти путь из \i f\i0   в \i z\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Для того, чтобы найти путь из \i a\i0   в \i z\i0   через \i g\i0  , необходимо:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    2.1 найти путь из \i а\i0   в \i g  и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    2.2 найти путь из \i g\i0   в \i z\i0  .\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.3.\b0   (а) Решить P — это значит решить  P\sub 1\nosupersub  или Р\sub 2\nosupersub  или … (б) Решить Q — это значит решить все: Q\sub 1\nosupersub  и Q\sub 2\nosupersub  и ….\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак, мы имеем две главных альтернативы для решения исходной задачи: (1) путь через \i f\i0   или (2) путь через \i g\i0  . Далее, каждую из этих альтернатив можно \i разбить на подзадачи\i0   (1.1 и 1.2 или 2.1 и 2.2 соответственно). Здесь важно то обстоятельство, что каждую из подзадач в обоих альтернативах можно решать независимо от другой. Полученное разбиение исходной задачи можно изобразить в форме \i И/ИЛИ-графа\i0   (рис. 13.2). Обратите внимание на полукруглые дуги, которые указывают на отношение И между соответствующими подзадачами. Граф, показанный на рис. 13.2 — это всего лишь верхняя часть всего И/ИЛИ-дерева. Дальнейшее разбиение подзадач можно было бы строить на основе введения дополнительных промежуточных городов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Какие вершины  И/ИЛИ-графа  являются целевыми? Целевые вершины — это тривиальные, или "примитивные" задачи. В нашем примере такой подзадачей можно было бы считать подзадачу "найти путь из \i а\i0   в \i с\i0  ", поскольку между городами \i а\i0   и \i с\i0   на карте имеется непосредственная связь.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассматривая наш пример, мы ввели ряд важных понятий. И/ИЛИ-граф — это направленный граф, вершины которого соответствуют задачам, а дуги — отношениям между задачами. Между дугами также существуют свои отношения. Это отношения И и ИЛИ, в зависимости от того, должны ли мы решить только одну из задач-преемников или же несколько из них (см. рис. 13.3). В принципе из вершины могут выходить дуги, находящиеся в отношении И вместе с дугами, находящимися в отношении ИЛИ. Тем не менее, мы будем предполагать, что каждая вершина имеет либо только И-преемников, либо только ИЛИ-преемников; дело в том, что в такую форму можно преобразовать любой И/ИЛИ граф, вводя в него при необходимости вспомогательные ИЛИ-вершины. Вершину, из которой выходят только И-дуги, называют И-вершиной; вершину, из которой выходят только ИЛИ-дуги, — ИЛИ-вершиной.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда задача представлялась в форме пространства состояний, ее решением был путь в этом пространстве. Что является решением в случае И/ИЛИ-представления? Решение должно, конечно, включать в себя все подзадачи И-вершины. Следовательно, это уже не путь, а дерево. Такое решающее дерево T определяется следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • исходная задача P — это корень дерева T;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • если P является ИЛИ-вершиной, то в T содержится только один из ее преемников (из И/ИЛИ-графа) вместе со своим собственным решающим деревом;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • если P — это И-вершина, то все ее преемники (из И/ИЛИ-графа) вместе со своими решающими деревьями содержатся в T.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.4.\b0   (а) Пример И/ИЛИ-графа: \i d\i0  , \i g\i0   и \i h\i0   — целевые вершины; \i a\i0   — исходная задача. (b) и (с) Два решающих дерева, стоимости которых равны 9 и 8 соответственно. Здесь стоимость решающего дерева определена как сумма стоимостей всех входящих в него дуг.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Иллюстрацией к этому определению может служить рис. 13.4. Используя стоимости, мы можем формулировать критерии оптимальности решения. Например, можно определить стоимость решающего графа как сумму стоимостей всех входящих в него дуг. Тогда, поскольку обычно мы заинтересованы в минимизации стоимости, мы отдадим предпочтение решающему графу, изображенному на рис. 13.4(с).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако мы не обязательно должны измерять степень оптимальности решения, базируясь на стоимостях дуг. Иногда более естественным окажется приписывать стоимость не дугам, а вершинам, или же и тем, и другим одновременно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Подведем итоги:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • И/ИЛИ-представление основано на философии сведения задач к подзадачам.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Вершины И/ИЛИ-графа соответствуют задачам; связи между вершинами — отношениям между задачами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Вершина, из которой выходят ИЛИ-связи, называется ИЛИ-вершиной. Для того, чтобы решить соответствующую задачу, нужно решить одну из ее задач-преемников.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Вершина, из которой выходят И-связи, называется И-вершиной. Для того, чтобы решить соответствующую задачу, нужно решить все ее задачи-преемники.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • При заданном И/ИЛИ-графе конкретная задача специфицируется заданием\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   стартовой вершины и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   целевого условия для распознавания\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   целевых вершин.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Целевые вершины\i0   (или "терминальные вершины") соответствуют тривиальным (или "примитивным") задачам.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Решение представляется в виде \i решающего графа\i0   — подграфа всего И/ИЛИ-графа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Представление задач в форме пространства состояний можно рассматривать как специальный частный случай И/ИЛИ-представления, когда все вершины И/ИЛИ-графа являются ИЛИ-вершинами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • И/ИЛИ-представление имеет преимущество в том случае, когда вершинами, находящимися в отношении И, представлены подзадачи, которые можно решать независимо друг от друга. Критерий независимости можно несколько ослабить, а именно потребовать, чтобы существовал такой порядок решения И-задач, при котором решение более "ранних" подзадач не разрушалось бы при решении более "поздних" под задач.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Дугам или вершинам, или и тем, и другим можно приписать стоимости с целью получить возможность сформулировать критерий оптимальности решения.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 13.2. Примеры И/ИЛИ-представления задач \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 13.2.1. И/ИЛИ-представление задачи поиска маршрута\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для задачи отыскания кратчайшего маршрута (рис. 13.1) И/ИЛИ-граф вместе с функцией стоимости можно определить следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • ИЛИ-вершины представляются в форме X-Z, что означает: найти кратчайший путь из X в Z.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • И-вершины имеют вид \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   X-Z через Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 что означает: найти кратчайший путь из X в Z, проходящий через Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Вершина X-Z является целевой вершиной (примитивной задачей), если на карте существует непосредственная связь между X и Z.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Стоимость каждой целевой вершины X-Z равна расстоянию, которое необходимо  преодолеть по дороге, соединяющей X с Z.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Стоимость всех остальных (нетерминальных) вершин равна 0.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Стоимость решающего графа равна сумме стоимостей всех его вершин (в нашем случае это просто сумма стоимостей всех терминальных вершин). В задаче рис. 13.1 стартовая вершина — это \i а-z\i0  . На рис. 13.5 показан решающий граф, имеющий стоимость 9. Это дерево соответствует пути [a, b, d, f, i, z], который можно построить, если пройти по всем листьям решающего дерева слева направо.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.5.\b0   Решающее дерево минимальной стоимости для задачи поиска маршрута рис. 13.1, сформулированной в терминах И/ИЛИ-графа. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 13.2.2. Задача о ханойской башне\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задача о ханойской башне (рис. 13.6) — это еще один классический пример эффективного применения метода разбиения задачи на подзадачи и построения И / ИЛИ-графа. Для простоты мы рассмотрим упрощенную версию этой задачи, когда в ней участвует только три диска:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имеется три колышка 1, 2 и 3 и три диска \i а\i0  , \i b\i0   и \i с\i0   (\i а\i0   — наименьший из них, а \i с\i0   — наибольший). Первоначально все диски находятся на колышке 1. Задача состоит в том, чтобы переложить все диски на колышек 3. На каждом шагу можно перекладывать только один диск, причем никогда нельзя помещать больший диск на меньший.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эту задачу можно рассматривать как задачу достижения следующих трех целей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Диск \i а\i0   — на колышек 3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Диск \i b\i0   — на колышек 3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Диск \i с\i0   — на колышек 3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Беда в том, что эти цели не независимы. Например, можно сразу переложить диск \i а\i0   на колышек 3, и первая цель будет достигнута. Но тогда две другие цели станут недостижимыми (если только мы не отменим первое наше действие). К счастью, существует такой удобный порядок достижения этих целей, из которого можно легко вывести искомое решение.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.6.\b0   Задача о ханойской башне\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Порядок этот можно установить при помощи следующего рассуждения: самая трудная цель — это цель 3 (диск \i с\i0   — на колышек 3), потому что на диск \i c\i0   наложено больше всего ограничений. В подобных ситуациях часто срабатывает хорошая идея: пытаться достичь первой самую трудную цель. Этот принцип основан на следующей логике: поскольку другие цели достигнуть легче (на них меньше ограничений), можно надеяться на то, что их достижение возможно без отмены действий на достижение самой трудной цели.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Применительно к нашей задаче это означает, что необходимо придерживаться следующей стратегии:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Первой достигнуть цель "диск \i с\i0   — на колышек 3", а затем — все остальные.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Но первая цель не может быть достигнута сразу, так как в начальной ситуации диск \i с\i0   двигать нельзя. Следовательно, сначала мы должны подготовить этот ход, и наша стратегия принимает такой вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Обеспечить возможность перемещения диска \i с\i0   с 1 на 3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Переложить \i с\i0   с 1 на 3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Достигнуть остальные цели (\i а\i0   на 3 и \i b\i0   на 3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Переложить \i c\i0   с 1 на 3 возможно только в том случае, если диск \i а\i0   и \i b\i0   оба надеты на колышек 2. Таким образом наша исходная задача перемещения \i а\i0  , \i b\i0   и \i с\i0   с 1 на 3 сводится к следующим трем подзадачам:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы переложить \i a\i0  , \i b\i0   и \i с\i0   с 1 на 3, необходимо\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) переложить \i а\i0   и \i b\i0   с 1 на 2, \i и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) переложить \i с\i0   с 1 на 3, \i и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) переложить \i а\i0   и \i b\i0   с 2 на 3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задача 2 тривиальна (она решается за один шаг). Остальные две подзадачи можно решать независимо от задачи 2, так как диски \i а\i0   и \i b\i0   можно двигать, не обращая внимание на положение диска \i с\i0  . Для решения задач 1 и 3 можно применить тот же самый принцип разбиения (на этот раз диск \i b\i0   будет самым "трудным"). В соответствии с этим принципом задача 1 сводится к трем тривиальным подзадачам:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы переложить \i а\i0   и \i b\i0   с 1 на 2, необходимо:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) переложить \i а\i0   с 1 на 3, \i и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) переложить \i b\i0   с 1 на 2, \i и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) переложить \i а\i0   с 3 на 2.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 13.2.3. Формулировка игровых задач в терминах И/ИЛИ-графов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такие игры, как шахматы или шашки, естественно рассматривать как задачи, представленные И/ИЛИ-графами. Игры такого рода называются играми двух лиц с полной информацией. Будем считать, что существует только два возможных исхода игры: ВЫИГРЫШ и ПРОИГРЫШ. (Об играх с тремя возможными исходами — ВЫИГРЫШ, ПРОИГРЫШ и НИЧЬЯ, можно также говорить, что они имеют только два исхода: ВЫИГРЫШ и НЕВЫИГРЫШ). Так как участники игры ходят по очереди, мы имеем два вида позиций, в зависимости от того, чей ход. Давайте условимся называть участников игры "игрок" и "противник", тогда мы будем иметь следующие два вида позиций: позиция с ходом игрока ("позиция игрока") и позиция с ходом противника ("позиция противника"). Допустим также, что начальная позиция \i P\i0   — это позиция игрока. Каждый вариант хода игрока в этой позиции приводит к одной из позиций противника  \i Q\i0  \sub 1\nosupersub , \i Q\i0  \sub 2\nosupersub , \i Q\i0  \sub 3\nosupersub , … (см. рис. 13.7). Далее каждый вариант хода противника в позиции \i Q\i0  \sub 1\nosupersub  приводит к одной из позиций игрока \i R\i0  \sub 11\nosupersub , \i R\i0  \sub 12\nosupersub , …. В  И/ИЛИ-дереве, показанном на рис. 13.7, вершины соответствуют позициям, а дуги — возможным ходам. Уровни позиций игрока чередуются в дереве с уровнями позиций противника. Для того, чтобы выиграть в позиции \i P\i0  , нужно найти ход, переводящий \i P\i0   в выигранную позицию \i Q\sub i\nosupersub \i0  . (при некотором \i i\i0  ). Таким образом, игрок выигрывает в позиции \i P\i0  , если он выигрывает в \i Q\sub 1\nosupersub \i0  , \i или  Q\sub 2\nosupersub \i0  , \i или  Q\sub 3\nosupersub \i0  , \i или\i0   …. Следовательно, \i P\i0   — это ИЛИ-вершина. Для любого \i i\i0   позиция  \i Q\sub i\nosupersub \i0   — это позиция противника, поэтому если в этой позиции выигрывает игрок, то он выигрывает и после каждого варианта хода противника. Другими словами, игрок выигрывает в \i Q\sub i\nosupersub \i0  , если он выигрывает во всех позициях \i R\sub i1\nosupersub  и R\sub i2\nosupersub  и\i0   ….  Таким образом, все позиции противника — это И-вершины. Целевые вершины — это позиции, выигранные согласно правилам игры, например позиции, в которых король противника получает мат. Позициям проигранным соответствуют задачи, не имеющие решения. Для того, чтобы решить игровую задачу, мы должны построить решающее дерево, гарантирующее победу игрока независимо от ответов противника. Такое дерево задает полную стратегию достижения выигрыша: для каждого возможного продолжения, выбранного противником, в дереве стратегии есть ответный ход, приводящий к победе.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.7.\b0   Формулировка игровой задачи для игры двух лиц в форме И/ИЛИ-дерева; участники игры: "игрок" и "противник".\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 13.3. Базовые процедуры поиска в И/ИЛИ-графах\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом разделе нас будет интересовать \i какое-нибудь\i0   решение задачи независимо от его стоимости, поэтому проигнорируем пока стоимости связей или вершин И/ИЛИ-графа. Простейший способ организовать поиск в И/ИЛИ-графах средствами Пролога — это использовать переборный механизм, заложенный в самой пролог-системе. Оказывается, что это очень просто сделать, потому что процедурный смысл Пролога это и есть не что иное, как поиск в И/ИЛИ-графе. Например, И/ИЛИ-граф рис. 13.4 (без учета стоимостей дуг) можно описать при помощи следующих предложений:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а :- b.    % а - ИЛИ-вершина с двумя преемниками\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а :- с.    % b и  с\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 b :- d, e. % b - И-вершина с двумя преемниками d и e\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 с :- h.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 с :- f, g.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f :- h, i.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 d. g. h.   % d, g и h - целевые вершины\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы узнать, имеет ли эта задача решение, нужно просто спросить:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- а.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Получив этот вопрос, пролог-система произведет поиск в глубину в дереве рис. 13.4 и после того, как пройдет через все вершины подграфа, соответствующего решающему дереву рис. 13.4(b), ответит "да".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Преимущество такого метода программирования И/ИЛИ-поиска состоит в его простоте. Но есть и недостатки:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Мы получаем ответ "да" или "нет", но не получаем решающее дерево. Можно было бы восстановить решающее дерево при помощи трассировки программы, но такой способ неудобен, да его и недостаточно, если мы хотим иметь возможность явно обратиться к решающему дереву как к объекту программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В эту программу трудно вносить добавления, связанные с обработкой стоимостей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Если наш И/ИЛИ-граф — это граф общего вида, содержащий циклы, то пролог-система, следуя стратегии в глубину, может войти в бесконечный рекурсивный цикл.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Попробуем постепенно исправить эти недостатки. Сначала определим нашу собственную процедуру поиска в глубину для И/ИЛИ-графов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде всего мы должны изменить представление И/ИЛИ-графов. С этой целью введём бинарное отношение, изображаемое инфиксным оператором '--->'. Например, вершина \i а\i0   с двумя ИЛИ-преемниками будет представлена предложением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а ---> или : [b, с].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оба символа '--->' и ':' — инфиксные операторы, которые можно определить как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 600, xfx, --->).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 500, xfx, :).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Весь И/ИЛИ-граф рис. 13.4 теперь можно задать при помощи множества предложений\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а ---> или : [b, с].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 b ---> и : [d, e].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 с ---> и : [f, g].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 e ---> или : [h].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f ---> или : [h, i].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 цель( d). цель( g). цель( h).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедуру поиска в глубину в И/ИЛИ-графах можно построить, базируясь на следующих принципах:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы решить задачу вершины В, необходимо придерживаться приведенных ниже правил:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Если  В — целевая вершина, то задача решается тривиальным образом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Если вершина В имеет ИЛИ-преемников, то нужно решить одну из соответствующих задач-преемников (пробовать решать их одну за другой, пока не будет найдена задача, имеющая решение).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Если вершина В имеет И-преемников, то нужно решить все соответствующие задачи (пробовать решать их одну за другой, пока они не будут решены все).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если применение этих правил не приводит к решению, считать, что задача не может быть решена.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Соответствующая программа выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Верш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( Верш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Верш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Верш ---> или : Вершины, % Верш - ИЛИ-вершина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Верш1, Вершины),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Выбор преемника  Верш1  вершины  Верш\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решить( Bepш1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Верш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Верш ---> и : Вершины,   % Верш - И-вершина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решитьвсе( Вершины).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Решить все задачи-преемники\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решитьвсе( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решитьвсе( [Верш | Вершины]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решить( Верш),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решитьвсе( Вершины).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь принадлежит — обычное отношение принадлежности к списку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта программа все еще имеет недостатки:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • она не порождает решающее дерево, и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • она может зацикливаться, если И/ИЛИ-граф имеет соответствующую структуру (циклы).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программу нетрудно изменить с тем, чтобы она порождала решающее дерево. Необходимо так подправить отношение решить, чтобы оно имело два аргумента:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Верш, РешДер).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Решающее дерево представим следующим образом. Мы имеем три случая:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Если Верш — целевая вершина, то соответствующее решающее дерево и есть сама эта вершина.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Если Верш — ИЛИ-вершина, то решающее дерево имеет вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Верш ---> Поддерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Поддерево — это решающее дерево для одного из преемников вершины Верш.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Если Верш — И-вершина, то решающее дерево имеет вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Верш ---> и : Поддеревья\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Поддеревья — список решающих деревьев для всех преемников вершины Верш.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Поиск в глубину для И/ИЛИ-графов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Процедура решить( Верш, РешДер) находит решающее дерево для\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % некоторой вершины в И / ИЛИ-графе\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Верш, Верш) :-    % Решающее дерево для целевой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( Верш).             % вершины - это сама вершина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Верш, Верш ---> Дер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Верш ---> или : Вершины, % Верш - ИЛИ-вершина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Верш1, Вершины),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Выбор преемника  Верш1  вершины  Верш\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решить( Bepш1, Дер).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Верш, Верш ---> и : Деревья) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Верш ---> и : Вершины,   % Верш - И-вершина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решитьвсе( Вершины, Деревья).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Решить все задачи-преемники\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решитьвсе( [], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решитьвсе( [Верш | Вершины], [Дер | Деревья]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решить( Верш, Дер),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решитьвсе( Вершины, Деревья).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( Дер) :-            % Отобразить решающее дерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Дер, 0), !.       % с отступом 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( Верш ---> Дер, H) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Отобразить решающее дерево с отступом H\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Верш), write( '--->'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  H1 is H + 7,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Дер, H1), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( и : [Д], H) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Отобразить И-список решающих деревьев\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Д, H).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( и : [Д | ДД], H) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Отобразить И-список решающих деревьев\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Д, H),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( H),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( и : ДД, H), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( Верш, H) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Верш), nl.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.8.\b0   Поиск в глубину для И/ИЛИ-графов. Эта программа может зацикливаться. Процедура решить находит решающее дерево, а процедура отобр показывает его пользователю. В процедуре отобр предполагается, что на вывод вершины тратится только один символ.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, при поиске в И/ИЛИ-графе рис. 13.4 первое найденное решение задачи, соответствующей самой верхней вершине \i а\i0  , будет иметь следующее представление:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а ---> b ---> и : [d, c ---> h]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Три формы представления решающего дерева соответствуют трем предложениям отношения решить. Поэтому все, что нам нужно сделать для изменения нашей исходной программы решить, — это подправить каждое из этих трех предложений, просто добавив в каждое из них решающее дерево в качестве второго аргумента. Измененная программа показана на рис. 13.8. В нее также введена дополнительная процедура отобр для отображения решающих деревьев в текстовой форме. Например, решающее дерево рис. 13.4 будет отпечатано процедурой отобр в следующем виде:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а ---> b ---> d\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               e ---> h\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа рис. 13.8 все еще сохраняет склонность к вхождению в бесконечные циклы. Один из простых способов избежать бесконечных циклов — это следить за текущей глубиной поиска и не давать программе заходить за пределы некоторого ограничения по глубине. Это можно сделать, введя в отношение решить еще один аргумент:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Верш, РешДер, МаксГлуб)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как и раньше, вершиной Верш представлена решаемая задача, а РешДер — это решение этой задачи, имеющее глубину, не превосходящую МаксГлуб. МаксГлуб — это допустимая глубина поиска в графе. Если МаксГлуб = 0, то двигаться дальше запрещено, если же МаксГлуб > 0, то поиск распространяется на преемников вершины Верш, причем для них устанавливается меньший предел по глубине, равный МаксГлуб-1. Это дополнение легко ввести в программу рис. 13.8. Например, второе предложение процедуры решить примет вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( Верш, Верш ---> Дер, МаксГлуб) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  МаксГлуб > 0,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Верш ---> или : Вершины, % Верш - ИЛИ-вершина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит ( Верш1, Вершины),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Выбор преемника  Верш1  вершины  Верш\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Глуб1 is МаксГлуб - 1,   % Новый предел по глубине\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решить( Bepш1, Дер, Глуб1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Решить задачу-преемник с меньшим ограничением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нашу процедуру поиска в глубину с ограничением можно также использовать для имитации поиска в ширину. Идея состоит в следующем: многократно повторять поиск в глубину каждый раз все с большим значением ограничения до тех пор, пока решение не будет найдено, То есть попробовать решить задачу с ограничением по глубине, равным 0, затем — с ограничением 1, затем — 2 и т.д. Получаем следующую программу:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имитация_в_ширину( Верш, РешДер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  проба_в_глубину( Верш, РешДер, 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Проба поиска с возрастающим ограничением, начиная с 0\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 проба_в_глубину( Верш, РешДер, Глуб) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решить( Верш, РешДер, Глуб);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Глуб1 is Глуб + 1, % Новый предел по глубине\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  проба_в_глубину( Верш, РешДер, Глуб1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Попытка с новым ограничением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Недостатком имитации поиска в ширину является то, что при каждом увеличении предела по глубине программа повторно просматривает верхнюю область пространства поиска.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 13.1.\b0   Закончите составление программы поиска в глубину (с ограничением) для И/ИЛИ-графов, намеченную в настоящем разделе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 13.2.\b0   Определите на Прологе И/ИЛИ-пространство для задачи "ханойская башня" и примените к нему процедуры поиска настоящего раздела.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 13.3.\b0   Рассмотрите какую-нибудь простую детерминированную игру двух лиц с полной информацией и дайте определение ее И/ИЛИ-представления. Используйте программу поиска в И/ИЛИ-графах для построения выигрывающих стратегий в форме И/ИЛИ-деревьев.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 13.4. Поиск с предпочтением в И/ИЛИ-графах \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 13.4.1. Эвристические оценки и алгоритм поиска\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Базовые процедуры поиска предыдущего раздела производят систематический и полный просмотр И/ИЛИ-дерева, не руководствуясь при этом какими-либо эвристиками. Для сложных задач подобные процедуры весьма не эффективны из-за большой комбинаторной сложности пространства поиска. В связи с этим возникает необходимость в эвристическом управлении поиском, направленном на уменьшение комбинаторной сложности за счет исключения бесполезных альтернатив. Управление эвристиками, излагаемое в настоящем разделе, будет основано на численных эвристических оценках "трудности" задач, входящих в состав И/ИЛИ-графа. Программу, которую мы составим, можно рассматривать как обобщение программы поиска с предпочтением в пространстве состояний гл. 12.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Начнем с того, что сформулируем критерий оптимальности, основанный на стоимостях дуг И/ИЛИ-графа. Во-первых, мы расширим наше представление И/ИЛИ-графов, дополнив его стоимостями дуг. Например, И/ИЛИ-граф рис. 13.4 можно представить следующими предложениями:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а ---> или : [b/1, с/3].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 b ---> и : [d/1, e/1].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 с ---> и : [f/2, g/1].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 e ---> или : [h/6].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f ---> или : [h/2, i/3].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 цель( d). цель( g). цель( h).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Стоимость решающего дерева мы определим как сумму стоимостей его дуг. Цель оптимизации - найти решающее дерево минимальной стоимости. Как и раньше, иллюстрацией служит рис. 13.4.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Будет полезным определить \i стоимость вершины\i0   И/ИЛИ-графа как стоимость оптимального решающего дерева для этой вершины. Стоимость вершины, определенная таким образом, соответствует "трудности" соответствующей задачи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы будем предполагать, что стоимости вершин И/ИЛИ-графа можно оценить (не зная соответствующих решающих деревьев) при помощи эвристической функции \i h\i0  . Эти оценки будут использоваться для управления поиском. Наша программа поиска начнет свою работу со стартовой вершины и, распространяя поиск из уже просмотренных вершин на их преемников, будет постепенно наращивать дерево поиска. Этот процесс будет строить дерево даже в том случае, когда сам И/ИЛИ-граф не является деревом; при этом граф будет разворачиваться в дерево за счет дублирования своих отдельных частей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для продолжения поиска будет всегда выбираться "наиболее перспективное" решающее дерево-кандидат. Каким же образом используется функция \i h\i0   для оценки степени перспективности решающего дерева-кандидата или, точнее, вершины-кандидата — корня этого дерева?\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.9.\b0   Получение оценки \i H\i0   трудности задач И/ИЛИ-графа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обозначим через \i H(В)\i0   оценку трудности вершины \i В\i0  . Для самой верхней вершины текущего дерева поиска \i H(В)\i0   просто совпадает с \i h(В)\i0  . С другой стороны, для оценки внутренней вершины дерева поиска нам не обязательно использовать непосредственно значение \i h\i0  , поскольку у нас есть некоторая дополнительная информация об этой вершине: мы знаем ее преемников. Следовательно, как показано на рис. 13.9, мы можем приближенно оценить трудность внутренней ИЛИ-вершины как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  \qc\par\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где \i с(В, В\sub i\nosupersub )\i0   — стоимость дуги, ведущей из \i В\i0   в \i В\sub i\nosupersub \i0  . Взятие минимума в этой формуле оправдано тем обстоятельством, что для того, чтобы решить задачу \i В\i0  , нам нужно решить только одну из ее задач-преемников. Трудность И-вершины \i В\i0   можно приближенно оценить так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \qc\par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Будем называть \i H\i0  -оценку внутренней вершины "возвращенной" (backed-up) оценкой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Более практичной с точки зрения использования в нашей программе поиска является другая величина \i F\i0  , которую можно определить в терминах \i H\i0   следующим образом. Пусть \i В1\i0   — вершина-предшественник вершины \i В\i0   в дереве поиска, причем стоимость дуги, ведущей из \i В1\i0   в \i В\i0  , равна \i с(В1, В)\i0  , тогда положим\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i F( B) = с( В1, В) + H( В)\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пусть \i В1\i0   — родительская вершина вершины \i В\i0  , а \i В\i0  \sub 1\nosupersub , \i В\i0  \sub 2\nosupersub , … — ее дочерние вершины, тогда, в соответствии с определениями \i F\i0   и \i H\i0  , имеем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \qc\par,  если \i В\i0   — ИЛИ-вершина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \qc\par,  если \i В\i0   — И-вершина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хотя стартовая вершина \i А\i0   и не имеет предшественника, будем считать, что стоимость ведущей в нее (виртуальной) дуги равна 0. Если положить \i h\i0   равным 0 для всех вершин И/ИЛИ-дерева, то для любого найденного оптимального решающего дерева окажется, что его стоимость, т.е. сумма стоимостей его дуг, в точности равна  \i F(A)\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На любой стадии поиска каждый преемник ИЛИ-вершины соответствует некоторому альтернативному решающему дереву-кандидату. Процесс поиска всегда принимает решение продолжать просмотр того дерева-кандидата, для которого \i F\i0  -оценка минимальна. Вернемся еще раз к рис. 13.4 и посмотрим, как будет вести себя процесс, поиска на примере И/ИЛИ-графа, изображенного на этом рисунке. В начале дерево поиска состоит всего из одной вершины — стартовой вершины  \i а\i0  , далее дерево постепенно "растет" до тех пор, пока не будет найдено решающее дерево. На рис. 13.10, показан ряд "мгновенных снимков", сделанных в процессе роста дерева поиска. Для простоты мы предположим, что \i h =\i0   0 для всех вершин. Числа, приписанные вершинам на рис. 13.10 — это их \i F\i0  -оценки (разумеется, по мере накопления информации в процессе поиска они изменяются). Ниже даются некоторые пояснительные замечания к рис. 13.10.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 После распространения поиска из первоначального дерева (снимок А) получается дерево В. Вершина \i а\i0   — это ИЛИ-вершина, поэтому мы имеем два решающих дерева-кандидата: \i b\i0   и \i с\i0  . Поскольку \i F( b) = 1 < 3 = F( c)\i0  , для продолжения поиска выбирается альтернатива \i b\i0  . Насколько далеко может зайти процесс роста поддерева \i b\i0  ? Этот процесс может продолжаться до тех пор, пока не произойдет одно из двух событий:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) \i F\i0  -оценка вершины \i b\i0   станет больше, чем  \i F\i0  -оценка ее конкурента \i с\i0  , или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) обнаружится, что найдено решающее дерево.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В связи с этим, начиная просмотр поддерева-кандидата \i b\i0  , мы устанавливаем верхнюю границу для \i F( b)\i0  : \i F( b) \i0  &#8804;\i  3 = F( c)\i0  . Сначала порождаются преемники \i d\i0   и \i e\i0   вершины \i b\i0   (снимок С),после чего \i F\i0  -оценка \i b\i0   возрастает до 3. Так как это значение не превосходит верхнюю границу, рост дерева-кандидата с корнем в \i b\i0   продолжается. Вершина \i d\i0   оказывается целевой вершиной, а после распространения поиска из вершины \i e\i0   на один шаг получаем дерево, показанное на снимке D. В этот момент выясняется, что \i F( b) = 9 > 3\i0  ,  и рост дерева \i b \i0  прекращается. В результате процесс поиска не успевает "осознать", что \i h\i0   — это тоже целевая вершина и что порождено решающее дерево. Вместо этого происходит переключение активности на конкурирующую альтернативу  \i с\i0  .  Поскольку в этот момент \i F( b) =\i0   9, устанавливается верхняя граница для  \i F( c)\i0  ,  равная 9. Дерево-кандидат с корнем  \i с\i0     наращивается (с учетом установленного ограничения) до тех пор, пока не возникает ситуация, показанная на снимке  E.  Теперь процесс поиска обнаруживает, что найдено решающее дерево (включающее в себя целевые вершины \i h\i0   и \i g\i0  ), на чем поиск заканчивается. Заметьте, что в качестве результата процесс поиска выдает наиболее дешевое из двух возможных решающих деревьев, а именно решающее дерево рис. 13.4(с).\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.10.\b0   Трассировка процесса поиска с предпочтением в И/ИЛИ-графе (\i h =\i0   0) при решении задачи рис. 13.4. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 13.4.2. Программа поиска\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа, в которой реализованы идеи предыдущего раздела, показана на рис. 13.12. Прежде, чем мы перейдем к объяснению отдельных деталей этой программы, давайте рассмотрим тот способ представления дерева поиска, который в ней используется.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует несколько случаев, как показано на рис. 13.11. Различные формы представления поискового дерева возникают как комбинации следующих возможных вариантов, относящихся к размеру дерева и к его "решающему статусу".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Размер:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (1) дерево состоит из одной вершины (листа) или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (2) оно имеет корень и (непустые) поддеревья.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Решающий статус:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (1) обнаружено, что дерево соответствует решению задачи (т.е. является решающим деревом) или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  (2) оно все еще решающее дерево-\i кандидат\i0  .\par
\qc\par\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.11.\b0   Представление дерева поиска.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основной функтор, используемый для представления дерева, указывает, какая из комбинаций этих воз-можностей имеется в виду. Это может быть одна из следующих комбинаций:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 лист  решлист  дер  решдер\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее, в представление дерева входят все или некоторые из следующих объектов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • корневая вершина дерева,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i F\i0  -оценка дерева,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • стоимость С дуги И/ИЛИ-графа, ведущей в корень дерева,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • список поддеревьев,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • отношение (И или ИЛИ) между поддеревьями.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список поддеревьев всегда упорядочен по возрастанию \i F\i0  -оценок. Поддеревья, являющиеся решающими деревьями, помещаются в конец списка.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратимся теперь к программе рис. 13.12. Отношение самого высокого уровня — это\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и_или( Верш, РешДер)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Верш — стартовая вершина. Программа строит решающее дерево (если таковое существует), рассчитывая на то, что оно окажется оптимальным решением. Будет ли это решение в действительности самым дешевым, зависит от той функции \i h\i0  , которую использует алгоритм. Существует теорема, в которой говорится о том, как оптимальность решения зависит от \i h\i0  . Эта теорема аналогична теореме о допустимости алгоритма поиска с предпочтением в пространстве состояний (гл. 12). Обозначим через \i С( В)\i0    стоимость оптимального решающего дерева для вершины \i В\i0  . Если для каждой вершины \i В\i0   И/ИЛИ-графа эвристическая оценка  \i h(B)\i0  &#8804;\i C(B)\i0  , то гарантируется, что процедура и_или найдет оптимальное решение. Если же \i h\i0   не удовлетворяет этому условию, то найденное решение может оказаться субоптимальным. Существует тривиальная эвристическая функция, удовлетворяющая условию оптимальности, а именно \i h =\i0   0 для всех вершин. Ее недостатком является отсутствие эвристической силы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основную роль в программе рис. 13.12 играет отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( Дер, Предел, Дер1, ЕстьРеш)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер и Предел — его "входные" аргументы, а Дер1 и ЕстьРеш — "выходные". Аргументы имеют следующий смысл:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дер — дерево поиска, подлежащее расширению.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Предел — предельное значение \i F\i0  -оценки, при котором еще разрешено наращивать дерево Дер.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ЕстьРеш — индикатор, значения которого указывают на то, какой из следующих трех случаев имеет место:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) ЕстьРеш = да: Дер можно "нарастить" (с учетом ограничения Предел) таким образом, чтобы образовалось решающее дерево Дер1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) ЕстьРеш = нет: дерево Дер можно расширить до состояния Дер1, для которого \i F\i0  -оценка превосходит Предел, но прежде чем \i F\i0  -оценка превзошла Предел, решающее дерево не было обнаружено.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) ЕстьРеш = никогда: Дер не содержит решения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В зависимости от случая Дер1 — это либо решающее дерево, либо Дер, расширенное до момента перехода через Предел; если ЕстьРеш = никогда, то переменная Дер1 неинициализирована.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширспис( Деревья, Предел, Деревья1, ЕстьРеш)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 аналогична процедуре расширить. Так же, как и в процедуре расширить, Предел задает ограничение на рост дерева, а ЕстьРеш — это индикатор, указывающий, каков результат расширения ("да", "нет" или "никогда"). Первый аргумент — это, на этот раз, список деревьев (И-список или ИЛИ-список):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Деревья = или:[Д1, Д2, ...] или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Деревья = и : [Д1, Д2, ...]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура расширспис выбирает из списка Деревья наиболее перспективное дерево (исходя из \i F\i0  -оценок). Так как деревья в списке упорядочены, таким деревом является первый элемент списка. Наиболее перспективное дерево подвергается расширению с новым ограничением Предел1. Значение Предел1 зависит от Предел, а также от других деревьев списка. Если Деревья — это ИЛИ-список, то Предел1 устанавливается как наименьшая из двух величин: Предел и \i F\i0  -оценка следующего по "качеству" дерева из списка Деревья. Если Деревья — это И-дерево, то Предел1 устанавливается равным Предел минус сумма \i F\i0  -оценок всех остальных деревьев из списка. Значение переменной Деревья1 зависит от случая, задаваемого индикатором ЕстьРеш. Если ЕстьРеш = нет, то Деревья1 — это то же самое, что и список Деревья, причем наиболее перспективное дерево расширено с учетом ограничения Предел1. Если ЕстьРеш = да, то Деревья1 — это решение для всего списка Деревья (найденное без выхода за границы значения Предел). Если ЕстьРеш = никогда, то переменная Деревья1 неинициализирована.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура продолжить, вызываемая после расширения списка деревьев, решает, что делать дальше, в зависимости от результата срабатывания процедуры расширить. Эта процедура либо строит решающее дерево, либо уточняет дерево поиска и продолжает процесс его наращивания, либо выдает сообщение "никогда" в случае, когда было обнаружено, что список деревьев не содержит решения.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 /* ПРОГРАММА И/ИЛИ-ПОИСКА С ПРЕДПОЧТЕНИЕМ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта программа порождает только одно решение. Гарантируется, что это решение самое дешевое при условии, что используемая эвристическая функция является нижней гранью реальной стоимости решающих деревьев.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Дерево поиска имеет одну из следующих форм:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дер( Верш, F, С, Поддеревья) дерево-кандидат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 лист( Верш, F, C)            лист дерева поиска\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решдер( Верш, F, Поддеревья) решающее дерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решлист( Верш, F)            лист решающего дерева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С - стоимость дуги, ведущей в Верш\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 F = С + H, где H - эвристическая оценка оптимального решающего дерева с корнем Верш\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список Поддеревья упорядочен таким образом, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) решающие поддеревья находятся в конце списка;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) остальные поддеревья расположены в порядке возрастания F-оценок\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 */\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 500, xfx, :).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 600, xfx, --->).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и_или( Верш, РешДер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширить( лист( Верш, 0, 0), 9999, РешДер, да).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Предполагается, что 9999  >  любой F-оценки\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Процедура расширить( Дер, Предел, НовДер, ЕстьРеш)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % расширяет Дер в пределах ограничения Предел\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % и порождает НовДер с "решающим статусом" ЕстьРеш.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Случай 1:  выход за ограничение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( Дер, Предел, Дер, нет) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  f( Дер, F),  F > Предел, !. % Выход за ограничение\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % В остальных случаях F &#8804; Предел\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Случай 2:  встретилась целевая вершина\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( лист( Верш, F, С), _, решлист( Верш, F), да) : -\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( Верш), !.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Случай 3:  порождение преемников листа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( лист( Верш, F,C), Предел, НовДер, ЕстьРеш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расшлист( Верш, С, Дер1), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширить( Дер1, Предел, НовДер, ЕстьРеш);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ЕстьРеш = никогда, !.       % Нет преемников, тупик\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Случай 4:  расширить дерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширить( дер( Верш, F, С, Поддеревья),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Предел, НовДер, ЕстьРеш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Предел1 is Предел - С,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширспис( Поддеревья, Предел1, НовПоддер, ЕстьРеш1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  продолжить( ЕстьРеш1, Верш, С, НовПоддер, Предел,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   НовДер, ЕстьРеш).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % расширспис( Деревья, Предел, Деревья1, ЕстьРеш)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % расширяет деревья из заданного списка с учетом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % ограничения Предел и выдает новый список Деревья1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % с "решающим статусом" ЕстьРеш.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расширспис( Деревья, Предел, Деревья1, ЕстьРеш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выбор( Деревья, Дер, ОстДер, Предел, Предел1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширить( Дер, Предел1, НовДер, ЕстьРеш1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  собрать( ОстДер, НовДер, ЕстьРеш1, Деревья1, ЕстьРеш).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % "продолжить" решает, что делать после расширения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % списка деревьев\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 продолжить( да, Верш, С, Поддеревья, _,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решдер( Верш, F, Поддеревья), да): -\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  оценка( Поддеревья, H), F is С + H, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 продолжить( никогда, _, _, _, _, _, никогда) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 продолжить( нет, Верш, С, Поддеревья, Предел,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  НовДер, ЕстьРеш) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  оценка( Поддеревья, H), F is С + H, !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расширить( дер( Верш, F, С, Поддеревья), Предел,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   НовДер, ЕстьРеш).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % "собрать" соединяет результат расширения дерева со списком деревьев\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( или : _, Дер, да, Дер, да):- !. % Есть решение ИЛИ-списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( или : ДД, Дер, нет, или : НовДД, нет) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Дер, ДД, НовДД), !.  % Нет решения ИЛИ-списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( или : [], _, никогда, _, никогда) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Больше нет кандидатов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( или:ДД, _, никогда, или:ДД, нет) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Есть еще кандидаты\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( и : ДД, Дер, да, и : [Дер Э ДД], да ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  всереш( ДД), !.             % Есть решение И-списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( и : _, _, никогда, _, никогда) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Нет решения И-списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( и : ДД, Дер, ДаНет, и : НовДД, нет) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Дер, ДД, НовДД), !.  % Пока нет решения И-списка\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % "расшлист" формирует дерево из вершины и ее преемников\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расшлист( Верш, С, дер( Верш, F, С, Оп : Поддеревья)) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Верш---> Оп : Преемники,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  оценить( Преемники, Поддеревья),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  оценка( Оп : Поддеревья, H), F is С + H.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  оценить( [], []).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 оценить( [Верш/С | ВершиныСтоим], Деревья) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  h( Верш, H), F is С + H,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  оценить( ВершиныСтоим, Деревья1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( лист( Верш, F, С), Деревья1, Деревья).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % "всереш" проверяет, все ли деревья в списке "решены"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 всереш([]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 всереш( [Дер | Деревья] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  реш( Дер),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  всереш( Деревья).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 реш( решдер( _, _, _ ) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 реш( решлист( _ , _) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 f( Дер, F) :-              % Извлечь F-оценку дерева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  arg( 2, Дер, F), !.       % F - это 2-й аргумент Дер\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % встав( Дер, ДД, НовДД) вставляет Дер в список\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % деревьев ДД; результат - НовДД\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Д, [], [Д] ) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Д, [Д1 | ДД], [Д, Д1 | ДД] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  реш( Д1), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Д, [Д1 | ДД], [Д1 | ДД1] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  реш( Д),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д, ДД, ДД1), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Д, [Д1 | ДД], [Д, Д1 | ДД] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  f( Д, F), f( Д1, F1), F=< F1, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 встав( Д, [Д1 | ДД], [ Д1 | ДД1] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  встав( Д, ДД, ДД1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % "оценка" находит "возвращенную" F-оценку И/ИЛИ-списка деревьев\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 оценка( или :[Дер | _ ], F) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Первое дерево ИЛИ-списка - наилучшее\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  f( Дер, F), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 оценка( и :[], 0) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 оценка( и : [Дер1 | ДД], F) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  f( Дер1, F1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  оценка( и : ДД, F2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  F is F1 + F2, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 оценка( Дер, F) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  f( Дер, F).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Отношение выбор( Деревья, Лучшее, Остальные, Предел, Предел1):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Остальные - И/ИЛИ-список Деревья без его "лучшего" дерева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Лучшее; Предел - ограничение для Списка Деревья, Предел1 -\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % ограничение для дерева Лучшее\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выбор( Оп : [Дер], Дер, Оп : [], Предел, Предел) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Только один кандидат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выбор( Оп : [Дер | ДД], Дер, Оп : ДД, Предел, Предел1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  оценка( Оп : ДД, F),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Оп = или, !, мин( Предел, F, Предел1);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Оп = и, Предел1 is Предел - F).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мин( А, В, А) :- А < В, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мин( А, В, В).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 13.12.\b0   Программа поиска с предпочтением в И/ИЛИ-графе.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще одна процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( ОстДер, НовДер, ЕстьРеш1, НовДеревья, ЕстьРеш)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 связывает между собой несколько объектов, с которыми работает расширспис. НовДер — это расширенное дерево, взятое из списка деревьев процедуры расширспис, ОстДер — остальные, не измененные деревья из этого списка, а ЕстьРеш1 указывает на "решающий статус" дерева НовДер. Процедура собрать имеет дело с несколькими случаями в зависимости от значения ЕстьРеш1, а также от того, является ли список деревьев И-списком или ИЛИ-списком. Например, предложение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 собрать( или : _, Дер, да, Дер, да).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает: в случае, когда список деревьев — это ИЛИ-список и при только что проведенном расширении получено решающее дерево, считать, что задача, соответствующая всему списку деревьев, также решена, а ее решающее дерево и есть само дерево Дер. Остальные случаи легко понять из текста процедуры собрать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для отображения решающего дерева можно определить процедуру, аналогичную процедуре отобр (рис. 13.8). Оставляем это читателю в качестве упражнения.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 13.4.3. Пример отношений, определяющих конкретную задачу: поиск маршрута\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте теперь сформулируем задачу нахождения маршрута как задачу поиска в И/ИЛИ-графе, причем сделаем это таким образом, чтобы наша формулировка могла бы быть непосредственно использована процедурой и_или рис. 13.12. Мы условимся, что карта дорог будет представлена при помощи отношения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 связь( Гор1, Гор2, P)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означающего, что между городами Гор1 и Гор2 существует непосредственная связь, а соответствующее расстояние равно P. Далее, мы допустим, что существует отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 клпункт( Гор1-Гор2, Гор3)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 имеющее следующий смысл: для того, чтобы найти маршрут из Гор1 в Гор2, следует рассмотреть пути, проходящие через Гор3 (Гор3 — это "ключевой пункт" между Гор1 и Гор2). Например, на карте рис. 13.1 \i f\i0   и \i g\i0   — это ключевые пункты между \i а\i0   и \i z\i0  :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 клпункт( a-z, f).  клпункт( a-z, g).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы реализуем следующий принцип построения маршрута:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Для того, чтобы найти маршрут между городами X и Z, необходимо:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   (1) если между X и Z имеются ключевые пункты Y1, Y2, …, то найти один из путей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    путь из X в Z через Y1, или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    путь из X в Z через Y2, или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    …\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   (2) если между X и Z нет ключевых пунктов, то найти такой соседний с X город Y, что существует маршрут из Y в Z.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом, мы имеем два вида задач, которые мы будем представлять как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) X-Z         найти маршрут из X в Z\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) X-Z через Y найти маршрут из X в Z, проходящий через Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь 'через' — это инфиксный оператор более высокого приоритета, чем '-', и более низкого, чем '--->'. Теперь можно определить соответствующий И/ИЛИ-граф явным образом при помощи следующего фрагмента программы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 560, xfx, через)\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Правила задачи X-Z, когда между  X  и  Z\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % имеются ключевые пункты,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % стоимости всех дуг равны 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X-Z ---> или : СписокЗадач\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  :- bagof( ( X-Z через Y)/0, клпункт( X-Z, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  СписокЗадач), !.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Правила для задачи X-Z без ключевых пунктов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X-Z ---> или : СписокЗадач\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  :- bagof( ( Y-Z)/P, связь( X, Y, P), СписокЗадач).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Сведение задачи типа "через" к подзадачам,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % связанным отношением И\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 X-Z через Y---> и : [( X-Y)/0, ( Y-Z)/0].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( X-X) % Тривиальная задача: попасть из X в X\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Функцию \i h\i0   можно определить, например, как расстояние, которое нужно преодолеть при воздушном сообщении между городами.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 13.4.\b0   Напишите процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр2( РешДер)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 для отображения решающего дерева, найденного программой и_или рис. 13.12. Формат отображения пусть будет аналогичен тому, что применялся в процедуре отобр (рис. 13.8), так что процедуру отобр2 можно получить, внеся в отобр изменения, связанные с другим представлением деревьев. Другая полезная модификация — заменить в отобр цель write( Верш) на процедуру, определяемую пользователем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 печверш( Верш, H)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которая выведет Верш в удобной для пользователя форме, а также конкретизирует H в соответствии с количеством символов, необходимом для представления Верш в этой форме. В дальнейшем H будет использоваться как величина отступа для поддеревьев.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • И/ИЛИ-граф — это формальный аппарат для представления задач. Такое представление является наиболее естественным и удобным для задач, которые разбиваются на независимые подзадачи. Примером могут служить игры.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Вершины И/ИЛИ-графа бывают двух типов: И-вершины и ИЛИ-вершины.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Конкретная задача определяется стартовой вершиной и целевым условием. Решение задачи представляется решающим деревом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Для моделирования оптимизационных задач в И/ИЛИ-граф можно ввести стоимости дуг и вершин.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Процесс решения задачи, представленной И/ИЛИ-графом, включает в себя поиск в графе. Стратегия поиска в глубину предусматривает систематический просмотр графа и легко программируется. Однако эта стратегия может привести к неэффективности из-за комбинаторного взрыва.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Для оценки трудности задач можно применить эвристики, а для управления поиском — принцип эвристического поиска с предпочтением. Эта стратегия более трудна в реализации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В данной главе были разработаны прологовские программы для поиска в глубину и поиска с предпочтением в И/ИЛИ-графах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Были введены следующие понятия: \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   И/ИЛИ-графы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   И-дуги, ИЛИ-дуги\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   И-вершины, ИЛИ-вершины\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   решающий путь, решающее дерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   стоимость дуг и вершин\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   эвристические оценки в И/ИЛИ-графах\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "возвращенные" оценки\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   поиск в глубину в И/ИЛИ-графах\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   поиск с предпочтением в И/ИЛИ-графах\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И/ИЛИ-графы и связанные с ними алгоритмы поиска являются частью классических механизмов искусственного интеллекта для решения задач и реализации машинных игр. Ранним примером прикладной задачи, использующей эти методы, может служить программа символического интегрирования (Slagle 1963). И/ИЛИ-поиск используется в самой пролог-системе. Общее описание И/ИЛИ-графов и алгоритма можно найти в учебниках по искусственному интеллекту (Nilsson 1971; Nilsson 1980). Наша программа поиска с предпочтением — это один из вариантов алгоритма, известного под названием АО*. Формальные свойства АО*-алгоритма (включая его допустимость) изучались несколькими авторами. Подробный обзор полученных результатов можно найти в книге Pearl (1984).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Nilsson N.J. (1971). \i Problem-Solving Methods in Artificial Intelligence\i0  . McGraw-Hill.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Nilsson N.J. (1980). \i Principles of Artificial Intelligence\i0  . Tioga; also Springer-Verlag.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Pearl J. (1984). \i Heuristics: Intelligent Search Strategies for Computer Problem Solving\i0  . Addison-Wesley.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Slagle J.R. (1963). A heuristic program that solves symbolic integration problems in freshman calculus. In: \i Computers and Thought\i0   (E. Feigenbaum, J. Feldman, eds.). McGraw-Hill. \par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 14\par
Экспертные системы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Экспертная система - это программа, которая ведет себя подобно эксперту в некоторой проблемной области. Она должна иметь способность к \i объяснению\i0   своих решений и тех рассуждений, на основе которых эти решения были приняты. Часто от экспертной системы требуют, чтобы она могла работать с неточной и неполной информацией.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы построить экспертную систему, мы должны создать механизмы, обеспечивающие выполнение следующих функций: решение задач, взаимодействие с пользователем и работа в условиях неопределенности. В данной главе мы разработаем и peaлизуем основные идеи построения экспертных систем.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 14.1. Функции, выполняемые экспертной системой\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Экспертная система\i0   — это программа, которая ведет себя подобно эксперту в некоторой, обычно узкой, прикладной области. Типичные применения экспертных систем включают в себя такие задачи, как медицинская диагностика, локализация неисправностей в оборудовании и интерпретация результатов измерений. Экспертные системы должны решать задачи, требующие для своего решения экспертных знаний в некоторой конкретной области. В той или иной форме экспертные системы должны обладать этими знаниями. Поэтому их также называют \i системами\i0  ,\i  основанными на знаниях\i0  . Однако не всякую систему, основанную на знаниях, можно рассматривать как экспертную. Экспертная система должна также уметь каким-то образом \i объяснять\i0   свое поведение и свои решения пользователю, так же, как это делает эксперт-человек. Это особенно необходимо в областях, для которых характерна неопределенность, неточность информации (например, в медицинской диагностике). В этих случаях способность к объяснению нужна для того, чтобы повысить степень доверия пользователя к советам системы, а также для того, чтобы дать возможность пользователю обнаружить возможный дефект в рассуждениях системы. В связи с этим в экспертных системах следует предусматривать дружественное взаимодействие с пользователем, которое делает для пользователя процесс рассуждения системы "прозрачным".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Часто к экспертным системам предъявляют дополнительное требование — способность иметь дело с неопределенностью и неполнотой. Информация о поставленной задаче может быть неполной или ненадежной; отношения между объектами предметной области могут быть приближенными. Например, может не быть полной уверенности в наличии у пациента некоторого симптома или в том, что данные, полученные лри измерении, верны; лекарство \i может\i0   стать причиной осложнения, хотя \i обычно\i0   этого не происходит. Во всех этих случаях необходимы рассуждения с использованием вероятностного подхода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В самом общем случае для того, чтобы построить экспертную систему, мы должны разработать механизмы выполнения следующих функций системы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i решение задач\i0   с использованием знаний о конкретной предметной области — возможно, при этом возникнет необходимость \i иметь дело с неопределенностью\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i взаимодействие с пользователем\i0  , включая объяснение намерений и решений системы во время и после окончания процесса решения задачи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждая из этих функций может оказаться очень сложной и зависит от прикладной области, а также от различных практических требований. В процессе разработки и реализации могут возникать разнообразные трудные проблемы. В данной главе мы ограничился наметками основных идей, подлежащих в дальнейшем детализации и усовершенствованию.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 14.2. Грубая структура экспертной системы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При разработке экспертной системы принято делить ее на три основных модуля, как показано на рис. 14.1:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) база знаний,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) машина логического вывода,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) интерфейс с пользователем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i База знаний\i0   содержит знания, относящиеся к конкретной прикладной области, в том числе отдельные факты, правила, описывающие отношения или явления, а также, возможно, методы, эвристики и различные идеи, относящиеся к решению задач в этой прикладной области. \i Машина логического вывода\i0   умеет активно использовать информацию, содержащуюся в базе знаний. \i Интерфейс с пользователем\i0   отвечает за бесперебойный обмен информацией между пользователем и системой; он также дает пользователю возможность наблюдать за процессом решения задач, протекающим в машине логического вывода. Принято рассматривать машину вывода и интерфейс как один крупный модуль, обычно называемый \i оболочкой экспертной системы\i0  , или, для краткости, просто \i оболочкой\i0  .\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.1.\b0   Структура экспертной системы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В описанной выше структуре собственно знания отделены от алгоритмов, использующих эти знания. Такое разделение удобно по следующим соображениям. База знаний, очевидно, зависит от конкретного приложения. С другой стороны, оболочка, по крайней мере в принципе, независима от приложений. Таким образом, разумный способ разработки экспертной системы для нескольких приложений сводится к созданию универсальной оболочки, после чего для каждого приложения достаточно подключить к системе новую базу знаний. Разумеется, все эти базы знаний должны удовлетворять одному и тому же формализму, который оболочка "понимает". Практический опыт показывает, что для сложных экспертных систем наш сценарий с одной оболочкой и многими базами знаний работает не так гладко, как бы этого хотелось, за исключением тех случаев, когда прикладные области очень близки. Тем не менее даже если переход от одной прикладной области к другой требует модификации оболочки, то по крайней мере основные принципы ее построения обычно удается сохранить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой главе мы намерены разработать относительно простую оболочку, при помощи которой, несмотря на. ее простоту, мы сможем проиллюстрировать основные идеи и методы в области экспертных систем. Мы будем придерживаться следующего плана:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Выбрать формальный аппарат для представления знаний.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Разработать механизм логического вывода, соответствующий этому формализму.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Добавить средства взаимодействия с пользователем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (4) Обеспечить возможность работы в условиях неопределенности.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 14.3. Правила типа "если-то" для представления знаний\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве кандидата на использование в экспертной системе можно рассматривать, в принципе, любой непротиворечивый формализм, в рамках которого можно описывать знания о некоторой проблемной области. Однако самым популярным формальным языком представления знаний является язык правил типа "если-то" (или кратко: "если-то"-правил), называемых также \i продукциями\i0  . Каждое такое правило есть, вообще говоря, некоторое условное утверждение, но возможны и различные другие интерпретации. Вот примеры:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i • если\i0   предварительное условие P \i то\i0   заключение (вывод) С\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i если\i0   ситуация S \i то\i0   действие А\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i если\i0   выполнены условия C1 и C2 \i то\i0   не выполнено условие С\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 "Если-то"-правила обычно оказываются весьма естественным выразительным средством представления знаний. Кроме того, они обладают следующими привлекательными свойствами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Модульность\i0  : каждое правило описывает небольшой, относительно независимый фрагмент знаний.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Возможность \i инкрементного наращивания\i0  : добавление новых правил в базу знаний происходит относительно независимо от других правил.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i Удобство модификации\i0   (как следствие модульности): старые правила можно изменять и заменять на новые относительно независимо от других правил.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Применение правил способствует \i прозрачности\i0   системы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Последнее свойство — это важное, отличительное свойство экспертных систем. Под прозрачностью мы понимаем способность системы к объяснению принятых решений и полученных результатов. Применение "если-то"-правил облегчает получение ответов на следующие основные типы вопросов пользователя:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Вопросы типа "как": \i Как\i0   вы пришли к этому выводу?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Вопросы типа "почему": \i Почему\i0   вас интересует эта информация?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Механизмы, основанные на "если-то"-правилах, для формирования ответов на подобные вопросы мы обсудим позже.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i если\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  1 тип инфекции — это первичная бактериемия и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  2 материал для посева был отобран стерильно, и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  3 предполагаемые ворота инфекции — желудочно-кишечный тракт\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i то\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  имеются веские аргументы (0.7) за то,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  что инфекционный агент является бактерией\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.2.\b0   "Если-то"-правило медицинской консультативной системы MYCIN (Shortliffe, 1976). Параметр 0.7 показывает степень доверия этому правилу.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 "Если-то"-правила часто применяют для определения логических отношений между понятиями предметной области. Про чисто логические отношения можно сказать, что они принадлежат к "категорическим знаниям", "категорическим" — потому, что соответствующие утверждения всегда, абсолютно верны. Однако в некоторых предметных областях, таких, как медицинская диагностика, преобладают "мягкие" или вероятностные знания. Эти знания являются "мягкими"; в том смысле, что говорить об их применимости к любым практическим ситуациям можно только до некоторой степени ("часто, но не всегда"). В таких случаях используют модифицированные "если-то"-правила, дополняя их логическую интерпретацию вероятностной оценкой. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i если\i0   условие А \i то\i0   заключение В \i с уверенностью\i0   F\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рис. 14.2, 14.3 и 14.4 дают представление о разнообразии способов, которыми знания могут быть выражены при помощи "если-то"-правил. На этих рисунках приведены примеры правил из трех различных систем, основанных на знаниях: медицинской консультативной системы MYCIN, системы AL/X для диагностики неисправностей в оборудовании и системы AL3 для решения шахматных задач.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вообще говоря, если вы хотите разработать серьезную экспертную систему для некоторой выбранной вами предметной области, вы должны провести консультации с экспертами в этой области и многое узнать о ней сами. Достигнуть определенного понимания предметной области после общения с экспертами и чтения литературы, а затем облечь это понимание в форму представления знаний в рамках выбранного формального языка — это искусство, называемое \i инженерией знаний\i0  . Как правило, это сложная задача, требующая больших усилий, чего мы не можем себе позволить в данной книге. Но какая-нибудь предметная область и какая-нибудь база данных нам необходимы в качестве материала для экспериментов. С практической точки зрения нам для этой цели вполне подойдет "игрушечная" база знаний. На рис. 14.5 показана часть такой базы знаний. Она состоит из простых правил, помогающих идентифицировать животных по их основным признаками в предположении, что задача идентификации ограничена только небольшим числом разных животных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i если\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  давление в v-01 достигло уровня открытия выпускного клапана\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i то\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выпускной клапан в v-01 открылся\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [N=0.005, S=400]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i если\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  давление в v-01 не достигло уровня открытия выпускного клапана и выпускной клапан в v-01 открылся\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i то\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  преждевременное открытие выпускного клапана (сместилась установка порогового давления)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [N=0.001, S=2000]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.3.\b0   Два правила из демонстрационной базы знаний системы AL/X для диагностики неисправностей (Reiter 1980). N и S — величины "необходимости" и "достаточности", детально описанные в разд. 14.7. Величина S указывает степень, с которой условие влечет за собой заключение (вывод). Величина N указывает, до какой степени истинность условия необходима для того, чтобы заключение было истинным.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i если\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  1 существует гипотеза \i H\i0  , что план \i P\i0   ведет к успеху, и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  2 существуют две гипотезы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \i H1\i0  , что план \i P1\i0   опровергает план \i P\i0  , и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   \i Н2\i0  , что план \i Р2\i0   опровергает план \i P\i0  , и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  3 имеют место факты:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    гипотеза \i H1\i0   ложна и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    гипотеза \i Н2\i0   ложна\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i то\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  1 породить гипотезу \i Н3\i0  , что составной план \i "P1 или Р2"\i0   опровергает план \i P\i0  , и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  2 породить факт: \i из  Н3 следует не( H)\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.4.\b0   Правило уточнения плана из системы AL3 для решения шахматных задач (Bratko 1982).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Правила, содержащиеся в базе знаний, имеют вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ИмяПравила : если Условие то Заключение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Заключение — это простое утверждение, а Условие — это набор простых утверждений, соединенных между собой операторами и и или. Мы также разрешим в части условия использовать оператор не, хотя и с некоторыми оговорками. При надлежащем прологовском определении этих операторов (как это сделано на рис. 14.5) правила станут синтаксически верными предложениями Пролога. Заметим, что оператор и связывает операнды сильнее, чем или, что соответствует обычным соглашениям.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Небольшая база знаний для идентификации животных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 100, xfx, [имеет, 'кормит детенышей',\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  'не может', ест, откладывает, это]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 100, xf, [плавает, летает, хорошо]).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прав1: если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное имеет шерсть\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное 'кормит детенышей' молоком\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это млекопитающее.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прав2: если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное имеет перья\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное летает и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное откладывает яйца\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это птица.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прав3: если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это млекопитающее и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Животное ест мясо\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Животное имеет 'острые зубы' и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Животное имеет когти и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Животное имеет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    'глаза, направленные вперед' )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это хищник.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прав4: если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это хищник и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное имеет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   'рыжевато-коричневый цвет' и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное имеет 'темные пятна'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это гепард.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прав5: если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это хищник и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное имеет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   'рыжевато-коричневый цвет' и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное имеет 'черные полосы'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это тигр.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прав6: если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это птица и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное 'не может' летать и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное плавает\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это пингвин.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прав7: если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это птица и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное летает хорошо\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это альбатрос.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: X это животное :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, [гепард, тигр, пингвин, альбатрос]).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( _ 'кормит детенышей' _,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  'Животное' 'кормит детенышей' 'Чем').\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( _ летает, 'Животное' летает).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( _ откладывает яйца,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  'Животное' откладывает яйца).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( _ ест _, 'Животное' ест 'Что').\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( _ имеет _,'Животное' имеет 'Нечто').\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( _ 'не может' _,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  'Животное' 'не может' 'Что делать').\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( _ плавает, 'Животное' плавает).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( _ летает хорошо,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  'Животное' летает хорошо).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.5.\b0   Простая база знаний для идентификации животных. Заимствовано из Winston (1984). Отношение "можно_спросить" определяет вопросы, которые можно задавать пользователю. Операторы если, то, и, или определены на рис. 14.10.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим еще одну небольшую базу знаний, которая может помочь локализовать неисправности в простой электрической схеме, состоящей из электрических приборов и предохранителей. Электрическая схема показана на рис. 14.6. Вот одно из возможных правил:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i если\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  лампа1 включена \i и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  лампа1 не работает  \i и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предохранитель1 заведомо цел\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i то\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  лампа1 заведомо неисправна.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот другой пример правила:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i если\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  радиатор работает\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i то\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предохранитель1 заведомо цел.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.6.\b0   Соединения между предохранителями и приборами в простой электрической схеме.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эти два правила опираются на некоторые факты (относящиеся к нашей \i конкретной\i0   схеме), а именно что \i лампа1\i0   соединена с \i предохранитель1\i0   и что \i лампа1\i0   и \i радиатор\i0   имеют общий предохранитель. Для другой схемы нам понадобится еще один набор правил. Поэтому было бы лучше сформулировать правила в более общем виде (используя прологовские переменные) так, чтобы они были применимы к любой схеме, а затем уже дополнять их информацией о конкретной схеме. Например, вот одно из полезных правил: если прибор включен, но не работает, а соответствующий предохранитель цел, то прибор неисправен. На наш формальный язык это транслируется так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 правило_поломки:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   Прибор включен и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   не (Прибор работает) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   Прибор соединен с Предохранитель и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   Предохранитель заведомо цел\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   Прибор заведомо неисправен.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 База знаний такого рода показана на рис. 14. 7.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Небольшая база знаний для локализации неисправностей в\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % электрической схеме\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Если прибор включен, но не работает, и предохранитель цел,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % то прибор неисправен.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 правило_поломки:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   вкл( Прибор) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   прибор( Прибор) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   не работает( Прибор) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   соед( Прибор, Предохр) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   доказано( цел( Предохр) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   доказано( неиспр( Прибор) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Если устройство работает, то его предохранитель цел\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 правило_цел_предохр:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   соед( Прибор, Предохр)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   и работает( Прибор)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   доказано( цел( Предохр) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Если два различных прибора подключены к одному и тому же\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % предохранителю, оба включены и не работают, то предохранитель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % сгорел.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % ЗАМЕЧАНИЕ: предполагается, что из двух приборов неисправных -\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % не более одного!\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 правило_предохр:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   соед( Прибор1, Предохр) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   вкл( Прибор1) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   не работает( Прибор1) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   общ_предохр( Прибор2, Прибор1) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   вкл( Прибор2) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   не работает( Прибор2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   доказано( сгорел( Предохр) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 правило_общ_предохр:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   соед( Прибор1, Предохр) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   соед( Прибор2, Предохр) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   различны( Прибор1, Прибор2)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   общ_предохр( Прибор1, Прибор2).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: различны( X, Y) :- not (X=Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: прибор( радиатор).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: прибор( лампа1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: прибор( лампа2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: прибор( лампа3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: прибор( лампа4).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: соед( лампа1, предохр1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: соед( лампа2, предохр1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: соед( радиатор, предохр1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: соед( лампа3, предохр2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 факт: соед( лампа4, предохр2).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( вкл( П), вкл( 'Прибор') ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( работает( П), работает(' Прибор')).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.7.\b0   База знаний для локализации неисправностей в схеме, показанной на рис. 14.6.\par
\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 14.1.\b0   Рассмотрите "если-то"-правила рис. 14.2-14.4 и транслируйте их в нашу систему обозначений для правил. Предложите расширение нотации, чтобы, при необходимости, можно было работать с оценками уверенности.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 14.2.\b0   Придумайте какую-нибудь задачу принятия решений и сформулируйте соответствующие знания в форме "если-то"-правил. Можете рассмотреть, например, планирование отпуска, предсказание погоды, простой медицинский диагноз и лечение и т.п.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 14.4. Разработка оболочки\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если мы посмотрим на правила наших двух маленьких баз знаний рис. 14.5 и 14.7, мы сразу увидим, что они по своему смыслу эквивалентны правилам Пролога. Однако, с точки зрения синтаксиса Пролога, эти правила в том виде, как они написаны, соответствуют всего лишь фактам. Для того, чтобы заставить их работать, самое простое, что может прийти в голову, это переписать их в виде настоящих прологовских правил. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Животное это млекопитающее :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное имеет шерсть;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное 'кормит детенышей' молоком.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Животное это хищник :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное это млекопитающее,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Животное ест мясо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь эта программа сможет подтвердить, что тигр по имени Питер — это действительно тигр, если мы добавим в нее некоторые из свойств Питера (в виде прологовских фактов):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 питер имеет шерсть.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 питер ленив.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 питер большой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 питер имеет 'рыжевато-коричневый цвет'.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 питер имеет 'черные полосы'.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 питер ест мясо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тогда мы можем спросить:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- питер это тигр.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 yes\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- питер это гепард.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 no\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Хотя пролог-система и отвечает на вопросы, используя для этого нашу базу знаний, нельзя сказать, что ее поведение вполне соответствует поведению эксперта. Это происходит по крайней мере по двум причинам:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Мы не можем попросить систему объяснить свой ответ; например, \i как\i0   она установила, что Питер это тигр, и \i почему\i0   Питер это \i не\i0   гепард.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Прежде, чем задать вопрос, нужно ввести в систему всю необходимую информацию (в виде прологовских фактов). Но тогда пользователь, возможно, введет какую-нибудь лишнюю информацию (как в нашем примере) или же упустит какую-нибудь информацию, имеющую решающее значение. В первом случае будет проделана ненужная работа, а во втором - система будет давать неверные ответы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы исправить эти два недостатка, мы нуждаемся в более совершенном способе взаимодействия между пользователем и системой во время и после завершения процесса рассуждений. Поставим себе целью добиться того, чтобы система взаимодействовала с пользователем так, как в следующем примере диалога (ответы пользователя даются полужирным шрифтом, реплики пролог-системы — курсивом):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Пожалуйста, спрашивайте:\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b питер это тигр.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: питер имеет шерсть?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: питер ест мясо?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b нет.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: питер имеет острые зубы?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: питер имеет когти?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b почему.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Чтобы проверить по прав3, что питер это хищник,\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Чтобы проверить по прав5, что питер это тигр\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это был ваш вопрос\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: питер имеет когти?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: питер имеет глаза, направленные вперед?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: питер имеет рыжевато-коричневый цвет?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: питер имеет черные полосы?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i (питер это тигр) это правда\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Хотите узнать, как?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i питер это тигр\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  было выведено по прав5 из\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i   питер это хищник,\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i    было выведено по прав3 из\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     питер это млекопитающее\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i      было выведено по прав1 из\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i       питер имеет шерсть\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i        было сказано\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     питер имеет острые зубы\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i      было сказано\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     питер имеет когти\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i      было сказано\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     питер имеет глаза, направленные вперед\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i      было сказано\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     питер имеет рыжевато-коричневый цвет\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i      было сказано\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     питер имеет черные полосы\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i      было сказано\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как видно из диалога, система задает пользователю вопросы, касающиеся "примитивной" информации, например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: питер ест мясо?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эту информацию нельзя отыскать в базе знаний или вывести из другой информации. На подобные вопросы пользователь может отвечать двумя способами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) сообщив системе в качестве ответа на вопрос необходимую информацию или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) спросив систему, \i почему\i0   эта информация необходима.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Последняя из двух возможностей полезна, поскольку она позволяет пользователю заглянуть внутрь системы и увидеть ее текущие намерения. Пользователь спросит "почему" в том случае, когда вопрос системы покажется ему не относящимся к делу либо когда ответ на вопрос системы потребует от него дополнительных усилий. Из объяснений системы пользователь поймет, стоит ли информация, которую запрашивает система, тех дополнительных усилий, которые необходимо приложить для ее приобретения. Предположим, например, что система спрашивает: "Это животное ест мясо?" Пользователь, не знающий ответа на этот вопрос, поскольку он никогда не видел, как это животное ело что-либо, может решить, что не стоит ждать, пока он застанет животное за едой и убедится, что оно действительно ест мясо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы заглянуть внутрь системы и до какой-то степени представить себе протекающий в ней процесс рассуждений, можно воспользоваться прологовскими средствами трассировки. Но эти средства в большинстве случаев окажутся недостаточно гибкими для наших целей. Поэтому, вместо того, чтобы воспользоваться собственным механизмом интерпретации Пролога, который не сможет справиться с нужным нам способом взаимодействия с пользователем, мы создадим свое средство интерпретации в виде специальной надстройки над пролог-системой. Этот новый интерпретатор будет включать в себя средства для взаимодействия с пользователем.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.4.1. Процесс рассуждений\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наш интерпретатор будет принимать вопрос и искать на него ответ. Язык правил допускает, чтобы в условной части правила была И/ИЛИ-комбинация условий. Вопрос на входе интерпретатора может быть такой же комбинацией подвопросов. Поэтому процесс поиска ответов на эти вопросы будет аналогичен процессу поиска в И/ИЛИ-графах, который мы обсуждали в гл. 13.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответ на заданный вопрос можно найти несколькими способами в соответствии со следующими принципами:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Для того, чтобы найти ответ \i Отв\i0   на вопрос \i В\i0  , используйте одну из следующих возможностей:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • если \i В\i0   найден в базе знаний в виде факта, то \i Отв\i0   — это "\i В\i0   это правда"\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • если в базе знаний существует правило вида\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600   "если \i Условие\i0   то \i В\i0  ",\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 то для получения ответа \i Отв\i0   рассмотрите \i Условие\i0  \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • если вопрос \i В\i0   можно задавать пользователю, спросите пользователя об истинности \i В\i0  \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • если в имеет вид \i В1 и В2\i0  , то рассмотрите \i В1\i0  , а затем,\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600   если \i В1 \i0  ложно, то положите \i Отв \i0  равным "\i В \i0  это ложь",  в противном случае рассмотрите \i В2 \i0  и получите \i Отв \i0  как соответствующую комбинацию ответов на вопросы \i В1\i0   и \i В2\i0  \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 • если \i В\i0   имеет вид \i В1 или В2\i0  , то рассмотрите \i В1\i0  , а затем,\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600   если \i В1\i0   истинно, то положите \i Отв\i0   равным "\i В1\i0   это правда",  в противном случае рассмотрите \i В2\i0   и получите \i Oтв\i0   как соответствующую комбинацию ответов на вопросы \i В1\i0   и \i В2\i0  .\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вопросы вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i не В\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обрабатываются не так просто, и мы обсудим их позже. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.4.2. Формирование ответа на вопрос "почему"\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вопрос "\i почему\i0  " возникает в ситуации, когда система просит пользователя сообщить ей некоторую информацию, а пользователь желает знать, \i почему\i0   эта информация необходима. Допустим, что система спрашивает:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i а — это правда?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В ответ пользователь может спросить:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b почему?\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Объяснение в этом случае выглядит примерно так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Потому, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я могу использовать \i а\i0  ,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   чтобы проверить по правилу \i П\sub а\nosupersub \i0  , что \i b\i0  , и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я могу использовать \i b\i0  ,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   чтобы проверить по правилу \i П\sub b\nosupersub \i0  , что \i с\i0  , и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я могу использовать \i с\i0  ,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   чтобы проверить по правилу \i П\sub c\nosupersub \i0  , что \i d\i0  , и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 …\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Я могу использовать \i y\i0  ,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   чтобы проверить по правилу \i П\sub y\nosupersub \i0  , что \i z\i0  , и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i z\i0   — это ваш исходный вопрос.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Объяснение — это демонстрация того, как система намерена использовать информацию, которую она хочет получить от пользователя. Намерения системы демонстрируются в виде цепочки правил и целей, соединяющей эту информацию с исходным вопросом.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.8.\b0   Объяснение типа "почему". На вопрос "Почему вас интересует текущая цель?" дается объяснение в виде цепочки правил и целей, соединяющей текущую цель с исходным вопросом пользователя, находящимся в верхушке дерева. Эта цепочка называется трассой.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Будем называть такую цепочку \i трассой\i0  . Трассу можно себе представлять как цепочку правил, соединяющую в И/ИЛИ-дереве вопросов текущую цель с целью самого верхнего уровня так, как это показано на рис. 14.8. Таким образом, для формирования ответа на вопрос "почему" нужно двигаться в пространстве поиска от текущей цели вверх вплоть до самой верхней цели. Для того, чтобы суметь это сделать, нам придется в процессе рассуждений сохранять трассу в явном виде. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.4.3. Формирование ответа на вопрос "как"\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Получив ответ на свой вопрос, пользователь возможно захочет увидеть, \i как\i0   система пришла к такому заключению. Один из подходящих способов ответить на вопрос "как" — это представить доказательство, т.е. те правила и подцели, которые использовались для достижения полученного заключения. Это доказательство в случае нашего языка записи правил имеет вид решающего И/ИЛИ-дерева. Поэтому наша машина логического вывода будет не просто отвечать на вопрос, соответствующий цели самого верхнего уровня — этого нам недостаточно, а будет выдавать в качестве ответа решающее И/ИЛИ-дерево, составленное из имен правил и подцелей. Затем это дерево можно будет отобразить на выходе системы в качестве объяснения типа "как". Объяснению можно придать удобную для восприятия форму, если каждое поддерево печатать с надлежащим отступом, например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i питер это хищник\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  было выведено по прав3 из\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i   питер это млекопитающее\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i    было выведено по прав1 из\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i     питер имеет шерсть\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i      было сказано\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i   и\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i   питер ест мясо\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i    было сказано\i0  \par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 14.5. Реализация\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь мы приступим к реализации нашей оболочки, следуя тем идеям, которые обсуждались в предыдущем разделе. На рис. 14.9 показаны основные объекты, которыми манипулирует оболочка. Цель — это вопрос, подлежащий рассмотрению; Трасса — это цепочка, составленная из "целей-предков" и правил, находящихся между вершиной Цель и вопросом самого верхнего уровня; Ответ — решающее дерево типа И/ИЛИ для вершины Цель.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.9.\b0   Отношение рассмотреть( Цель,  Трасса,  Ответ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответ — это И/ИЛИ решающее дерево для целевого утверждения Цель.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основными процедурами оболочки будут:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель, Трасса, Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта процедура находит ответ Ответ на вопрос Цель. Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, Трасса, Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 порождает решения для тех вопросов Цель, которые можно задавать пользователю. Она спрашивает пользователя об истинности утверждения Цель, а также отвечает на вопросы "почему". Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выдать( Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выводит результат и отвечает на вопросы "как". Все эти процедуры приводятся в действие процедурой-драйвером эксперт.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.5.1. Процедура рассмотреть\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Центральной процедурой оболочки является процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель, Трасса, Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которая будет находить ответ Ответ на заданный вопрос Цель, используя принципы, намеченные в общих чертах в разд. 14.4.1: найти Цель среди фактов базы знаний, или применить правило из базы знаний, или спросить пользователя, или же обработать Цель как И/ИЛИ-комбинацию подцелей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Аргументы имеют следующий смысл и следующую структуру:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вопрос, подлежащий рассмотрению, представленный как И/ИЛИ-комбинация простых утверждений, например\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X имеет перья или X летает или\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X откладывает яйца\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Трасса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цепочка, составленная из целей-предков и правил, расположенных между Цель и исходной целью самого верхнего уровня. Представляется как список, состоящий из элементов вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Цель  по  Прав\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  что означает: Цель рассматривалась с использованием правила Прав. Например, пусть исходной целью будет "питер это тигр", а текущей целью — "питер ест мясо". В соответствии с базой знаний рис. 14.5 имеем трассу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [( питер это хищник) по прав3,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   ( питер это тигр) по прав5 ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Смысл ее можно выразить так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Я могу использовать "питер ест мясо" для того, чтобы проверить по прав3, что "питер это хищник".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Далее, я могу использовать "питер это хищник" для того, чтобы проверить по прав5, что "питер это тигр".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  решающее И/ИЛИ-дерево для вопроса Цель. Общая форма представления для объекта Ответ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Заключение было Найдено\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Найдено — это обоснование для результата Заключение. Следующие три примера иллюстрируют различные варианты ответов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) ( соед( радиатор, предохр1) это правда) было \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    'найдено как факт'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) (питер ест мясо) это ложь было сказано \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) (питер это хищник) это правда было \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ( 'выведено по' прав3 из\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    (питер это млекопитающее) это правда было\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ( 'выведено по' прав1 из\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    (питер имеет шерсть) это правда было сказано)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    (питер ест мясо) это правда было сказано )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 14.10 показана прологовская программа для процедуры рассмотреть. В этой программе реализованы принципы разд. 14.4.1 с использованием только что описанных структур данных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % рассмотреть( Цель, Трасса, Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % находит Ответ на вопрос Цель. Трасса - это цепочка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % целей-предков и правил. "рассмотреть" стремится найти\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % положительный ответ на вопрос. Ответ "ложь" выдается\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % только в том случае, когда рассмотрены все возможности,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % и все они дали результат "ложь".\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 900, xfx, :).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 800, xfx, было).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 870, fx, если).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 880, xfx, то).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 550, xfy, или).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 540, xfy, и).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 300, fx, 'выведено по').\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 600, xfx, из).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 600, xfx, по).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % В программе предполагается,что op( 700, хfх, это), op( 500, fx, не)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель, Трасса, Цель это правда\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  было 'найдено как факт') :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  факт : Цель.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Предполагается, что для каждого типа цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % существует только одно правило\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель, Трасса,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Цель это ПравдаЛожь\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  было 'выведено по' Прав из Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Прав : если Условие то Цель,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Правило, относящееся к цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Условие, [Цель по Прав | Трасса], Ответ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  истинность( Ответ, ПравдаЛожь).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель1 и Цель2, Трасса, Ответ) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Цель1, Трасса, Ответ1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  продолжить( Ответ1, Цель1 и Цель2, Трасса, Ответ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель1 или Цель2, Трасса, Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассм_да( Цель1, Трасса, Ответ);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Положительный ответ на Цель1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассм_да( Цель2, Трасса, Ответ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Положительный ответ на Цель2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель1 или Цель2, Трасса,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Ответ1 и Ответ2) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not рассм_да( Цель1, Трасса, _ ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not рассм_да( Цель2, Трасса, _ ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Нет положительного ответа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Цель1, Трасса, Ответ1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Ответ1 отрицательный\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Цель2, Трасса, Ответ2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Ответ2 отрицательный\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель, Трасса,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Цель это Ответ было сказано) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ответпольз( Цель, Трасса, Ответ). % Ответ дан пользователем\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассм_да( Цель, Трасса, Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Цель, Трасса, Ответ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  положительный( Ответ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 продолжить( Ответ1, Цель1 и Цель2, Трасса, Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  положительный( Ответ1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Цель2, Трасса, Ответ2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( положительный( Ответ2), Ответ = Ответ1 и Ответ2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отрицательный( Ответ2), Ответ = Ответ2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 продолжить( Ответ1, Цель1 и Цель2, _, Ответ1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отрицательный( Ответ1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинность( Вопрос это ПравдаЛожь было Найдено,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ПравдаЛожь) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинность( Ответ1 и Ответ2, ПравдаЛожь) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  истинность( Ответ1, правда),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  истинность( Ответ2, правда), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ПравдаЛожь = правда;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ПравдаЛожь = ложь.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 положительный( Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  истинность( Ответ, правда).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отрицательный( Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  истинность( Ответ, ложь).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.10.\b0   Основная процедура оболочки экспертной системы. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.5.2. Процедура ответпольз\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем перейти к написанию процедуры ответпольз, давайте рассмотрим одну полезную вспомогательную процедуру\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принять( Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В процессе диалога часто возникает ситуация, когда от пользователя ожидается ответ "да", "нет" или "почему". Процедура принять предназначена для того, чтобы извлечь один из этих ответов, понимая его правильно и в тех случаях, когда пользователь применяет сокращения ('д' или 'н') или делает ошибки. Если ответ пользователя непонятен, то принять просит дать другой вариант ответа.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принять( Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( Ответ1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  означает( Ответ1, Значение), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Ответ1 означает что-нибудь?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Ответ = Значение;                          % Да\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( 'Непонятно, попробуйте еще раз, % Нет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              пожалуйста'), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принять( Ответ). % Новая попытка\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает( да, да).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает( д, да).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает( нет, нет).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает( н, нет).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает( почему, почему).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает( п, почему).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следует заметить, что процедурой принять нужно пользоваться с осторожностью, так как она содержит взаимодействие с пользователем. Следующий фрагмент программы может служить примером неудачной попытки запрограммировать интерпретацию ответов пользователя:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принять( да), интерп_да( ...);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принять( нет), интерп_нет( ...);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь, если пользователь ответит "нет", то программа попросит его повторить свой ответ. Поэтому более правильный способ такой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принять( Ответ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Ответ = да, интерп_да( ...);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Ответ = нет, интерп_нет( ...);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    ... )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, Трасса, Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 спрашивает пользователя об истинности утверждения Цель. Ответ — это результат запроса. Трасса используется для объяснения в случае, если пользователь спросит "почему".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сначала процедура ответпольз должна проверить, является ли Цель информацией, которую можно запрашивать у пользователя. Это свойство объекта Цель задается отношением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( Цель)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которое в дальнейшем будет усовершенствовано. Если спросить можно, то утверждение Цель выдается пользователю, который, в свою очередь, указывает истинно оно или ложно. Если пользователь спросит "почему", то ему выдается Трасса. Если утверждение Цель истинно, то пользователь укажет также значения содержащихся в нем переменных (если таковые имеются).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Все вышеизложенное можно запрограммировать (в качестве первой попытки) следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 остветпольз( Цель, Трасса, Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  можно_спросить( Цель), % Можно ли спрашивать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  спросить( Цель, Трасса, Ответ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Задать вопрос относительно утверждения Цель\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 спросить( Цель, Трасса, Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  показать( Цель),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Показать пользователю вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принять(Ответ1),       % Прочесть ответ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обработать( Ответ1, Цель, Трасса, Ответ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Обработать ответ\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( почему, Цель, Трасса, Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Задан вопрос "почему"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  показать_трассу( Трасса),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Выдача ответа на вопрос "почему"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  спросить( Цель, Трасса, Ответ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Еще раз спросить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( да, Цель, Трасса, Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Пользователь ответил, что Цель истинна\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Ответ = правда,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  запрос_перем( Цель);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Вопрос о значении переменных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  спросить( Цель, Трасса, Ответ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Потребовать от пользователя новых решений\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( нет, Цель, Трасса, ложь).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Пользователь ответил, что Цель ложна\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 показать( Цель) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( 'Это правда:'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Цель), write( ?), nl.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обращение к процедуре запрос_перем( Цель) нужно для того, чтобы попросить пользователя указать значение каждой из переменных, содержащихся в утверждении Цель:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 запрос_перем( Терм) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  var( Терм), !, % Переменная ?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( Терм), write( '='),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( Терм).   % Считать значение переменной\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 запрос_перем( Терм) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Терм =.. [Функтор | Аргументы],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Получить аргументы структуры\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  запрос_арг( Аргументы).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Запросить значения переменных в аргументах\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 запрос_арг( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 запрос_арг( [Терм | Термы]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  запрос_перем( Терм),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  запрос_арг( Термы).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Проведем несколько экспериментов с процедурой ответпольз. Пусть, например, известно, что пользователя можно спрашивать о наличии бинарного отношения ест:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( X ест Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (В приведенных ниже диалогах между пролог-системой и пользователем тексты пользователя даются \b полужирным шрифтом\b0  , а реплики пролог-системы \i курсивом\i0  ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b ?- ответпольз( питер ест мясо, [], Ответ).\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: питер ест мясо?\i0   % Вопрос пользователю\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0                           % Ответ пользователя\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Ответ = правда\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Более интересный пример диалога (с использованием переменных) мог бы выглядеть примерно так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b ?- ответпольз( Кто ест Что, [], Ответ).\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: _17 ест _18?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Пролог дает переменным свои внутренние имена\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i _17 =\i0  \b питер\b0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i _18 =\i0  \b мясо\b0  .\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Ответ = правда.\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Кто = питер\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Что = мясо;\i0   % Возврат для получения других решений\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: _17 ест _18?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i _17 =\i0  \b сьюзен.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i _18\i0   = \b бананы.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Ответ = правда\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Кто = сьюзен\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Что = бананы;\i0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда : _17 ест _18?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b нет.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Ответ = ложь\i0  \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.5.3. Усовершенствование процедуры ответпольз\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Один из недостатков нашей процедуры ответпольз, который хорошо виден из приведенного выше диалога, — это появление на выходе системы имен, генерируемых пролог-системой, что выглядит довольно неуклюже. Символы, подобные _17, следовало бы заменить на более осмысленные слова.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другой, более серьезный дефект этой версии процедуры ответпольз состоит в следующем. Если мы еще раз обратимся к ответпольз, задав ту же самую цель, то пользователю придется повторно вводить все варианты решений. Поэтому, если наша экспертная система придет в процессе рассуждений к рассмотрению той же самой цели второй раз, то, вместо того, чтобы использовать информацию, уже полученную от пользователя, она проведет с пользователем в точности тот же самый скучный диалог.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте исправим эти два дефекта. Во-первых, улучшение внешнего вида запросов системы будет основано на введении стандартного формата для каждой "запрашиваемой" цели. Для этого в отношение можно_спросить мы добавим второй аргумент, который и будет задавать этот формат, как видно из следующего примера:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить(X ест Y, 'Животное' ест 'Что-то').\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При передаче запроса пользователю каждая переменная вопроса должна быть заменена на ключевое слово, взятое из формата, например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b ?- ответпольз( X ест Y, [], Ответ).\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: Животное ест Что-то?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Животное =\i0  \b питер.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Что-то =\i0  \b мясо.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Ответ = правда\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i X = питер\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Y = мясо\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В улучшенной версии процедуры ответпольз, показанной на рис. 14.11, такое форматирование запросов выполняется процедурой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 формат( Цель, ВнешФормат, Вопрос, Перем0, Перем )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь Цель — утверждение, которое нужно форматировать. ВнешФормат определяет внешний формат этого утверждения, задаваемый отношением\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можно_спросить( Цель, ВнешФормат)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вопрос — это Цель, отформатированная в соответствии с ВнешФормат. Перем — список переменных, входящих в Цель, вместе с соответствующими ключевыми словами (как указано в ВнешФормат), причем список Перем получается из списка Перем0 добавлением новых переменных. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- формат( X передает документы Y,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  'Кто' передает 'Что' 'Кому',\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Вопрос, [], Перем).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вопрос = 'Кто' передает документы 'Кому',\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Перем = [ X/'Кто', Y/'Кому'].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Второе усовершенствование, состоящее в устранении повторных вопросов к пользователю, будет более трудным. Во-первых, все ответы пользователя следует запоминать, с тем чтобы их можно было отыскать в памяти в более поздний момент времени. Для этого достаточно сделать ответы пользователя элементами некоторого отношения и применить assert, например\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 assert( сказано( мери передает документы друзьям, правда) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В ситуации, когда имеется несколько решений, предложенных пользователем для одной и той же цели, в память относительно нее будет записано несколько фактов. Здесь возникает одно осложнение. Допустим, что в нескольких местах программы встречаются различные варианты некоторой цели (отличающиеся именованием переменных). Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ( X имеет Y) и   % Первый вариант - Цель1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ( X1 имеет Y1) и % Второй вариант - Цель2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Допустим также, что пользователя просят (через механизм возвратов) предложить несколько решений для Цель1. Затем процесс рассуждений продвигается вплоть до Цель2. Так как у нас уже есть несколько решений для Цель1, мы захотим, чтобы система автоматически применила их и к Цель2 (поскольку очевидно, что они удовлетворяют Цель2). Теперь предположим, что система пытается применить эти решения к Цель2, но ни одно из них не удовлетворяет некоторой другой цели, расположенной ниже. Система делает возврат к Цель2 и просит пользователя предложить новые решения. Если пользователь введет еще несколько решений, то их также придется запомнить. И если система в дальнейшем сделает возврат к Цель1, то эти новые решения надо будет применить к Цель1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы правильным образом использовать информацию, вводимую пользователем по запросам из разных точек программы, мы будем снабжать каждую такую информацию специальным индексом. Таким образом, факты, запоминаемые системой, будут иметь вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сказано( Цель, Истинность, Индекс)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Индекс — это значение счетчика, ответов пользователя. Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, Трасса, Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 теперь должна будет отслеживать число решений, уже порожденных механизмом возвратов к моменту обращения к этой процедуре. Это можно сделать при помощи другого варианта процедуры ответпольз с четырьмя аргументами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, Трасса, Ответ, N)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где N — некоторое целое число. Такое обращение к ответпольз должно порождать решения для Цель с индексами, начиная с N и далее. Обращение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, Трасса, Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соответствует получению \i всех\i0   решений, индексируемых, начиная с 1, поэтому мы имеем следующее соотношение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, Трасса, Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ответпольз( Цель, Трасса, Ответ, 1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Принцип работы процедуры\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, Трасса, Ответ, N)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 таков: сначала получить решения для Цель, отыскивая в памяти все уже известные решения с индексами, начиная с N и далее. Когда все старые решения исчерпаются, начать задавать вопросы пользователю относительно утверждения Цель, записывая полученные таким образом новые решения в память при помощи assert и индексируя их должным образом при помощи целых чисел. Когда пользователь сообщит, что больше нет решений, записать в память факт\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конец_ответов( Цель)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если пользователь с самого начала скажет, что решений нет вообще, то записать факт\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сказано( Цель, ложь, Индекс)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Находя в памяти те или иные решения, процедура ответпольз должна правильно интерпретировать подобную информацию.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Однако существует еще одна трудность. Пользователь может, оставляя некоторые переменные неконкретизированными, указывать общие решения. Если найдено положительное решение, более общее, чем Цель, или столь же общее, как Цель, то нет смысла продолжать задавать вопросы об утверждении Цель, поскольку мы уже имеем более общее решение. Аналогичным образом следует поступить, если обнаружен факт\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сказано( Цель, ложь, _ )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа ответпольз, показанная на рис. 14.11, учитывает все вышеприведенные соображения. В нее введен новый аргумент Копия (копия утверждения Цель), который используется в нескольких случаях сопоставлений вместо Цель, с тем чтобы оставить в неприкосновенности переменные утверждения Цель. Эта программа использует также два вспомогательных отношения. Одно из них\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конкретный( Терм)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 истинно, если Терм не содержит переменных. Другое\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конкретизация( Терм, Терм1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает, что Терм1 есть некоторая конкретизация (частный случай) терма Терм, т.е. Терм — это утверждение не менее общее, чем Терм1. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конкретизация( X передает информацию Y,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  мэри передает информацию Z)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обе процедуры основаны на еще одной процедуре:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нумпер( Терм, N, М)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта процедура "нумерует" переменные, содержащиеся в Терм, заменяя каждую из них на некоторый специальный новый терм таким образом, чтобы эти "нумерующие" термы соответствовали числам от N до M–1, Например, пусть эти термы имеют вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пер/0, пер/1, пер/2, ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тогда в результате обращения к системе\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- Терм = f( X, t( a,Y, X) ), нумпер( Терм, 5, М).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мы получим\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Терм = f( пер/5, t( а, пер/6, пер/5) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 М = 7\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % ответпольз( Цель, Трасса, Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % порождает, используя механизм возвратов, все решения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % для целевого утверждения Цель, которые указал пользователь.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Трасса - это цепочка целей-предков и правил,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % используемая для объяснения типа "почему".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, Трасса, Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  можно_спросить( Цель, _ ), % Можно спросить?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  копия( Цель, Копия),       % Переименование переменных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ответпольз( Цель, Копия, Трасса, Ответ, 1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Не спрашивать второй раз относительно конкретизированной цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, _, _, _, N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N > 1,                     % Повторный вопрос?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конкретный( Цель),  !,     % Больше не спрашивать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  fail.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Известен ли ответ для всех конкретизации утверждения Цель?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, Копия, _, Ответ, _ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сказано( Копия, Ответ, _ ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конкретизация( Копия, Цель), !. % Ответ известен\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Найти все известные решения для Цель с индексами, начиная с N\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, _, _, правда, N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сказано( Цель, правда, М),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  М >= N.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Все уже сказано об утверждении Цель?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, Копия, _, Ответ, _) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конец_ответов( Копия),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конкретизация( Копия, Цель), !, % Уже все сказано\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  fail.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Попросить пользователя дать (еще) решения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответпольз( Цель, _, Трасса, Ответ, N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  спросить_польз( Цель, Трасса, Ответ, N).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 спросить_польз( Цель, Трасса, Ответ, N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  можно спросить( Цель, ВнешФормат),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  формат( Цель, ВнешФормат, Вопрос, [], Перем),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Получить формат вопроса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  спросить( Цель, Вопрос, Перем, Трасса, Ответ, N).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 спросить( Цель, Вопрос, Перем, Трасса, Ответ, N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Перем = [], !,                % Сформулировать вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( 'Это правда: ');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( 'Есть (еще) решения для :' )),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Вопрос), write( '?'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принять( Ответ1), !,            % Ответ1 - да/нет/почему\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обработать( Ответ1, Цель, Вопрос, Перем,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              Трасса, Ответ, N).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( почему, Цель, Вопрос, Перем,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Трасса, Ответ, N):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выд_трассу( Трасса),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  спросить( Цель, Вопрос, Перем, Трасса, Ответ, N).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( да, Цель,_, Перем, Трасса, правда, N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  след_индекс( Инд),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Получить новый индекс для "сказано"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Инд1 is Инд + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( запрос_перем( Перем),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    assertz( сказано( Цель, правда, Инд) );\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     % Запись решения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  копия( Цель, Копия),            % Копирование цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ответпольз( Цель, Копия, Трасса, Ответ, Инд1) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Есть еще решения?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( нет, Цель, _, _, _, ложь, N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  копия( Цель, Копия),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сказано( Копия, правда, _), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % 'нет' означает, больше нет решений\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  assertz( конец_ответов( Цель) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Отметить конец ответов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  fail;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  след_индекс( Инд),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Следующий свободный индекс для "сказано"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  assertz( сказано( Цель, ложь, Инд) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % 'нет' означает нет ни одного решения\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 формат( Пер, Имя, Имя, Перем, [Пер/Имя | Перем]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  var( Пер), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 формат( Атом, Имя, Атом, Перем, Перем) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  atomic( Атом), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  atomic( Имя).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 формат( Цель, Форм, Вопрос, Перем0, Перем) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Цель =.. [Функтор | Apг1],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Форм =.. [Функтор | Форм1],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  формвсе( Apг1, Форм1, Арг2, Перем0, Перем),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Вопрос =.. [Функтор | Арг2].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 формвсе( [], [], [], Перем, Перем).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 формвсе( [X | СпХ], [Ф | СпФ], [В | СпВ], Перем0, Перем) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  формвсе( СпХ, СпФ, СпВ, Перем0, Перем1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  формат( X, Ф, В, Перем1, Перем).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 запрос_перем( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 запрос_перем( [Переменная/Имя | Переменные]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( Имя), write( '='),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( Переменная),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  запрос_перем( Переменные).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выд_трассу( []) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( 'Это был ваш вопрос'), nl.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выд_трассу( [Цель по Прав | Трасса] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( 'Чтобы проверить по' ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Прав), write( ', что'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Цель),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выд_трассу( Трасса).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конкретный( Терм) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  нумпер( Терм, 0, 0).            % Нет переменных в Терм'е\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % конкретизация( Т1, Т2) означает, что Т2 - конкретизация Т1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % т.е. терм Т1 - более общий, чем Т2, или той же степени\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % общности, что и Т2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конкретизация( Терм, Терм1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Терм1 - частный случай Терм'а\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  копия( Терм1, Терм2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Копия Терм1 с новыми переменными\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  нумпер( Терм2, 0, _), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Терм = Терм2.       % Успех, если Терм1 - частный случай Терм2\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 копия( Терм, НовТерм) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Копия Терм' а с новыми переменными\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  asserta( copy( Терм) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  retract( сору( НовТерм) ), !.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 посл_индекс( 0).     % Начальный индекс для "сказано"\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 след_индекс( Инд) :- % Следующий индекс для "сказано"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  retract( посл_индекс( ПослИнд) ), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Инд is ПослИнд + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  assert( посл_индекс( Инд) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.11.\b0   Оболочка экспертной системы: Вопросы к пользователю и ответы на вопросы "почему".\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Отношение, подобное нумпер, часто входит в состав пролог-системы в качестве встроенной процедуры. Если это не так, то его можно реализовать программно следующим способом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нумпер( Терм, N, Nплюс1) :- \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  var( Терм), !, % Переменная? \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Терм = пер/N, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Nплюс1 is N + 1. \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нумпер( Терм, N, М) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Терм =.. [Функтор | Аргументы], % Структура или атом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  нумарг( Аргументы, N, M).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Пронумеровать переменные в аргументах\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нумарг( [], N, N) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нумарг( [X | Спис], N, M) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  нумпер( X, N, N1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  нумарг( Спис, N1, М).\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.5.4. Процедура  выдать\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выдать( Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 приведенная на рис. 14.12, показывает пользователю окончательный результат консультационного сеанса и дает объяснения типа "как". Ответ включает в себя как ответ на вопрос пользователя, так и дерево вывода, демонстрирующее \i как\i0   система пришла к такому заключению. Сначала процедура выдать представляет пользователю свое заключение. Затем, если пользователь пожелает узнать, \i как\i0   это заключение достигнуто, то печатается дерево вывода в некоторой удобной для восприятия форме - это и есть объяснение типа "как". Форма объяснения показана в примере разд. 14.4.3.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.5.5. Драйвер верхнего уровня\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И наконец, для того, чтобы иметь удобный доступ к оболочке из интерпретатора Пролога, нам необходима процедура, выполняющая функцию "драйвера". На рис. 14.13 показано, как могла бы выглядеть предназначенная для этой цели процедура эксперт. Драйвер эксперт производит запуск трех основных модулей оболочки (рис. 14.10–14.12) и координирует их работу. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b ?- эксперт.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Пожалуйста, спрашивайте:\i0         % Приглашение пользователю\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b X это животное и голиаф это X.\b0   % Вопрос пользователя\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда:  голиаф имеет шерсть?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b ...\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Выдача заключения консультационного сеанса и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % объяснения типа "как"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выдать( Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, заключение( Ответ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( 'Хотите узнать, как?'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принять( Ответ1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Ответ1 = да, !, отобр( Ответ);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    true).                        % Показ решающего дерева\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 заключение( Ответ1 и Ответ2) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  заключение( Ответ1), write( 'и'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  заключение( Ответ2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 заключение( Заключение было Найдено) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Заключение).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % "отобр" отображает полное решающее дерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( Решение) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, отобр( Решение, 0), !.      % Отступ 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( Ответ1 и Ответ2, H) :- !, % Отступ H\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Ответ1, H),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( H), write( 'и'), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Ответ2, H).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( Ответ был Найден, H) :-   % Отступ H\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  tab( H), печответ( Ответ),      % Показ заключения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, tab( H),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( 'было'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр1( Найден, H).             % Показ доказательства\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр1( Выведено из Ответ, H) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Выведено), write( 'из'), % Показ имени правила\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, H1 is H + 4,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Ответ, H1).              % Показ "предшественника"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр1( Найдено, _ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Найдено = 'сказано' или 'найдено как факт'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Найдено), nl.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 печответ( Цель это правда) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Цель).      % На выходе 'это правда' опускается\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 печответ( Ответ) :- % Отрицательный ответ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Ответ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.12.\b0   Оболочка экспертной системы: Отображение окончательного результата и объяснение типа "как".\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.5.6. Одно замечание по поводу программы-оболочки\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В некоторых местах нашей программы-оболочки обнаруживается недостаток той "декларативной ясности", которая так характерна для программ, написанных на Прологе. Причина состоит в том, что нам пришлось предусмотреть в этой программе довольно жесткое управление процессом функционирования оболочки. Ведь, согласно нашему замыслу, экспертная система должна была не только находить ответы на вопросы, но и делать это некоторым разумным с точки зрения пользователя способом. В связи с этим нам пришлось реализовать вполне определенное \i поведение\i0   системы в процессе решения задач, а не просто некоторое отношение ввода-вывода. В результате получилась программа более процедурного характера, чем обычно. Все это может послужить примером ситуации, когда, не имея возможности рассчитывать на собственные процедурные механизмы Пролога, мы вынуждены взять на себя детальное описание процедурного поведения системы.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.5.7. Цели с отрицанием\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Использование знака отрицания в левых частях правил, а следовательно, и в вопросах, обрабатываемых процедурой рассмотреть, представляется естественным и его следует разрешить. В качестве первой попытки можно предложить следующий способ работы с отрицанием целей:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( не Цель, Трасса, Ответ) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Цель, Трасса, Ответ1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обратить( Ответ1, Ответ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Получить обратное истинностное значение\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обратить( Цель это правда было Найдено,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( не Цель) это ложь было Найдено).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обратить( Цель это ложь было Найдено,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( не Цель) это правда было Найдено).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Процедура-драйвер верхнего уровня\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 эксперт :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принять_вопрос( Вопрос),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Ввести вопрос пользователя\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( ответ_да( Вопрос);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Попытка найти положительный ответ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ответ_нет( Вопрос) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Если нет положительного ответа, то найти отрицательный\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответ_да( Вопрос) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Искать положительный ответ на Вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  статус( отрицательный),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Пока еще нет положительного ответа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Вопрос, [], Ответ), % Трасса пуста\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  положительный( Ответ), % Искать положительный ответ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  статус( положительный),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Найден положительный ответ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выдать( Ответ), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( 'Нужны еще решения?' ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принять( Ответ1), % Прочесть ответ пользователя\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Ответ1 = нет.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % В противном случае возврат к "рассмотреть"\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ответ_нет( Вопрос):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Искать отрицательный ответ на Вопрос\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  retract( пока_нет_положительного_решения), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Не было положительного решения?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Вопрос, [], Ответ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отрицательный( Ответ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выдать( Ответ), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( 'Нужны еще решения?' ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принять( Ответ1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Ответ1 = нет.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % В противном случае - возврат к "рассмотреть"\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 статус( отрицательный) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  assert( пока_нет_положительного_решения).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 статус( положительный) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  retract( пока_нет_положительного_решения), !; true.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принять_вопрос( Вопрос) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( 'Пожалуйста, спрашивайте:'), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( Вопрос).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.13.\b0   Оболочка экспертной системы: драйвер. Обращение к оболочке из Пролога при помощи процедуры эксперт.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если Цель конкретизирована, то все в порядке, если же нет, то возникают трудности. Рассмотрим, например, такой диалог:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b ?- эксперт.\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Пожалуйста, спрашивайте:\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b не ( X ест мясо).\b0  \par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Есть (еще) решения для : Животное\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Животное =\i0  \b тигр\b0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этот момент система даст ответ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i не ( тигр ест мясо) это ложь\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такой ответ нас не может удовлетворить. Источник затруднения следует искать в том, какой смысл мы вкладываем в вопросы типа\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 не ( X ест мясо)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В действительности мы хотим спросить: "Существует ли такой X, что X не ест мяса?" Однако процедура рассмотреть (так как мы ее определили) проинтерпретирует этот вопрос следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Существует ли такой X, что X ест мясо?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Да, тигр ест мясо.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Итак,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) не (тигр ест мясо) это ложь.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Короче говоря, интерпретация такова — "Правда ли, что никакой X не ест мясо?" Положительный ответ мы получим, только если \i никто\i0   не ест мяса. Можно также сказать, что процедура рассмотреть отвечает на вопрос так, как будто X находится под знаком квантора \i всеобщности\i0  :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  для \i всех\i0   X: не (X ест мясо)?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 а не квантора существования, в чем и состояло наше намерение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  для \i некоторого\i0   X: не (X ест мясо)?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Если рассматриваемый вопрос конкретизирован, то проблемы исчезают. В противном случае правильный способ работы с отрицаниями становится более сложным. Например, вот некоторые из возможных правил:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы рассмотреть \i (не Цель)\i0  , рассмотрите \i Цель\i0  , а затем:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • если \i Цель\i0   это ложь, то \i (не Цель)\i0   это правда;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • если \i Цель'\i0   — это некоторое решение для \i Цель\i0  , и \i Цель'\i0   — утверждение той же степени общности, что и \i Цель\i0  , то \i (не Цель)\i0   это ложь;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • если \i Цель'\i0   — это некоторое решение для \i Цель\i0  , и \i Цель'\i0   — более конкретное утверждение, чем \i Цель\i0  , то об утверждении \i (не Цель)\i0   нельзя сказать ничего определенного.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Можно избежать всех этих осложнений, если потребовать, чтобы отрицания стояли только перед конкретизированными целями. Если правила базы знаний формулировать должным образом, то часто удается удовлетворить этому условию. Нам это удалось в "правиле поломки" (рис. 14.7):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 правило_поломки:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   вкл( Прибор) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   прибор( Прибор) и % Конкретизация\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   не работает( Прибор) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   соед( Прибор, Предохр) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   доказано( цел( Предохр) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   доказано( неиспр( Прибор) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь условие\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прибор( Прибор)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 "защищает" следующее за ним условие\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 не работает( Прибор)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 от неконкретизированной переменной.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Упражнение\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 14.3.\b0   База знаний может, в принципе, содержать циклы. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прав1: если бутылка_пуста то джон_пьян.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прав2: если джон_пьян то бутылка_пуста.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Работая с подобной базой знаний, наша процедура рассмотреть может зациклиться на обработке одних и тех же целей. Внесите в процедуру рассмотреть изменения, предотвращающие зацикливание. Используйте для этого объект Трасса. Однако соблюдайте осторожность: если текущая цель \i сопоставима\i0   с одной из предыдущих целей, то такую ситуацию следует рассматривать как цикл только в том случае, когда текущая цель имеет большую, степень общности, чем предыдущая.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 14.6. Работа с неопределенностью \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.6.1. Степень достоверности\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша оболочка экспертной системы, описанная в предыдущем разделе, может работать только с такими вопросами (утверждениями), которые либо истинны, либо ложны. Предметные области, в которых на любой вопрос можно ответить "правда" или "ложь", называются \i категорическими\i0  . Наши правила базы знания (также, как и данные) были категорическими, это были "категорические импликации". Однако многие области экспертных знаний не являются категорическими. Как правило, в заключениях эксперта много догадок (впрочем, высказанных с большой уверенностью), которые обычно верны, но могут быть и исключения. Как данные, относящиеся к конкретной задаче, так и импликации, содержащиеся в правилах, могут быть не вполне определенными. Неопределенность можно промоделировать, приписывая утверждениям некоторые характеристики, отличные от "\i истина\i0  " и "\i ложь\i0  ". Характеристики могут иметь свое внешнее выражение в форме дескрипторов, таких, как, например, \i верно\i0  , \i весьма вероятно\i0  , \i вероятно\i0  , \i маловероятно\i0  , \i невозможно\i0  . Другой способ: степень уверенности может выражаться в форме действительного числа, заключенного в некотором интервале, например между 0 и 1 или между -5 и +5. Такую числовую характеристику называют по-разному — "коэффициент определенности", "степень доверия" или "субъективная уверенность". Более естественным было бы использовать вероятности (в математическом смысле слова), но попытки применить их на практике приводят к трудностям. Происходит это по следующим причинам:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Экспертам, по-видимому, неудобно мыслить в терминах вероятностей. Их оценки правдоподобия не вполне соответствуют математическому определению вероятностей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Работа с вероятностями, корректная с точки зрения математики, потребовала бы или какой-нибудь недоступной информации, или каких-либо упрощающих допущений, не вполне оправданных с точки зрения практического приложения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Поэтому, даже если выбранная мера правдоподобия лежит в интервале 0 и 1, более правильным будет называть ее из осторожности "субъективной уверенностью", подчеркивая этим, что имеется в виду оценка, данная экспертом. Оценки эксперта не удовлетворяют всем требованиям теории вероятностей. Кроме того, вычисления над такими оценками могут отличаться от исчисления вероятностей. Но, несмотря на это, они могут служить вполне адекватной моделью того, как человек оценивает достоверность своих выводов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для работы в условиях неопределенности было придумано множество различных механизмов. Мы будем рассматривать здесь механизм, используемый в системах Prospector и AL/X для минералогической разведки и локализации неисправностей соответственно. Следует заметить, что модель, применяемая в системе Prospector, несовершенна как с теоретической, так и с практической точек зрения. Однако она использовалась на практике, она проста и может служить хорошей иллюстрацией при изложении основных принципов, а потому вполне подойдет нам, по крайней мере для первого знакомства с этой областью. С другой стороны, известно, что даже в значительно более сложных моделях не обходится без трудностей. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.6.2. Модель Prospector'а\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Достоверность событий моделируется с помощью действительных чисел, заключенных в интервале между 0 и 1. Для простоты изложения мы будем называть их "вероятностями", хотя более точный термин "субъективная уверенность". Отношения между событиями можно представить графически в форме "сети вывода". На рис. 14.14 показан пример сети вывода. События изображаются прямоугольниками, а отношения между ними — стрелками. Овалами изображены комбинации событий (И, ИЛИ, НЕ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы будем считать, что отношения между событиями (стрелки) являются своего рода "мягкими импликациями". Пусть имеются два события \i E\i0   и \i H\i0  , и пусть информация о том, что имело место событие \i E\i0  , оказывает влияние на нашу уверенность в том, что произошло событие \i H\i0  . Если это влияние является "категорической импликацией", то можно просто написать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если \i E\i0   то \i H\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В случае же "мягкой импликации" это отношение может быть менее определенным, так что ему можно приписать некоторую "силу", с которой оно действует:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если \i E\i0   то \i H\i0   с силой S\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Та сила, с которой достоверность \i E\i0   влияет на уверенность в \i H\i0  , моделируется в системе Prospector при помощи двух параметров:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i N\i0   = "коэффициент необходимости"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i S\i0    = "коэффициент достаточности"\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.14.\b0   Сеть вывода системы AL/X (заимствовано из Reiter (1980)). Числа, приписанные прямоугольникам, — априорные вероятности событий; числами на стрелках задается "сила" отношений между событиями.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В сети вывода это изображается так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i E ------------> H\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i        (N, S)\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Два события, участвующие в отношении, часто называют "фактом" и "гипотезой" соответственно. Допустим, что мы проверяем гипотезу \i H\i0  . Тогда мы будем искать такой факт \i E\i0  , который мог бы подтвердить либо опровергнуть эту гипотезу. \i S\i0   говорит нам, в какой степени \i достаточно\i0   факта \i E\i0   для подтверждения гипотезы \i H\i0  ; \i N\i0   — насколько \i необходим\i0   факт \i E\i0   для подтверждения гипотезы \i H\i0  . Если факт \i E\i0   имел место, то чем больше \i S\i0  , тем больше уверенности в \i H\i0  . С другой стороны, если не верно, что имел место факт \i E\i0  , то чем больше \i N\i0  , тем менее вероятно, что гипотеза \i H\i0   верна. В случае, когда степень достоверности \i E\i0   находится где-то между полной достоверностью и невозможностью, степень достоверности \i H\i0   определяется при помощи интерполяции между двумя крайними случаями. Крайние случаи таковы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) известно, что факта \i E\i0   не было\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) известно, что факт \i E\i0   имел место\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) ничего не известно относительно \i E\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для каждого события \i H\i0   сети вывода существует априорная вероятность \i р\sub o\nosupersub \i0  (\i H\i0  ) (безусловная) вероятность события \i H\i0   в состоянии, когда неизвестно ни одного положительного или отрицательного факта. Если становится известным какой-нибудь факт \i E\i0  , то вероятность \i H\i0   меняет свое значение с  \i р\sub o\nosupersub \i0  (\i H\i0  ) на  \i p\i0  (\i H|E\i0  ). Величина изменения зависит от "силы" стрелки, ведущей из \i E\i0   в \i H\i0  . Итак, мы начинаем проверку гипотез, принимая их априорные вероятности. В дальнейшем происходит накопление информации о фактах, что находит свое отражение в изменении вероятностей событий сети. Эти изменения распространяются по сети от события к событию в соответствии со связями между событиями. Например, рассмотрим рис. 14.14 и предположим, что получена информация о срабатывании индикатора открытия выпускного клапана. Эта информация повлияет на нашу уверенность в том, что выпускной клапан открылся, что, в свою очередь, повлияет на уверенность в том, что сместилась установка порогового давления.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.15.\b0   Правила распространения вероятностей по сети, принятые в системах Prospector и AL/X: (а) "мягкая импликация" с силой (\i N\i0  , \i S\i0  ); (b) логические комбинации отношений.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 14.15 показан один из способов реализации этого эффекта распространения информации по сети. Часть вычислений производится не над вероятностями, а над \i шансами\i0  . Это удобно, хотя в принципе и не обязательно. Между шансами и вероятностями имеет место простое соотношение:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i шанс = вер / \i0  (1\i  – вер\i0  )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i вер = шанс / \i0  (1\i  + шанс\i0  )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Пусть между \i E\i0   и \i H\i0   существует отношение "мягкой импликации", тогда, в соответствии с рис. 14.15,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i шанс\i0  (\i H|E\i0  ) \i = M * шанс\i0  (\i H\i0  )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где множитель \i M\i0   определяется априорной и апостериорной вероятностями с учетом силы (\i N, S\i0  ) связи между \i E\i0   и \i H\i0  . Предполагается, что правила Prospector'a (рис. 14.15) для вычисления вероятностей логических комбинаций событий (использующие \i min\i0   и \i max\i0  ) правильно моделируют поведение человека при оценке субъективной уверенности в таких составных событиях. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 14.6.3. Принципы реализации\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте сначала расширим правила языка, с тем чтобы получить возможность работать с неопределенностью. К каждому, правилу мы можем добавить "силовой модификатор", определяемый двумя неотрицательными действительными числами \i S \i0  и \i N\i0  . Вот соответствующий формат:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Имя Правила: если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               Условие\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               Заключение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0              с\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0               Сила( N, S).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Примеры правил рис. 14.14 можно изобразить в этой форме так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прав1 : если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          не давлоткр и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          открклап\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          открклрано\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         с\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          сила( 0.001, 2000).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прав2 : если\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          сепзапвд\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         то\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          давлоткр\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0         с\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0          сила( 0.05, 400).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы произвести соответствующее расширение оболочки экспертной системы (разд. 14.5), нам понадобится внести изменения в большинство процедур. Давайте сосредоточимся только на одной из них, а именно на процедуре\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель, Трасса, Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы предположим, что утверждение Цель не содержит переменных (как это сделано в Prospector'e и в AL/X). Это сильно упростит дело (особенно в процедуре ответпольз). Таким образом, Цель будет логической комбинацией элементарных утверждений. Например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 не давлоткр и открклап\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цепочку целей-предков и правил Трасса можно представить таким же способом, как это сделано в разд. 14.5. Однако форму представления объекта Ответ придется модифицировать для того, чтобы включить в нее вероятности. Цель и ее вероятность можно соединить в один терм следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цель : Вероятность\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Получим такой пример объекта Ответ:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 индоткр : 1 было сказано\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Смысл ответа: пользователь сообщил системе, что событие индоткр произошло, и что это абсолютно достоверно.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Представление объекта Ответ требует еще одной модификации, в связи с тем, что в одно и то же событие могут вести несколько независимых связей, которые все окажут влияние на вероятность этого события — его шанс будет помножен (рис. 14.15) на все множители. В этом случае Ответ будет содержать список всех ветвей вывода заключения. Приведем пример ответа такого рода для сети рис. 14.14 (для наглядности расположенный на нескольких строках):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 давлоткр : 1 было 'выведено по'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ прав2 из сепзапвд : 1 было сказано,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    прав5 из диагсеп : 1 было сказано ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура рассмотреть, выдающая ответы в такой форме, показана на рис. 14.16. Она обращается к предикату\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 импликация( Р0, P, Сила, Вер0, Вер)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 соответствующему отношению "мягкой импликации" (см. рис. 14.15). Р0 — априорная вероятность события \i E\i0  , а P — его апостериорная вероятность. Сила — сила импликации, представленная как\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сила( N, S)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вер0 и Вер — соответственно априорная и апостериорная вероятности гипотезы \i H\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следует заметить, что наша реализация очень проста, она обеспечивает только изменение вероятностей при распространении информации по сети вывода и иногда ведет себя недостаточно разумно. Никакого внимания не уделяется отбору для анализа наиболее важной в данный момент информации. В более сложной версии следовало бы направлять процесс поиска ответа в сторону наиболее существенных фактов. Кроме того, необходимо стремиться к тому, чтобы пользователю задавалось как можно меньше вопросов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наконец, несколько замечаний относительно новой версии процедуры ответпольз. Она будет проще, чем процедура рис. 14.11, так как в запросах, передаваемых пользователю, уже не будет переменных. На этот раз пользователь в качестве ответа введет некоторую вероятность (вместо "да" или "нет"). Если пользователю ничего неизвестно о событии, содержащемся в вопросе, то вероятность этого события не изменится. Пользователь может также задать вопрос "почему" и получить изображение объекта Трасса в качестве объяснения. Кроме того, следует разрешить пользователю задавать вопрос: "Какова текущая вероятность моей гипотезы?" Тогда, если он устал вводить новую информацию (или у него мало времени), он может прекратить консультационный сеанс, довольствуясь ответом системы, полученным на основании неполной информации.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % рассмотреть( Цель, Трасса, Ответ)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % находит степень правдоподобия утверждения "цель это правда".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Оценка правдоподобия содержится в объекте Ответ. Трасса - это\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % цепочка целей-предшественников и правил, которую можно\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % использовать в объяснении типа "почему"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель, Трасса, ( Цель: Вер) было\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  'выведено по' ПравОтв) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  bagof( Прав: если Условие то Цель с Сила, Правила),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Все правила, относящиеся к цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  априори( Цель, Вер0),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Априорная вероятность цели\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  модиф( Вер0, Правила, Трасса, Вер, ПравОтв).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Модифицировать априорные вероятности\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель1 и Цель2, Трасса,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Цель1 и Цель2 : Вер было 'выведено из'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    ( Ответ1 и Ответ2) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Цель1, Трасса, Ответ1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Цель2, Трасса, Ответ2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вероятность( Ответ1, В1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вероятность( Ответ2, В2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  мин( В1, В2, Вер).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель1 или Цель2, Трасса,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Цель или Цель2:Вер) было 'выведено из'\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    ( Ответ1 и Ответ2) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Цель1, Трасса, Ответ1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Цель2, Трасса, Ответ2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вероятность( Ответ1, В1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вероятность( Ответ2, В2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  макс( В1, В2, Вер).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( не Цель, Трасса,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( не Цель:Вер) было 'выведено из' Ответ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Цель, Трасса, Ответ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вероятность( Ответ, В),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обратить( В, Вер).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 рассмотреть( Цель, Трасса, ( Цель: Вер) было сказано) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ответпольз( Цель, Трасса, Вер).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Ответ, выведенный пользователем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % модиф( Вер0, Правила, Трасса, Вер, ПравОтв)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Существует Цель с априорной вероятностью Вер0. Правила имеют\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % отношение к утверждению Цель; суммарное влияние этих правил\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % (точнее, их условных частей) на Вер0 приводит к тому,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % что Вер0 заменяется на апостериорную вероятность Вер;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Трасса - список целей-предков и правил, использовавшихся\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % при выводе утверждения Цель;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % ПравОтв - результаты анализа условных частей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % правил из списка Правила.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 модиф( Вер0, [], Трасса, Вер0, []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Нет правил - нет модификации\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 модиф( Вер0,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ Прав : если Усл то Цель с Сила | Правила],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Трасса, Вер, [Прав из Ответ | ПравОтв] ):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  рассмотреть( Усл, [Цель по Прав | Трасса], Ответ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Условие из первого правила\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  априори( Усл, В0),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вероятность( Ответ, В),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  импликация( В0, В, Сила, Вер0, Вер1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % "Мягкая" импликация\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  модиф( Вер1, Правила, Трасса, Вер, ПравОтв).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 14.16.\b0   Определение степени правдоподобия гипотезы при помощи распространения информации об оценке уверенности по сети вывода.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 14.7. Заключительные замечания\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нашу оболочку экспертной системы можно развивать в целом ряде направлений. В данный момент уместно сделать несколько критических замечаний и высказать предложения по усовершенствованию нашей программы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В нашей программе, являющейся упрощенной реализацией, не уделено достаточного внимания вопросам эффективности. В более эффективной реализации потребовалось бы использовать более сложные структуры данных, ввести индексирование или иерархическую структуризацию множества правил и т.п.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша процедура рассмотреть подвержена зацикливанию в тех случаях, когда в правилах базы знаний "циклически" упоминается одна и та же цель. Этот недостаток легко исправить, предусмотрев в рассмотреть соответствующий контроль, т.е. проверку, не является ли текущая цель частным случаем некоторой цели, уже введенной в состав объекта Трасса.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наше объяснение типа "как" выводит дерево доказательства целиком. В случае больших деревьев, удобнее было бы вывести только верхнюю часть дерева, а затем дать пользователю возможность "гулять" по остальной части дерева по своему желанию. Тогда пользователь смог бы просматривать дерево выборочным образом, используя команды, такие как "Вниз по ветви 1", "Вниз по ветви 2", …, "Вверх", "Достаточно".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В объяснениях типа "как" и "почему" наша оболочка ссылается на правила, указывая их имена, и не показывает их в явном виде. Необходимо, чтобы во время консультационного сеанса пользователь мог, по желанию, запрашивать те или иные правила и получать их явные изображения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Известно, что придать диалогу с пользователем естественный характер при помощи умелой постановки вопросов - сложная задача. Наш способ ее решения работает только в определенных пределах и во многих случаях приводит к самым разным проблемам, например:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: сьюзен летает?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b нет.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: сьюзен летает хорошо?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Конечно же нет, раз она совсем не летает! Другой пример:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Есть (еще) решения для: Кто-нибудь летает?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b да.\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Кто-нибудь =\i0   \b птица\b0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Это правда: альбатрос летает?\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для того, чтобы справиться с подобными нежелательными эффектами, следует ввести в экспертную систему дополнительные отношения между понятиями вместе с механизмами их обработки. Обычно эти новые отношения задают иерархию объектов и их свойств.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Возможно еще одно усовершенствование процедуры взаимодействия с пользователем, предусматривающее планирование оптимальной стратегии постановки вопросов. Целью оптимизации является минимизация количества вопросов, которые необходимо задать пользователю для достижения некоторого окончательного логического заключения. Разумеется, возникнут различные варианты таких стратегий, и то, какая из них окажется оптимальной, будет зависеть от ответов пользователя. Принятие решения о выборе той или иной альтернативной стратегии можно основывать на \i априорных\i0   вероятностях, являющихся вероятностными оценками "стоимостей" альтернатив. Величины оценок, возможно, придется пересчитывать после каждого ответа пользователя.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует еще одна величина, поддающаяся оптимизации: длина цепочки вывода. Такая оптимизация позволила бы давать более простые объяснения типа "как". Сложность объяснений можно также уменьшить за счет селективного подхода к правилам. Некоторые из правил можно было бы не включать в состав объектов Трасса и Ответ, порождаемых процедурой рассмотреть. С этой целью необходимо указывать в базе знаний, какие из правил "трассируемы", а следовательно, должны появляться в объяснениях, а какие можно опускать.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В "разумной" экспертной системе следует предусмотреть вероятностные механизмы, заставляющие ее концентрировать свое внимание на наиболее правдоподобных гипотезах среди всех конкурирующих между собой гипотез. Такая экспертная система должна запрашивать у пользователя ту информацию, которая позволила бы распознать наилучшую среди наиболее правдоподобных гипотез.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Наша экспертная система была классификационного или "анализирующего" типа, в противоположность системам "синтезирующего" типа, в которых ставится задача \i построить\i0   что-либо. В последнем случае результат работы - это план действий, предпринимаемых для выполнения этой задачи, например план действий робота, компьютерная конфигурация, удовлетворяющая заданным требованиям, или форсированная комбинация в шахматах. Наш пример, относящийся к локализации неисправностей, можно естественным образом расширить, чтобы включить в рассмотрение действия. Например, если система не может прийти к определенному выводу, поскольку приборы выключены, она даст рекомендацию: "Включить лампу 3". Здесь сразу возникнет задача построения оптимального плана: минимизировать число действий, необходимых для достижения окончательного вывода.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Проекты\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Завершите программирование нашей оболочки в части, касающейся неопределенной информации (процедура ответпольз и другие).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрите перечисленные выше критические замечания, а также возможные расширения нашей экспертной системы. Разработайте и реализуйте соответствующие усовершенствования.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Обычно от экспертных систем требуют выполнения следующих функций:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   решение задач в заданной предметной области,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   объяснение процесса решения задач,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   работа с неопределенной и неполной информацией.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Удобно считать, что экспертная система со стоит из двух модулей: оболочки и базы знаний. Оболочка в свою очередь состоит из механизма логического вывода и интерфейса с пользователем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • При создании экспертной системы необходимо принять решения о выборе формального языка представления знаний, механизма логического вывода, средств взаимодействия с пользователем и способа работы в условиях неопределенности.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • "Если-то"-правила, или продукции являются наиболее часто применяемой формой представления знаний в экспертных системах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Оболочка, разработанная в данной главе, интерпретирует "если-то"-правила, обеспечивает выдачу объяснений типа "как" и "почему" и запрашивает у пользователя необходимую информацию.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Машина логического вывода была расширена для работы с неопределенной информацией.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В данной главе были обсуждены следующие понятия:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   экспертные системы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   база знаний, оболочка,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   машина логического вывода\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   "если-то"-правила, продукции\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   объяснения типа "как" и "почему"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   категорические знания, неопределенные знания\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   сеть вывода,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   распространение оценок достоверности по сети\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Книга Michie (1979) - это сборник статей, относящихся к различным аспектам экспертных систем и инженерии знаний. Две ранние экспертные системы, оказавшие большое влияние на развитие этой области, MYCIN и Prospector, описаны в Shortliffe (1976) и Duda et al (1979). Книга Buchanan and Shortliffe (1984) является хорошим сборником статей, посвященных результатам экспериментов с системой MYCIN. Weiss and Kulikowski (1984) описывают свой практический опыт разработки экспертных систем. Вопрос о работе в условиях неопределенности еще нельзя считать вполне решенным: в статье Quinlan (1983) сравниваются различные подходы к этой проблеме. Способ разработки нашей экспертной системы до некоторой степени аналогичен описанному в Hammond (1984). Некоторые примеры, использовавшиеся в тексте, заимствованы из Winston (1984), Shortliffe (1976), Duda et al (1979), Bratko (1982) и Reiter (1980).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bratko I. (1982). Knowledge-based problem-solving in AL3. In: \i Machine Intelligence 10\i0   (J.E. Hayes, D. Michie, Y.H. Pao, eds.). Ellis Horwood.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Buchanan B.G. and Shortliffe E.H. (1984, eds.). \i Rule-based Expert Systems: The МYСIN Experiments of the Stanford Heuristic Programming Project.\i0   Addison-Wesley.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Duda R., Gasschnig J. and Hart P. (1979). Model design in the Prospector consultant system for mineral exploration. In: \i Expert Systems in the Microelectronic Age\i0   (D. Michie, ed.). Edinburgh University Press.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Hammond P. (1984). vMicro-PROLOG for Expert Systems. In: \i Micro-PROLOG: Programming in Logic\i0   (K.L. Clark, F.G. McCabe, eds.). Prentice-Hall.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Michie D. (1979, ed.). \i Expert Systems in the Microelectronic Age.\i0   Edinburgh University Press.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Quinlan J.R. (1983). Inferno: a cautious approach to uncertain reasoning. \i The Computer Journal\i0   \b 26\b0  : 255-270.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Reiter J. (1980). AL/X: An Expert System Using Plausible Inference. Oxford: Intelligent Terminals Ltd.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Shortliffe E. (1976). \i Computer-based Medical Consultations: MYCIN.\i0   Elsevier.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Weiss S.M. and Kulikowski CA. (1984). \i A Practical Guide to Designing Expert Systems.\i0   Chapman and Hall.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Winston P. H. (1984). \i Artificial Intelligence\i0   (second edition). Addison-Wesley. [Имеется перевод первого издания: Уинстон П. Искусственный интеллект. — М.: Мир, 1980.]\par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 15\par
Игры\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой главе мы рассмотрим методы программирования игр двух лиц с полной информацией (таких, как шахматы). Для игр, представляющих интерес, деревья возможных продолжений слишком велики, чтобы можно было говорить о полном переборе, поэтому необходимы какие-то другие подходы. Один из таких методов, основанный на минимаксном принципе, имеет эффективную реализацию, известную под названием "альфа-бета алгоритм". В дополнение к этому стандартному методу, мы разработаем в этой главе программу на основе Языка Советов (Advice Language), который дает возможность вносить в шахматную программу знания о типовых ситуациях. Этот довольно подробный пример может послужить еще одной иллюстрацией того, насколько хорошо Пролог приспособлен для реализации систем, основанных на знаниях.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 15.1. Игры двух лиц с полной информацией\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Игры, которые мы собираемся обсуждать в данной главе, относятся к классу так называемых игр двух лиц с полной информацией. Примерами таких игр могут служить шахматы, шашки и т.п. В игре участвуют два игрока, которые ходят по очереди, причем оба они обладают полной информацией о текущей игровой ситуации (это определение исключает большинство карточных игр). Игра считается оконченной, если достигнута позиция, являющаяся согласно правилам игры "терминальной" (конечной), например матовая позиция в шахматах. Правилами игры также устанавливается, каков исход игры в этой терминальной позиции.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для игр такого рода возможно представление в виде \i дерева игры\i0   (или \i игрового дерева\i0  ). Вершины этого дерева соответствуют ситуациям, а дуги — ходам. Начальная ситуация игры — это корневая вершина; листьями дерева представлены терминальные позиции.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В большинстве игр этого типа возможны следующие исходы: \i выигрыш\i0  , \i проигрыш\i0   и \i ничья\i0  . Мы будем рассматривать здесь игры, имеющие только два возможных исхода — \i выигрыш\i0   и \i проигрыш\i0  . Игры, в которых возможна ничья, можно упрощенно считать играми с двумя исходами — \i выигрыш\i0   и \i не-выигрыш\i0  . Двух участников игры мы будем называть "игроком" и "противником". "Игрок" может выиграть в некоторой нетерминальной позиции с ходом игрока ("позиции игрока"), если в ней существует \i какой-нибудь\i0   разрешенный ход, приводящий к выигрышу. С другой стороны, некоторая нетерминальная позиция с ходом противника ("позиция противника") является выигранной для игрока, если \i все\i0   разрешенные ходы из этой позиции ведут к позициям, в которых возможен выигрыш. Эти правила находятся в полном соответствии с представлением задач в форме И/ИЛИ-дерева, которое мы обсуждали в гл. 13. Между понятиями, относящимися к И/ИЛИ-деревьям, и понятиями, используемыми в играх, можно установить взаимное соответствие следующим образом:\par
\par { \trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 позиции игры\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 вершины, задачи\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 терминальные позиции выигрыша\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 целевые вершины, тривиально решаемые задачи\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 терминальные позиции проигрыша\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 задачи, не имеющие решения\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 выигранные позиции\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 задачи, имеющие решение\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 позиции игрока\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ИЛИ-вершины\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 позиции противника\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 И-вершины\b0\cell

}\row }\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очевидно, что аналогичным образом понятия, относящиеся к поиску в И/ИЛИ-деревьях, можно переосмыслить в терминах поиска в игровых деревьях.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ниже приводится простая программа, которая определяет, является ли некоторая позиция игрока выигранной.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выигр( Поз) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  терм_выигр( Поз).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Терминальная выигранная позиция\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выигр( Поз) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not терм_проигр( Поз),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход( Поз, Поз1), % Разрешенный ход в Поз1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not ( ход( Поз1, Поз2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not выигр( Поз2) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Ни один из ходов противника не ведет к не-выигрышу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь правила игры встроены в предикат ход( Поз, Поз1), который порождает все разрешенные ходы, а также в предикаты терм_выигр( Поз) и терм_проигр( Поз), которые распознают терминальные позиции, являющиеся, согласно правилам игры, выигранными или проигранными. В последнем из правил программы, содержащем двойное отрицание (not), говорится: не существует хода противника, ведущего к не выигранной позиции. Другими словами: \i все\i0   ходы противника приводят к позициям, выигранным с точки зрения игрока.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 15.1.\b0   Сложность игровых деревьев в шахматах. Оценки основаны на том, что в каждой шахматной позиции существуют приблизительно 30 разрешенных ходов я что терминальные позиции расположены на глубине 40 ходов. Один ход равен двум полуходам (по одному полуходу с каждой стороны).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Так же, как и аналогичная программа поиска в И/ИЛИ-графах, приведенная выше программа использует стратегию в глубину. Кроме того, в ней не исключается возможность зацикливания на одних и тех же позициях. Попытка устранить этот недостаток может привести к осложнениям, поскольку правила некоторых из игр допускают такое повторение позиций. Правда, разрешение повторять позиции часто носит условный характер, например по шахматным правилам после троекратного повторения позиции может быть объявлена ничья.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа, которую мы составили, демонстрирует основные принципы программирования игр. Но практически приемлемая реализация таких сложных игр, как шахматы или го, потребовала бы привлечения значительно более мощных методов. Огромная комбинаторная сложность этих игр делает наш наивный переборный алгоритм, просматривающий дерево вплоть до терминальных игровых позиций, абсолютно непригодным. Этот вывод иллюстрирует (на примере шахмат) рис. 15.1: пространство поиска имеет астрономические размеры — около 10\super 120\nosupersub  позиций. Можно возразить, что в дереве на рис. 15.1 встречаются одинаковые позиции. Однако было показано, что число различных позиций дерева поиска находится далеко за пределами возможностей вычислительных машин обозримого будущего.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Проект\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Напишите программу для какой-нибудь простой игры (такой, как \i ним\i0  ), использующую упрощенный алгоритм войска в И/ИЛИ-дереве.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 15.2. Минимаксный принцип\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для игр, представляющих интерес, полный просмотр игрового дерева невозможен, поэтому были разработаны другие методы, предусматривающие просмотр только части дерева игры. Среди этих методов существует страндартный метод поиска, используемый в игровых (особенно в шахматных) программах и основанный на \i минимаксном\i0   принципе. Дерево игры просматривается только вплоть до некоторой глубины (обычно на несколько ходов), а затем для всех концевых вершин дерева поиска вычисляются оценки при помощи некоторой оценочной функции. Идея состоит в том, чтобы, получив оценки этих терминальных поисковых вершин, не продвигаться дальше и получить тем самым экономию времени. Далее, оценки терминальных позиций распространяются вверх по дереву поиска в соответствии с минимаксным принципом. В результате все вершины дерева поиска получают свои оценки. И наконец, игровая программа, участвующая в некоторой реальной игре, делает свой ход — ход, ведущий из исходной (корневой) позиции в наиболее перспективного (с точки зрения оценки) ее преемника.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Обратите внимание на то, что мы здесь делаем определенное различие между "деревом игры" и "деревом поиска". Дерево поиска — это только часть дерева игры (его верхняя часть), т.е. та его часть, которая была явным образом порождена в процессе поиска. Таким образом, терминальные поисковые позиции совсем не обязательно должны совпадать с терминальными позициями самой игры.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очень многое зависит от оценочной функции, которая для большинства игр, представляющих интерес, является приближенной эвристической оценкой шансов на выигрыш одного из участников игры. Чем выше оценка, тем больше у него шансов выиграть и чем ниже оценка, тем больше шансов на выигрыш у его противника. Поскольку один из участников игры всегда стремится к высоким оценкам, а другой — к низким, мы дадим им имена МАКС и МИН соответственно. МАКС всегда выбирает ход с максимальной оценкой; в противоположность ему МИН всегда выбирает ход с минимальной оценкой. Пользуясь этим принципом (\i минимаксным\i0   принципом) и зная значения оценок для всех вершин "подножья" дерева поиска, можно определить оценки всех остальных вершин дерева. На рис. 15.2 показано, как это делается. На этом рисунке видно, что уровни позиций с ходом МАКС'а чередуются с уровнями позиций с ходом МИН'а. Оценки вершин нижнего уровня определяются при помощи оценочной функции. Оценки всех внутренних вершин можно определить, двигаясь снизу вверх от уровня к уровню, пока мы не достигнем корневой вершины. В результате, как видно из рис. 15.2, оценка корня оказывается равной 4, и, соответственно, лучшим ходом МАКС'а из позиции \i а\i0   — \i a-b\i0  . Лучший ответ МИН'а на этот ход — \i b-d\i0  , и т.д. Эту последовательность ходов называют также \i основным вариантом\i0  . Основной вариант показывает, какова "минимаксно-оптимальная" игра для обоих участников. Обратите внимание на то, что оценки всех позиций, входящих в основной вариант, совпадают.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 15.2.\b0   Статические (нижний уровень) и минимаксные рабочие оценки вершин дерева поиска. Выделенные ходы образуют \i основной вариант\i0  , т.е. минимаксно-оптимальную игру с обеих сторон.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы различаем два вида оценок: оценки вершин нижнего уровня и оценки внутренних вершин (рабочие оценки). Первые из них называются также "статическими", так как они вычисляются при помощи "статической" оценочной функции, в противоположность рабочим оценкам, получаемым "динамически" при распространении статических оценок вверх по дереву.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Правила распространения оценок можно сформулировать следующим образом. Будем обозначать статическую оценку позиции \i P \i0  через \i v\i0  (\i P\i0  ), а ее рабочую оценку — через \i V\i0  (\i P\i0  ). Пусть \i P\sub 1\nosupersub \i0  , …, \i Р\sub n\nosupersub \i0   — разрешенные преемники позиции \i P\i0  . Тогда соотношения между статическими и рабочими оценками можно записать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i V\i0  (\i P\i0  )\i  = v\i0  (\i P\i0  )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если \i P\i0   — терминальная позиция дерева поиска (\i n=\i0  0)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \qc\par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если \i P\i0   — позиция с ходом МАКС'а\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  \qc\par\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если \i P\i0   — позиция с ходом МИН'а\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Минимаксная процедура: минимакс( Поз, ЛучшПоз, Оц)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Поз - позиция, Оц - ее минимаксная оценка;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % лучший ход из Поз ведет в позицию ЛучшПоз\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 минимакс( Поз, ЛучшПоз, Оц) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  оды( Поз, СписПоз), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % СписПоз - список разрешенных ходов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  лучш( СписПоз, ЛучшПоз, Оц);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  стат_оц( Поз, Оц). % Поз не имеет преемников\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 лучш( [Поз], Поз, Оц) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  минимакс( Поз, _, Оц), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 лучш( [Поз1 | СписПоз], ЛучшПоз, ЛучшОц) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  минимакс( Поз1, _, Оц1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  лучш( СписПоз, Поз2, Оц2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выбор( Поз1, Оц1, Поз2, Оц2, ЛучшПоз, ЛучшОц).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выбор( Поз0, Оц0, Поз1, Оц1, Поз0, Оц0) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход_мина( Поз0), Оц > Оц1, !;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход_макса( Поз0), Оц < Оц1, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выбор( Поз0, Оц0, Поз1, Оц1, Поз1, Оц1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 15.3.\b0   Упрощенная реализация минимаксного принципа.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа на Прологе, вычисляющая минимаксную рабочую оценку для некоторой заданной позиции, показана на рис. 15.3. Основное отношение этой программы —\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 минимакс( Поз, ЛучшПоз, Оц)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Оц — минимаксная оценка позиции Поз, а ЛучшПоз — наилучшая позиция-преемник позиции Поз (лучший ход, позволяющий достигнуть оценки Оц). Отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ходы( Поз, СписПоз)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 задает разрешенные ходы игры: СписПоз — это список разрешенных позиций-преемников позиции Поз. Предполагается, что цель ходы имеет неуспех, если Поз является терминальной поисковой позицией (листом дерева поиска). Отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 лучш( СписПоз, ЛучшПоз, ЛучшОц)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выбирает из списка позиций-кандидатов СписПоз "наилучшую" позицию ЛучшПоз. ЛучшОц — оценка позиции ЛучшПоз, а следовательно, и позиции Поз. Под "наилучшей" оценкой мы понимаем либо максимальную, либо минимальную оценку, в зависимости от того, с чьей стороны ожидается ход.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 15.3. Альфа-бета алгоритм: эффективная реализация минимаксного принципа\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа, показанная на рис. 15.3, производит просмотр в глубину дерева поиска, систематически обходя \i все\i0   содержащиеся в нем позиции вплоть до терминальных; она вычисляет статические оценки \i всех\i0   терминальных позиций. Как правило, для того, чтобы получить правильную минимаксную оценку корневой вершины, совсем не обязательно проделывать эту работу полностью. Поэтому алгоритм поиска можно сделать более экономным. Его можно усовершенствовать, используя следующую идею. Предположим, что у нас есть два варианта хода. Как только мы узнали, что один из них явно хуже другого, мы можем принять правильное решение, не выясняя, на сколько \i в точности\i0   он хуже. Давайте используем этот принцип для сокращения дерева поиска рис. 15.2. Процесс поиска протекает следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Начинаем с позиции \i а\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Переходим к \i b\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Переходим к \i d\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (4) Берем максимальную из оценок преемников позиции \i d\i0  , получаем \i V(d) =\i0   4.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (5) Возвращаемся к \i b\i0   и переходим к  \i e\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (6) Рассматриваем первого преемника позиции \i e\i0   с оценкой 5. В этот момент МАКС (который как раз и должен ходить в позиции \i e\i0  ) обнаруживает, что ему гарантирована в позиции \i e\i0   оценка не меньшая, чем 5, независимо от оценок других (возможно, более предпочтительных) вариантов хода. Этого вполне достаточно для того, чтобы МИН, даже не зная точной оценки позиции \i e\i0  , понял, что для него в позиции \i b\i0   ход в \i e\i0   хуже, чем ход в \i d\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На основании приведенного выше рассуждения мы можем пренебречь вторым преемником позиции \i e\i0   и приписать \i e приближенную\i0   оценку 5. Приближенный характер этой оценки не окажет никакого влияния на оценку позиции \i b\i0  , а следовательно, и позиции \i а\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На этой идее основан знаменитый \i альфа-бета алгоритм\i0  , предназначенный для эффективной реализации минимаксного принципа. На рис. 15.4 показан результат работы альфа-бета алгоритма, примененного к нашему дереву рис. 15.2. Из рис. 15.4 видно, что некоторые из рабочих оценок стали приближенными. Однако этих приближенных оценок оказалось достаточно для того, чтобы определить точную оценку корневой позиции. Сложность поиска уменьшилась до пяти обращений к оценочной функции по сравнению с восемью обращениями (в первоначальном дереве поиска рис. 15.2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Как уже говорилось раньше, ключевая идея альфа-бета отсечения состоит в том, чтобы найти ход не обязательно лучший, но "достаточно хороший" для того, чтобы принять правильное решение. Эту идею можно формализовать, введя два граничных значения, обычно обозначаемых через \i Альфа\i0   и \i Бета\i0  , между которыми должна заключаться рабочая оценка позиции. Смысл этих граничных значений таков: \i Альфа\i0   — это самое маленькое значение оценки, которое к настоящему моменту уже гарантировано для игрока МАКС; \i Бета\i0   — это самое большое значение оценки, на которое МАКС пока еще может надеяться. Разумеется, с точки зрения МИН'а, \i Бета\i0   является самым худшим значением оценки, которое для него уже гарантировано. Таким образом, действительное значение оценки (т.е. то, которое нужно найти) всегда лежит между \i Альфа\i0   и \i Бета\i0  . Если же стало известно, что оценка некоторой позиции лежит вне интервала \i Альфа-Бета\i0  , то этого достаточно для того, чтобы сделать вывод: данная позиция не входит в основной вариант. При этом точное значение оценки такой позиции знать не обязательно, его надо знать только тогда, когда оценка лежит между \i Альфа\i0   и \i Бета\i0  . "Достаточно хорошую" рабочую оценку  \i V( P, Альфа, Бета)\i0    позиции \i P\i0   по отношению к \i Альфа\i0   и \i Бета\i0   можно определить формально как любое значение, удовлетворяющее следующим ограничениям:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i V( P, Альфа, Бета) &#8804;  Альфа\i0   если \i V( P) &#8804; Альфа\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i V( P, Альфа, Бета) = V( P)\i0   если \i Альфа < V( P) < Бета\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i V( P, Альфа, Бета) &#8805; Бета\i0   если \i V( P) &#8805; Бета\i0  \par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 15.4.\b0   Дерево рис. 15.2 после применения альфа-бета алгоритма. Пунктиром показаны ветви, отсеченные альфа-бета алгоритмом для экономии времени поиска. В результате некоторые из рабочих оценок стали приближенными (вершины \i c\i0  , \i e\i0  , \i f\i0  ; сравните с рис. 15.2). Однако этих приближенных оценок достаточно для вычисления точной оценки корневой вершины и построения основного варианта.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очевидно, что, умея вычислять "достаточно хорошую" оценку, мы всегда можем вычислить точную оценку корневой позиции \i P\i0  , установив границы интервала следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i V( P, -бесконечность, +бесконечность)  =  V( P)\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 15.5 показана реализация альфа-бета алгоритма в виде программы на Прологе. Здесь основное отношение —\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 альфабета( Поз, Альфа, Бета, ХорПоз, Оц)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где ХорПоз — преемник позиции Поз с "достаточно хорошей" оценкой Оц, удовлетворяющей всем указанным выше ограничениям:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оц\i = V( Поз, Альфа, Бета)\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прибл_лучш( СписПоз, Альфа, Бета, ХорПоз, Оц)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 находит достаточно хорошую позицию ХорПоз в списке позиций СписПоз; Оц — приближенная (по отношению к Альфа и Бета) рабочая оценка позиции ХорПоз.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Интервал между \i Альфа\i0   и \i Бета\i0   может сужаться (но не расширяться!) по мере углубления поиска, происходящего при рекурсивных обращениях к альфа-бета процедуре. Отношение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нов_границы( Альфа, Бета, Поз, Оц, НовАльфа, НовБета)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 определяет новый интервал (НовАльфа, НовБета). Он всегда уже, чем старый интервал (Альфа, Бета), или равен ему. Таким образом, чем глубже мы оказываемся в дереве поиска, тем сильнее проявляется тенденция к сжатию интервала \i Альфа-Бета\i0  , и в результате оценивание позиций на более глубоких уровнях происходит в условиях более тесных границ. При более узких интервалах допускается большая степень "приблизительности" при вычислении оценок, а следовательно, происходит больше отсечений ветвей дерева. Возникает интересный вопрос: насколько велика экономия, достигаемая альфа-бета алгоритмом по сравнению с программой минимаксного полного перебора рис. 15.3?\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Альфа-бета алгоритм\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 альфабета( Поз, Альфа, Бета, ХорПоз, Оц) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ходы( Поз, СписПоз), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  прибл_лучш( СписПоз, Альфа, Бета, ХорПоз, Оц);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  стат_оц( Поз, Оц).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 прибл_лучш( [Поз | СписПоз], Альфа, Бета, ХорПоз, ХорОц) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  альфабета( Поз, Альфа, Бета, _, Оц),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  дост_хор( СписПоз, Альфа, Бета, Поз, Оц, ХорПоз, ХорОц).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дост_хор( [], _, _, Поз, Оц, Поз, Оц) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Больше нет кандидатов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дост_хор( _, Альфа, Бета, Поз, Оц, Поз, Оц) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход_мина( Поз), Оц > Бета, !;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Переход через верхнюю границу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход_макса( Поз), Оц < Альфа, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Переход через нижнюю границу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дост_хор( СписПоз, Альфа, Бета, Поз, Оц, ХорПоз, ХорОц) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  нов_границы( Альфа, Бета, Поз, Оц, НовАльфа, НовБета),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Уточнить границы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  прибл_лучш( СписПоз, НовАльфа, НовБета, Поз1, Оц1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выбор( Поз, Оц, Поз1, Оц1, ХорПоз, ХорОц).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нов_границы( Альфа, Бета, Поз, Оц, Оц, Бета) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход_мина( Поз), Оц > Альфа, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Увеличение нижней границы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нов_границы( Альфа, Бета, Поз, Оц, Альфа, Оц) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход_макса( Поз), Оц < Бета, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Уменьшение верхней границы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нов_границы( Альфа, Бета, _, _, Альфа, Бета).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выбор( Поз, Оц, Поз1, Оц1, Поз, Оц) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход_мина( Поз), Оц > Оц1, !;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход_макса( Поз), Оц < Оц1, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выбор( _, _, Поз1, Оц1, Поз1, Оц1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 15.5.\b0   Реализация альфа-бета алгоритма.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эффективность альфа-бета процедуры зависит от порядка, в котором просматриваются позиции. Всегда лучше первыми рассматривать самые сильные ходы с каждой из сторон. Легко показать на примерах, что возможен настолько неудачный порядок просмотра, что альфа-бета алгоритму придется пройти через \i все\i0   вершины, которые просматривались минимаксным алгоритмом полного перебора. Это означает, что в худшем случае альфа-бета алгоритм не будет иметь никаких преимуществ. Однако, если порядок просмотра окажется удачным, то экономия может быть значительной. Пусть \i N\i0   — число терминальных поисковых позиций, для которых вычислялись статические оценки алгоритмом минимаксного полного перебора. Было доказано, что в лучшем случае, когда самые сильные ходы всегда рассматриваются первыми, альфа-бета алгоритм вычисляет статические оценки только для \i N\i0   позиций.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот результат имеет один практический аспект, связанный с проведением турниров игровых программ. Шахматной программе, участвующей в турнире, обычно дается некоторое определенное время для вычисления очередного хода, и доступная программе глубина поиска зависит от этого времени. Альфа-бета алгоритм сможет пройти при поиске \i вдвое глубже\i0   по сравнению с минимаксным полным перебором, а опыт показывает, что применение той же оценочной функции, но на большей глубине приводит к более сильной игре.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Экономию, получаемую за счет применения альфа-бета алгоритма, можно также выразить в терминах более эффективного коэффициента ветвления дерева поиска (т.е. числа ветвей, исходящих из каждой внутренней вершины). Пусть игровое дерево имеет единый коэффициент ветвления, равный \i b\i0  . Благодаря эффекту отсечения альфа-бета алгоритм просматривает только некоторые из существующих ветвей и тем самым уменьшает коэффициент ветвления. В результате коэффициент \i b\i0   превратится в \i b\i0   (в лучшем случае). В шахматных программах, использующих альфа-бета алгоритм, достигается коэффициент ветвления, равный 6, при наличии 30 различных вариантов хода в каждой позиции. Впрочем, на этот результат можно посмотреть и менее оптимистично: несмотря на применение альфа-бета алгоритма, после каждого продвижения вглубь на один полуход число терминальных поисковых вершин увеличивается примерно в 6 раз.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Проект\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрите какую-нибудь игру двух лиц (например, какой-нибудь нетривиальный вариант крестиков-ноликов). Напишите отношения, задающие правила этой игры (разрешенные ходы и терминальные позиции). Предложите статическую оценочную функцию, пригодную для использования в игровой программе, основанной на альфа-бета алгоритме.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 15.4. Минимаксные игровые программы: усовершенствования и ограничения\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Минимаксный принцип и альфа-бета алгоритм лежат в основе многих удачных игровых программ, чаще всего шахматных. Общая схема подобной программы такова: произвести альфа-бета поиск из текущей позиции вплоть до некоторого предела по глубине (диктуемого временными ограничениями турнирных правил). Для оценки терминальных поисковых позиций использовать подобранную специально для данной игры оценочную функцию. Затем выполнить на игровой доске наилучший ход, найденный альфа-бета алгоритмом, принять ответный ход противника и запустить тот же цикл с начала.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом, две основных составляющих игровой программы — это альфа-бета алгоритм и эвристическая оценочная функция. Для того, чтобы создать действительно хорошую программу для такой сложной игры, как шахматы, необходимо внести в эту базовую схему много различных усовершенствований. Ниже приводится краткое описание некоторых из стандартных приемов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Многое зависит от оценочной функции. Если бы мы располагали абсолютно точной оценочной функцией, мы могли бы ограничить поиск рассмотрением только непосредственных преемников текущей позиции, фактически исключив перебор. Но для таких игр, как шахматы, любая оценочная функция, имеющая практически приемлемую вычислительную сложность, по необходимости будет всего лишь эвристической оценкой. Такая оценка базируется на "статических" свойствах позиции (например, на количестве фигур) и в одних позициях работает надежнее, чем в других. Допустим, например, что мы имеем именно такую оценочную функцию, основанную на соотношении материала, и представим себе позицию, в которой у белых лишний конь. Ясно, что оценка будет в пользу белых. Здесь все в порядке, если позиция "спокойная" и черные не располагают какой-либо сильной угрозой. Но, с другой стороны, если на следующем ходу черные могут взять белого ферзя, то такая оценка может привести к фатальному просмотру из-за своей неспособности к \i динамическому\i0   восприятию позиции. Очевидно, что в спокойных позициях мы можем доверять такой статической оценке в большей степени, чем в активных позициях, когда с каждой из сторон имеются непосредственные угрозы взятия фигур. Поэтому статическую оценку следует использовать только для спокойных позиций. Что же касается активных позиций, то здесь существует такой стандартный прием: следует продолжить поиск из активной позиции за пределы ограничения по глубине и продолжать его до тех пор, пока не встретится спокойная позиция. В частности, таким образом производится просчет разменов фигур в шахматах.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Еще одно усовершенствование — \i эвристическое отсечение\i0   (ветвей). Целью его является достижение большей предельной глубины поиска за счет отбрасывания менее перспективных продолжений. Этот метод позволяет отсекать ветви в дополнение к тем, которые отсекаются самим альфа-бета алгоритмом. В связи с этим возникает риск пропустить какое-нибудь хорошее продолжение и неправильно вычислить минимаксную оценку.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует еще один прием, называемый \i последовательным углублением\i0  . Программа многократно выполняет альфа-бета поиск сначала до некоторой небольшой глубины, а затем, увеличивая предел по глубине при каждой итерации. Процесс завершается, когда истекает время, отведенное для вычисления очередного хода. Выполняется наилучший ход, найденный при наибольшей глубине, достигнутой программой. Этот метод имеет следующие преимущества:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • он облегчает контроль времени: в момент, когда время истекает, всегда имеется некоторый ход — лучший из всех, найденных к настоящему моменту;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • минимаксные оценки, вычисленные во время предыдущей итерации, можно использовать для предварительного упорядочивания позиций в следующей итерации, что помогает альфа-бета алгоритму следовать стратегии "самые сильные ходы — первыми".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод последовательного углубления влечет за собой некоторые накладные расходы (из-за повторного поиска в верхней части игрового дерева), но они незначительны по сравнению c суммарными затратами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для наших программ, основанных на описанной выше схеме, существует проблема, известная как "эффект горизонта". Представьте себе шахматную позицию, в которой программе грозит неминуемая потеря коня, однако эту потерю можно отложить, пожертвовав какую-либо менее ценную фигуру, скажем пешку. Эта немедленная жертва сможет отодвинуть потерю коня за пределы доступной глубины поиска (за "горизонт" программы). Не видя грозящей опасности, программа отдаст предпочтение продолжению с жертвой пешки, чтобы избежать быстрой гибели своего коня. В действительности программа потеряет \i обе\i0   фигуры — и пешку (без необходимости), и коня. Эффект горизонта можно несколько смягчить за счет углубления поиска вплоть до спокойных позиций.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Существует, однако, более фундаментальное ограничение на возможности минимаксных игровых программ, проистекающее из той ограниченной формы представления знаний, которая в них используется. Это становится особенно заметным при сравнении лучших шахматных программ с шахматными мастерами (людьми). Хорошая программа просматривает миллионы (и даже больше) позиций, прежде чем принимает решение об очередном ходе. Психологические опыты показали, что шахматные мастера, как правило, просматривают десятки (максимум, несколько сотен) позиций. Несмотря на эту явно меньшую производительность, мастера-шахматисты обыгрывают программы без особых усилий. Преимущество их состоит в их знаниях, значительно превосходящих знания шахматных программ. Игры между машинами и сильными шахматистами показали, что огромное превосходство в вычислительной мощности не способно скомпенсировать недостаток знаний.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Знания в минимаксных игровых программах имеют следующие три основные формы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • оценочная функция\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • эвристики для отсечения ветвей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • эвристики для распознавания спокойных позиций\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Оценочная функция сводит все разнообразные аспекты игровой ситуации к одному числу, и это упрощение может нанести вред. В противоположность этому хороший игрок обладает пониманием позиции, охватывающим многие "измерения". Вот пример из области шахмат: оценочная функция оценивает позицию как равную и выдает значение 0. Оценка той же позиции, данная мастером-шахматистом, может быть значительно более информативной, а также может указывать на дальнейший ход игры, например: у белых лишняя пешка, но черные имеют неплохие атакующие возможности, что компенсирует материальный перевес, следовательно, шансы равны.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Минимаксные шахматные программы часто хорошо проявляют себя в острой тактической борьбе, когда решающее значение имеет точный просчет форсированных вариантов. Их слабости обнаруживаются в спокойных позициях, так как они не способны к долговременному планированию, преобладающему при медленной, стратегической игре. Из-за отсутствия плана создается внешнее впечатление, что программа все время перескакивает с одной идеи" на другую. Особенно это заметно в эндшпилях.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В оставшейся части главы мы рассмотрим еще один подход к программированию игр, основанный на внесении в программу знаний о типовых ситуациях при помощи так называемых "советов".\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 15.5. Знания о типовых ситуациях и механизм "советов"\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом разделе рассматривается метод представления знаний о конкретной игре с использованием семейства Языков Советов. Языки Советов (Advice Languages) дают возможность пользователю декларативным способом описывать, какие идеи следует использовать в тех или иных типовых ситуациях. Идеи формулируются в терминах целей и средств, необходимых для их достижения. Интерпретатор Языка Советов определяет при помощи перебора, какая идея "работает" в данной ситуации.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 15.5.1. Цели и ограничения на ходы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основное понятие Языка Советов — "элементарный совет". Элементарный совет содержит указание о том, что следует делать (или \i пытаться\i0   делать) в некоторой типовой ситуации. Совет выражается в терминах тех \i целей\i0  , которые необходимо достичь, и тех \i средств\i0  , которые следует применять для этого. Мы называем участников игры "игроком" и "противником"; совет всегда относится к "игроку". Каждый элементарный совет имеет следующие четыре составные части:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i главная цель\i0  : цель, к которой нужно стремиться;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i цель-поддержка\i0  : цель, которая должна постоянно удовлетворяться в процессе достижения главной цели;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i ограничения на ходы игрока\i0  : предикат, определяющий некоторое подмножество ходов из всех разрешенных ходов игрока (ходы, представляющие интерес с точки зрения достижения указанных целей).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i ограничения на ходы противника\i0  : предикат, выбирающий ходы, которые должен рассмотреть противник (ходы, препятствующие достижению указанных целей).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрим, например, шахматный эндшпиль "король и пешка против короля". Здесь применима следующая очевидная идея: провести пешку в ферзи, продвигая ее вперед. В форме совета это выражается так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i главная цель\i0  : провести пешку;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i цель-поддержка\i0  : не потерять пешку;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i ходы игрока\i0  : продвигать пешку;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • \i ходы противника\i0  : приближаться королем к пешке. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 15.5.2. Выполнимость совета\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы говорим, что элементарный совет \i выполним\i0   в данной позиции, если игрок может форсированным образом достигнуть главной цели, указанной в совете, при условии, что:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) ни разу не нарушается цель-поддержка;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) все ходы игрока удовлетворяют наложенным на них ограничениям;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) противнику разрешено делать только те ходы, которые предусмотрены соответствующими ограничениями.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С выполнимостью элементарного совета связано понятие \i форсированного дерева\i0  . Форсированное дерево задает детальную стратегию, которая гарантирует достижение главной цели при выполнении всех ограничений, содержащихся в элементарном совете. Таким образом, форсированное дерево указывает, как именно должен ходить игрок при любых ответах противника. Более точно, форсированное дерево T для заданной позиции P и элементарного совета А есть такое поддерево дерева игры, что\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • корень дерева T — позиция P;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • все позиции из T удовлетворяют цели-поддержке;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • все терминальные позиции из T удовлетворяют главной цели (что, однако, неверно ни для одной внутренней вершины);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • для каждой внутренней позиции игрока в дереве T указан только один ход, причем он удовлетворяет ограничениям на ходы игрока;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • из каждой внутренней позиции противника исходят все ходы противника (удовлетворяющие соответствующим ограничениям).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждый элементарный совет можно рассматривать как описание некоторой небольшой специальной игры, имеющей следующие правила. Участникам игры разрешено ходить в пределах ограничений, наложенных на их ходы; позиция, не удовлетворяющая цели-поддержке, считается выигрышем "противника". Нетерминальная позиция считается выигранной с точки зрения игрока, если данный элементарный совет в ней выполним. Таким образом, для того, чтобы выиграть в этой игре, игрок должен следовать стратегии, задаваемой форсированным деревом. \par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 15.5.3. Правила и таблицы советов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В Языках Советов отдельные элементарные советы объединяются в полную схему представления знаний, имеющую следующую иерархическую структуру. Элементарный совет является частью "если-то"-правила. Набор "если-то"-правил образует \i таблицу советов\i0  . Множество таблиц советов имеет структуру иерархической сети. Каждая таблица советов выполняет роль эксперта в своей узкой области и работает с какой-нибудь специфической подзадачей. Примером такого специализированного эксперта может служить таблица советов, содержащая знания о том, как поставить мат королем и ладьей. Эта таблица вызывается в том случае, когда в процессе игры возникает соответствующее окончание.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы рассмотрим здесь упрощенную версию Языка Советов, допускающую только одну таблицу советов. Будем называть эту версию Язык Советов 0 или, для краткости, AL0 (Advice Language 0). Ниже описывается структура языка AL0, синтаксически специально приспособленная для удобной реализации на Прологе.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа на AL0 называется \i таблицей советов\i0  . Таблица советов представляет из себя \i упорядоченное\i0   множество "если-то"-правил. Каждое правило имеет вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ИмяПравила: если Условие то СписокСоветов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Условие — это логическое выражение, состоящее из имен предикатов, соединенных между собой логическими связками и, или, не.  СписокСоветов — список имен элементарных советов. Приведем пример правила под названием "правило_края" из окончания "король и ладья против короля":\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 правило_края:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если король_противника_на_краю и короли_рядом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  то [мат_2, потеснить, приблизиться,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      сохранить_простр, отделить].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этом правиле говорится: если в текущей позиции король противника находится на краю доски, а король игрока расположен близко к королю противника (точнее, расстояние между королями меньше четырех клеток), то попытаться выполнить в указанном порядке предпочтения следующие советы: "мат_2", "потеснить", "приблизиться", "сохранить_простр", "отделить". Элементарные советы расположены в порядке убывания их "притязаний" на успех: сначала попытаться поставить мат в два хода, если не получится — "потеснить" короля противника в угол и т.д. Обратите внимание на то, что при соответствующем определении операторов наше правило станет синтаксически корректным предложением Пролога.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для представления элементарных советов в виде прологовских предложений предназначен еще один формат:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 совет( ИмяСовета,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        ГлавнаяЦель:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        ЦельПоддержка:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        ХодыИгрока:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        ХодыПротивника).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Цели представляются как выражения, состоящие из имен предикатов и логических связок и, или, не.  Ограничения на ходы сторон — это тоже выражения, состоящие из имен предикатов и связок и и затем: связка и имеет обычный логический смысл, а затем задает порядок. Например, ограничение, имеющее вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Огр1 затем Огр2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 означает: сначала рассмотреть ходы, удовлетворяющие ограничению Oгp1, а затем — ходы, удовлетворяющие Огр2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Например, элементарный совет, относящийся к мату в два хода в окончании "король и ладья против короля", записанный в такой синтаксической форме, имеет вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 совет( мат_2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        мат:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        не потеря_ладьи:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина = 0) и разреш затем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина = 2) и ход_шах :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина = 1) и разреш ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь главная цель — мат, цель-поддержка не потеря_ладьи. Ограничение на ходы игрока означает: на глубине 0 (т.е. в текущей позиции) попробовать любой разрешенный ход и затем на глубине 2 (следующий ход игрока) пробовать только ходы с шахом. Глубина измеряется в полуходах. Ограничение на ходы противника: любой разрешенный ход на глубине 1.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В процессе игры таблица советов используется многократно вплоть до окончания игры, при этом выполняется следующий основной цикл: построить форсированное дерево, затем играть в соответствии с этим деревом, пока не произойдет выход из него; построить другое форсированное дерево и т.д. Форсированное дерево строится каждый раз таким образом: берется текущая позиция Поз и просматриваются одно за другим все правила таблицы советов; для каждого правила сопоставляется Поз с предварительным условием этого правила и просмотр прекращается, когда будет обнаружено правило, для которого Поз удовлетворяет предварительному условию. В этом случае надо рассмотреть список советов найденного правила: обработать элементарные советы один за другим, пока не будет построено форсированное дерево, представляющее собой детальную стратегию игры в этой позиции.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следует обратить внимание на существенность того порядка, в котором перечисляются правила в таблице советов. Правило, которое реально используется, — это первое из тех правил, предварительные условия которых согласуются с текущей позицией. Для любой возможной позиции должно существовать по крайней мере одно такое правило. Из него берется список советов, и первый из выполнимых советов списка используется в игре.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Таким образом, таблица советов это программа в высшей степени непроцедурного характера. Интерпретатор языка AL0 принимает на входе некоторую позицию, а затем, "исполняя" таблицу советов, строит форсированное дерево, определяющее стратегию игры в этой позиции.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 15.6. Программа на языке  AL0 для игры в шахматном эндшпиле\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 При реализации какой-либо игровой программы на языке  AL0  ее можно для удобства разбить на три модуля:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) интерпретатор языка  AL0,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) таблица советов на языке  AL0,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) библиотека предикатов, используемых в таблице советов (в том числе предикаты, задающие правила игры).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Эта структура соответствует обычной структуре системы, основанной на знаниях:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Интерпретатор  AL0  выполняет функцию машины логического вывода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Таблица советов вместе с библиотекой предикатов образует базу знаний.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 15.6.1. Миниатюрный интерпретатор языка \i AL0\i0  \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Реализация на Прологе миниатюрного, не зависящего от конкретной игры интерпретатора языка AL0 показана на рис. 15.6. Эта программа осуществляет также взаимодействие с пользователем во время игры. Центральная задача этой программы — использовать знания, записанные в таблице советов, то есть интерпретировать программу на языке советов AL0 с целью построения форсированных деревьев и их "исполнения" в процессе игры. Базовый алгоритм порождения форсированных деревьев аналогичен поиску с предпочтением в И/ИЛИ-графах гл. 13, при этом форсированное дерево соответствует решающему И/ИЛИ-дереву. Этот алгоритм также напоминает алгоритм построения решающего дерева ответа на вопрос пользователя, применявшийся в оболочке экспертной системы (гл. 14).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа на рис. 15.6 составлена в предположении, что она играет белыми, а ее противник — черными. Программа запускается процедурой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 игра( Поз)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Поз — выбранная начальная позиция. Если в позиции Поз ходит противник, то программа принимает его ход, в противном случае — "консультируется" с таблицей советов, приложенной к программе, порождает форсированное дерево и делает свой ход в соответствии с этим деревом. Так продолжается до окончания игры, которое обнаруживает предикат конец_игры (например, если поставлен мат).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Миниатюрный интерпретатор языка AL0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 %\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Эта программа играет, начиная с заданной позиции,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % используя знания, записанные на языке AL0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 200, xfy, :).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 220, xfy, ..).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 185, fx, если).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 190, xfx, то).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 180, xfy, или).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 160, xfy, и).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 140, fx, не).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 игра( Поз) :-         % Играть, начиная с Поз\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  игра( Поз, nil).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Начать с пустого форсированного дерева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 игра( Поз, ФорсДер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  отобр( Поз),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( конец_игры( Поз),  % Конец игры?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    write( 'Конец игры'), nl, !;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сделать_ход( Поз, ФорсДер, Поз1, ФорсДер1), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  игра( Поз1, ФорсДер1) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Игрок ходит в соответствии с форсированным деревом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сделать_ход( Поз, Ход .. ФДер1, Поз1, ФДер1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  чей_ход( Поз, б),    % Программа играет белыми\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разрход( Поз, Ход, Поз1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  показать_ход( Ход).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Прием хода противника\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сделать_ход( Поз, ФДер, Поз1, ФДер1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  чей_ход( Поз, ч),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( 'Ваш ход:'),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( Ход),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( разрход( Поз, Ход, Поз1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    поддер( ФДер, Ход, ФДер1), !;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     % Вниз по форс. дереву\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( 'Неразрешенный ход'), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сделать_ход( Поз, ФДер, Поз1, ФДер1) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Если текущее форсированное дерево пусто, построить новое\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сделать_ход( Поз, nil, Поз1, ФДер1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  чей_ход( Поз, б),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  восст_глуб( Поз, Поз0),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Поз0 = Поз с глубиной 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  стратегия( Поз0, ФДер), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Новое форсированное дерево\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сделать_ход( Поз0, ФДер, Поз1, ФДер1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Выбрать форсированное поддерево, соответствующее Ход'у\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 поддер( ФДеревья, Ход, Фдер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Ход . . Фдер, ФДеревья), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 поддер( _, _, nil).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 стратегия( Поз, ФорсДер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Найти форс. дерево для Поз\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Прав : если Условие то СписСов,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Обращение к таблице советов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удовл( Условие, Поз, _ ), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Сопоставить Поз с предварительным условием\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( ИмяСовета, СписСов),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % По очереди попробовать элем. советы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( 'Пробую'), write( ИмяСовета),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выполн_совет( ИмяСовета, Поз, ФорсДер), !.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выполн_совет( ИмяСовета, Поз, Фдер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  совет( ИмяСовета, Совет),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Найти элементарный совет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выполн( Совет, Поз, Поз, ФДер).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % "выполн" требует две позиции для сравнивающих предикатов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выполн( Совет, Поз, КорнПоз, ФДер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  поддержка( Совет, ЦП),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удовл( ЦП, Поз, КорнПоз),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Сопоставить Поз с целью-поддержкой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выполн1( Совет, Поз, КорнПоз, ФДер).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выполн1( Совет, Поз, КорнПоз, nil) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  главцель( Совет, ГлЦ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удовл( ГлЦ, Поз, КорнПоз), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Главная цель удовлетворяется\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выполн1( Совет, Поз, КорнПоз, Ход .. ФДеревья) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  чей_ход( Поз, б), !, % Программа играет белыми\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ходы_игрока( Совет, ХодыИгрока),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Ограничения на ходы игрока\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход( ХодыИгрока, Поз, Ход, Поз1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Ход, удовлетворяющий ограничению\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выполн( Совет, Поз1, КорнПоз, ФДеревья).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выполн1( Совет, Поз, КорнПоз, ФДеревья) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  чей_ход( Поз, ч), !, % Противник играет черными\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ходы_противника( Совет, ХодыПр),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  bagof ( Ход .. Поз1, ход( ХодыПр, Поз, Ход, Поз1), ХПспис),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выполн_все( Совет, ХПспис, КорнПоз, ФДеревья).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Совет выполним во всех преемниках Поз\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выполн_все( _, [], _, []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выполн_все( Совет, [Ход .. Поз | ХПспис], КорнПоз,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [Ход .. ФД | ФДД] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выполн( Совет, Поз, КорнПоз, ФД),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выполн_все( Совет, ХПспис, КорнПоз, ФДД).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Интерпретация главной цели и цели-поддержки:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % цель - это И / ИЛИ / НЕ комбинация. имен предикатов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удовл( Цель1 и Цель2, Поз, КорнПоз) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удовл( Цель1, Поз, КорнПоз),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удовл( Цель2, Поз, КорнПоз).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удовл( Цель1 или Цель2, Поз, КорнПоз) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( удовл( Цель1, Поз, КорнПоз);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    удовл( Цель2, Поз, КорнПоз) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удовл( не Цель, Поз, КорнПоз) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not удовл( Цель, Поз, КорнПоз ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удовл( Пред, Поз, КорнПоз) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Усл =.. [Пред, Поз];\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Большинство предикатов не зависит от КорнПоз\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Усл =.. [Пред, Поз, КорнПоз] ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  call( Усл).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Интерпретация ограничений на ходы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( Ходы1 и Ходы2, Поз, Ход, Поз1) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход( Ходы1, Поз, Ход, Поз1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход( Ходы2, Поз, Ход, Поз1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( Ходы1 затем Ходы2, Поз, Ход, Поз1) :- !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( ход( Ходы1, Поз, Ход, Поз1);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    ход( Ходы2, Поз, Ход, Поз1) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Доступ к компонентам элементарного совета\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 главцель( ГлЦ : _, ГлЦ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 поддержка( ГлЦ : ЦП : _, ЦП).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ходы_игрока( ГлЦ : ЦП : ХодыИгрока : _, Ходы Игрока).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ходы_противника( ГлЦ : ЦП: ХодыИгр : ХодыПр :_,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ХодыПр).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [X | Спис]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [Y | Спис]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, Спис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 15.6.\b0   Миниатюрный интерпретатор языка AL0.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Форсированное дерево — это дерево ходов, представленное в программе следующей структурой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ход .. [ Ответ1 .. Фдер1, Ответ2 .. Фдер2, ... ]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь ".." — инфиксный оператор; Ход — первый ход "игрока"; Ответ1, Ответ2, … — возможные ответы противника; Фдер1, Фдер2, … — форсированные поддеревья для каждого из этих ответов.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 15.6.2. Программа на языке советов для эндшпиля "король и ладья против короля"\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Общий принцип достижения выигрыша королем и ладьей против единственной фигуры противника, короля, состоит в том, чтобы заставить короля отступить к краю доски или, при необходимости, загнать его в угол, а затем поставить мат в несколько ходов. В детальном изложении эта стратегия выглядит так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Повторять циклически, пока не будет поставлен мат (постоянно проверяя, что не возникла патовая позиция и что нет нападения на незащищенную ладью):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) Найти способ поставить королю противника мат в два хода.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) Если не удалось, то найти способ уменьшить ту область доски, в которой король противника "заперт" под воздействием ладьи.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) Если и это не удалось, то найти способ приблизить своего короля к королю противника.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (4) Если ни один из элементарных советов 1, 2, или 3 не выполним, то найти способ сохранить все имеющиеся к настоящему моменту "достижения" в смысле (2) и (3) (т.е. сделать выжидающий ход).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (5) Если ни одна из целей 1, 2, 3 или 4 не достижима, то найти способ получить позицию, в которой ладья занимает вертикальную или горизонтальную линию, отделяющую одного короля от другого.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Описанные выше принципы реализованы во всех деталях в таблице советов на языке AL0, показанной на рис. 15.7. Эта таблица может работать под управлением интерпретатора рис. 15.6. Рис. 15.8 иллюстрирует смысл некоторых из предикатов, использованных в таблице советов, а также показывает, как эта таблица работает.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В таблице используются следующие предикаты:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Предикаты целей\i0  \par
\par { \trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 мат\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 мат королю противника\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 пат\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 пат королю противника\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 потеря_ладьи\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 король противника может взять ладью\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ладья_под_боем\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 король противника может напасть на ладью прежде, чем наш король сможет ее защитить\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 уменьш_простр\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 уменьшилось "жизненное пространство" короля противника, ограничиваемое ладьей\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 раздел\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ладья занимает вертикальную или горизонтальную линию, разделяющую королей\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ближе_к_клетке\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 наш король приблизился к "критической клетке" (см. рис. 15.9), т.е. манхеттеновское расстояние до нее уменьшилось\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 l_конфиг\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 "L-конфигурация" (рис. 15.9)\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 простр_больше_2\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 "жизненное пространство" короля противника занимает больше двух клеток\b0\cell

}\row }\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Предикаты, ограничивающие ходы\i0  \par
\par { \trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 глубина = N\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ход на глубине N дерева поиска\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 разреш\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 любой разрешенный ход\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ход_шах\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ход, объявляющий шах\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ход_ладьей\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ход ладьей\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 нет_хода\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ни один ход не подходит\b0\cell

}\row\trowd\trql\trftsWidth2\trwWidth5000\intbl
\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx

\clftsWidth2\clbrdrt\brdrs\brdrw10\clbrdrl\brdrs\brdrw10\brdrs\brdrw10\clbrdrb\brdrs\brdrw10\clbrdrr1\brdrs\brdrw10\cellx
{\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 сначала_диаг\b0\cell

\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \fi0\li50\ri50 ход королем, преимущественно по диагонали\b0\cell

}\row }\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Окончание "король и ладья против короля" на языке AL0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Правила\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 правило_края:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если король_противника_на_краю и короли_рядом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  то [мат_2, потеснить, приблизиться,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      сохранить_простр, отделить_2, отделить_3].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 иначе_правило\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  если любая_поз\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  то [ потеснить, приблизиться, сохранить_простр,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       отделить_2, отделить_3].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Элементарные советы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 совет( мат_2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        мат :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        не потеря_ладьи и король_противника_на_краю:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина = 0) и разреш\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        затем (глубина = 2) и ход_шах :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина = 1) и разреш ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 совет( потеснить,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        уменьш_простр и не ладья_под_боем и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        раздел и не пат :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        не потеря_ладьи :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина = 0) и ход_ладьей :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        нет_хода ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 совет( приблизиться,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        ближе _к_клетке и не ладья_под_боем и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (раздел или l_конфиг) и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (простр_больше_2 или не наш_король_на_краю):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        не потеря_ладьи :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина = 0) и сначала_диаг :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        нет_хода ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 совет( сохранить_простр,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        ход_противника и не ладья_под_боем и раздел\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        и не_дальше_от_ладьи и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (простр_больше_2 или не наш_король_на_краю):\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        не потеря_ладьи :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина = 0) и сначала_диаг :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        нет_хода ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 совет( отделить_2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        ход_противника и раздел и не ладья_под_боем:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        не потеря_ладьи :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина < 3) и разреш :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина < 2) и разреш ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 совет( отделить_3,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        ход_противника и раздел и не ладья_под_боем:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        не потеря_ладьи :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина < 5) и разреш :\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0        (глубина < 4) и разреш ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 15.7.\b0   Таблица советов на языке AL0 для окончания "король и ладья против короля". Таблица состоит из двух правил и шести элементарных советов.\par
\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 15.8.\b0   Фрагмент шахматной партии, полученный с использованием таблицы советов рис. 15.7 и иллюстрирующий применение стратегии оттеснения короля в угол доски. В этой последовательности ходов выполнялись элементарные советы: сохранить_ простр (выжидающий ход, сохраняющий "жизненное пространство" черного короля) и потеснить (ход, сокращающий "жизненное пространство"). Область, в которой заключен черный король, выделена штриховкой. После выполнения последнего совета потеснить эта область сократилась с восьми до шести клеток.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 15.9.\b0   (а) "Критическая клетка" отмечена крестиком. Она используется при маневрировании с целью оттеснить черного короля. Белый король приближается к "критической клетке", двигаясь, как указано на рисунке. (б) Три фигуры образуют конфигурацию, напоминающую букву L.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Аргументами этих предикатов являются либо позиции (в предикатах целей), либо ходы (в предикатах, ограничивающих ходы). Предикаты целей могут иметь один или два аргумента. Первый из аргументов — это всегда текущая вершина поиска; второй аргумент (если он имеется) — корневая вершина дерева поиска. Второй аргумент необходим в так называемых сравнивающих предикатах, которые сравнивают корневую и текущую позиции в том или ином отношении. Например, предикат уменьш_простр проверяет, сократилось ли "жизненное пространство" короля противника (рис. 15.8). Эти предикаты вместе с шахматными правилами (применительно к окончанию "король и ладья против короля"), а также процедура для отображения текущего состояния игровой доски (отобр( Поз)) запрограммированы на рис. 15.10.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 15.8 показано, как играет наша программа, основанная на механизме советов. При продолжении игры из последней позиции рис. 15.8 она могла бы протекать так, как в приведенном ниже варианте (в предположении, что "противник" ходит именно так, как указано). Здесь использована алгебраическая шахматная нотация, в которой вертикальные линии пронумерованы, как 'а', 'b', 'с', … а горизонтальные — как 1, 2, 3, …. Например, ход ЧК b7 означает: передвинуть черного короля на клетку, расположенную на пересечении вертикальной линии 'b' с горизонтальной линией 7.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 …        ЧК b7\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БК d5  ЧК с7\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БК с5  ЧК b7\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БЛ с6  ЧК а7\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БЛ b6  ЧК а8\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БК b5  ЧК а7\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БК с6  ЧК а8\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БК с7  ЧК а7\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БЛ с6  ЧК а8\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 БЛ а6  мат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Теперь уместно задать некоторые вопросы. Во-первых, является ли наша программа-советчик \i корректной\i0   в том смысле, что она ставит мат при любом варианте защиты со стороны противника и при любой начальной позиции, в которой на доске король и ладья против короля? В статье Bratko (1978) приведено формальное доказательство того, что таблица советов, практически совпадающая с таблицей рис. 15.7, действительно является корректной в указанном смысле.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Другой возможный вопрос: является ли программа оптимальной, то есть верно ли, что она ставит мат за минимальное число ходов? Нетрудно показать на примерах, что игру нашей программы в этом смысле нельзя назвать оптимальной. Известно, что оптимальный вариант в этом окончании (т.е. предполагающий оптимальную игру с обеих сторон) имеет длину не более 16 ходов. Хотя наша таблица советов и далека от этого оптимума, было показано, что число, ходов наверняка не превосходит 50. Это важный результат в связи с тем, что в шахматах существует "правило 50-ти ходов": в эндшпилях типа "король и ладья против короля" противник, имеющий преимущество, должен поставить, мат не более, чем за 50 ходов; иначе может быть объявлена ничья.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Библиотека предикатов для окончания\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % "король и ладья против короля"\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Позиция представлена стуктурой:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % ЧейХод..Бх : Бу..Лх : Лу..Чх : Чу..Глуб\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % ЧейХод - с чьей стороны ход в этой позиции ('б' или 'ч')\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Бх, Бу - координаты белого короля\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Лх, Лу - координаты белой ладьи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Чх, Чу - координаты черного короля\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Глуб - глубина, на которой находится эта позиция в дереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % поиска\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Отношения выбора элементов позиции\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 чей_ход( ЧейХод.._, ЧейХод).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 бк( _..БК.._, БК).                % Белый король\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 бл( _.._..БЛ.._, БЛ).             % Белая ладья\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 чк( _.._.._..ЧК.._, ЧК).          % Черный король\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 глуб( _.._.._.._..Глуб, Глуб).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 восст_глуб( ЧХ..Б..Л..Ч..Г, ЧХ..Б..Л..Ч..0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Формируется копия позиции, глубина устанавливается в 0\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Некоторые отношения между клетками доски\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сосед_чсл( N, N1) :- % Соседнее число "в пределах доски"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( N1 is N + 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    N1 is N - 1 ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внутри( N1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( N) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N > 0, N < 9.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сосед_диаг( X : Y, X1 : Y1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Соседние клетки по диагонали\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сосед_чсл( X, X1 ), сосед_чсл( Y, Y1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сосед_верт( X : Y, X : Y1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Соседние клетки по вертикали\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сосед_чсл( Y, Y1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сосед_гор( X : Y, X1 : Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Соседние клетки по горизонтали\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сосед_чсл( X, X1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сосед( S, S1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Соседние клетки (предпочтение - диагонали)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сосед_диаг( S, S1);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сосед_гор( S, S1);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сосед_верт( S, S1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конец_игры( Поз) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  мат( Поз).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Предикаты, ограничивающие ходы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Специализированное генераторы ходов вида:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % ход( Ограничение, Поз, Ход, Поз1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( глубина < Макс, Поз, Ход, Поз1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  глуб( Поз, Г),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Г < Макс, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( глубина = Г, Поз, Ход, Поз1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  глуб( Поз, Г), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( сначала диаг, б..Б..Л..Ч..Г, Б-Б1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ч..Б1..Л..Ч..Г1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Г1 is Г + l,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сосед( Б, Б1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % "сосед" порождает сначала диагональные ходы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not сосед( Б1, Ч), % Не попасть под шах\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Б1 \\== Л.          % Не столкнуться с ладьей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( ход ладьей, б..Б..Лх : Лу..Ч..Г, Лх : Лу-Л,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ч..Б..Л..Ч..Г1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Г1 is Г + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  коорд( I),                       % Число между 1 и 8\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Л = Лх : I; Л = I : Лу),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % По горизонтали или по вертикали\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Л \\== Лх : Лу,                   % Обязательно двигаться\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not мешает( Лх : Лу, Б, Л).      % Мешает белый король\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( ход_шах, Поз, Л-Лх : Лу, Поз1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  бл( Поз, Л),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  чк( Поз, Чх : Чу),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Лх = Чх; Лу = Чу),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Ладья и черный король на одной линии\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход( ход_ладьей, Поз, Л-Лх : Лу, Поз1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( разреш, б..П, М, П1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Огр = сначала_диаг; Огр = ход ладьей),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход( Огр, б..П, М, П1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход( разреш, ч..Б..Л..Ч..Г, Ч-Ч1, б..Б..Л..Ч1..Г1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Г1 is Г + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сосед( Ч, Ч1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not шах( б..Б..Л..Ч1..Г1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разрход( Поз, Ход, Поз1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход( разреш, Поз, Ход, Поз1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  шах( _..Б..Лх : Лу..Чх : Чу.._ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сосед( Б, Чх : Чу);              % Короли рядом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Лх = Чх; Лу = Чу),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Лх : Лу \\== Чх : Чу,             % Нет взятия ладьи\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not мешает( Лх : Лу, Б, Чх : Чу).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мешает( S, S1, S1) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мешает( X1 : Y, X2 : Y, Х3 : Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  упоряд( X1, Х2, Х3), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мешает( X : Y1, X : Y2, X : Y3) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  упоряд( Y1, Y2, Y3).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 упоряд( N1, N2, N3) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N1 < N2, N2 < N3;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N3 < N2, N2 < N1.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 коорд( 1). коорд( 2). коорд( 3). коорд( 4).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 коорд( 5). коорд( 6). коорд( 7). коорд( 8).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Предикаты целей\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 любая_поз( Поз).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ход_противника( б.._ ).           % Противник ходит белыми\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 мат( Поз) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  чей_ход( Поз, ч),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  шах( Поз),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not разрход( Поз, _, _ ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пат( Поз) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  чей_ход( Поз, ч),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not шах( Поз),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not разрход( Поз, _, _ ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 уменьш_простр( Поз, КорнПоз) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  простр( Поз, Пр),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  простр( КорнПоз, КорнПр),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Пр < КорнПр.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ладья_под_боем( ЧейХод..Б..Л..Ч.._ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расст( Б, Л, P1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расст( Ч, Л, Р2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( ЧейХод = б, !, P1 > Р2 + 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    ЧейХод = ч,  !,  P1 > Р2 ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ближе_к_клетке( Поз, КорнПоз) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расст_до_клетки( Поз, P1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расст_до_клетки( КорнПоз, Р2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  P1 < Р2.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расст_до_клетки( Поз, Мрасст) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0                % Манхеттеновское расстояние\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  бк( Поз, БК), % между БК и критической клеткой\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  кк( Поз, КК), % Критическая клетка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  манх_расст( БК, КК, Мрасст).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 раздел( _..Бх : Бу..Лх : Лу.. Чх : Чу.._ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  упоряд( Бх, Лх, Чх), !;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  упоряд( Бу, Лу, Чу).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 l_конфиг( _..Б..Л..Ч.._ ) :-      % L - конфигурация\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  манх_расст( Б, Ч, 2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  манх_расст( Л, Ч, 3).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 не дальше_от_ладьи( _..Б..Л.._, _..Б1..Л1.._ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расст( Б, Л, P),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расст( Б1, Л1, P1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  P =< P1.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 простр_больше_2( Поз) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  простр( Поз, Пр),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Пр > 2.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 наш_король_на_краю( _..X : Y.._ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Белый король на краю\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( X = 1, !; X = 8, !; Y = 1, !; Y = 8).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 король_противника_на_краю( _..Б..Л..X : Y.._ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Черный король на краю\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( X = 1, !; X = 8, !; Y = 1, !; Y = 8).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 короли_рядом( Поз) :-             % Расстояние между королями  <  4\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  бк( Поз, БК), чк( Поз, ЧК),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  расст( БК, ЧК, P),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  P < 4.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 потеря_ладьи( _..Б..Л..Л.._ )- % Ладья взята\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 потеря_ладьи( ч..Б..Л..Ч.._ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сосед( Ч, Л),                 % Черный король напал на ладью\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not сосед( Б, Л).             % Белый король не защищает ладью\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 расст( X : Y, X1 : Y1, P) :-   % Расстояние до короля\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  абс_разн( X, X1, Рх),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  абс_разн( Y, Y1, Ру),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  макс( Рх, Ру, P).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 абс_разн( А, В, С) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  А > В, !, С is A - В;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  С is В - А.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 макс( А, В, М) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  А >= В, !, М = А;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  М = В.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 манх_расст( X : Y, X1 : Y1, P) :- % Манхеттеновское расстояние\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  абс_разн( X, X1, Рх),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  абс_разн( Y, Y1, Ру),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  P is Рх + Ру.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 простр( Поз, Пр) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Область, в которой "заперт" черный король\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  бл( Поз, Лх : Лу),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  чк( Поз, Чх : Чу),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Чх < Лх, СторонаХ is Лх - 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Чх > Лх, СторонаХ is 8 - Лх ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Чу < Лу, СторонаY is Лу - 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Чу > Лу, СторонаY is 8 - Лу ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Пр is СторонаХ * СторонаY, !;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Пр = 64. % Ладья и черный король на одной линии\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 кк( _..Б..Лх : Лу.. Чх : Чу.._, Кх : Ку) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Критическая клетка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Чх < Лх, !, Кх is Лх - 1; Кх is Лх + 1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Чу < Лу, !, Ку is Лу - 1; Ку is Лу + 1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Процедуры для отображения позиций\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( Поз) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  коорд( Y), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  коорд( X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  печ_фиг( X : Y, Поз),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  fail.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( Поз) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  чей_ход( Поз, ЧХ), глуб( Поз, Г),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( 'ЧейХод='), write( ЧХ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( 'Глубина='), write( Г), nl.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 печ_фиг( Клетка, Поз):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  бк( Поз, Клетка), !, write( 'Б');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  бл( Поз, Клетка), !, write( 'Л');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  чк( Поз, Клетка), !, write( 'Ч');\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( '.').\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 показать_ход( Ход) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  nl, write( Ход), nl.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 15.10.\b0   Библиотека предикатов для окончания "король и ладья против короля".\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Проект\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Рассмотрите какой-нибудь другой простой эндшпиль, например "король и пешка против короля", и напишите для него программу на языке AL0 (вместе с определениями соответствующих предикатов).\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Игры двух лиц поддаются формальному представлению в виде И/ИЛИ-графов. Поэтому процедуры поиска в И/ИЛИ-графах применимы для поиска в игровых деревьях.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Простой алгоритм поиска в глубину в игровых деревьях легко программируется, но для игр, представляющих интерес, он не эффективен. Более реалистичный подход — минимаксный принцип в сочетании с оценочной функцией и поиском, ограниченным по глубине.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Альфа-бета алгоритм является эффективной реализацией минимаксного принципа. Эффективность альфа-бета алгоритма зависит от порядка, в котором просматриваются варианты ходов. Применение альфа-бета алгоритма приводит, в лучшем случае, к уменьшению коэффициента ветвления дерева поиска, соответствующему извлечению из него квадратного корня.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В альфа-бета алгоритм можно внести ряд усовершенствований. Среди них: продолжение поиска за пределы ограничения по глубине вплоть до спокойных позиций, последовательное углубление и эвристическое отсечение ветвей.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Численная оценка позиций является весьма ограниченной формой представления знаний о конкретной игре. Более богатый по своим возможностям метод представления знаний должен предусматривать внесение в программу знаний о типовых ситуациях. Язык Советов (Advice Language) реализует такой подход. На этом языке знания представляются в терминах целей и средств для их достижения.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В данной главе мы составили следующие программы: программная реализация минимаксного принципа и альфа-бета процедуры, интерпретатор языка AL0 и таблица советов для окончания "король и ладья против короля".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Были введены и обсуждены следующие понятия:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   игры двух лиц с полной информацией\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   игровые деревья\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   оценочная функция, минимаксный принцип\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   статические оценки, рабочие оценки\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   альфа-бета алгоритм\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   последовательное углубление,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   эвристическое отсечение,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   эвристики для обнаружения спокойных позиций\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Языки Советов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   цели, ограничения, элементарные советы,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   таблица советов\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Минимаксный принцип, реализованный в форме альфа-бета алгоритма, — это наиболее популярный метод в игровом программировании. Особенно часто он применяется в шахматных программах. Минимаксный принцип был впервые предложен Шенноном (Shannon 1950). Возникновение и становление альфа-бета алгоритма имеет довольно запутанную историю. Несколько исследователей независимо друг от друга открыли либо реализовали этот метод полностью или частично. Эта интересная история описана в статье Knuth and Moore (1978). Там же приводится более компактная формулировка альфа-бета алгоритма, использующая вместо минимаксного принципа принцип "него-макса" ("neg-max" principle), и приводится математический анализ производительности алгоритма. Наиболее полный обзор различных минимаксных алгоритмов вместе с их теоретическим анализом содержится в книге Pearl (1984). Существует еще один интересный вопрос, относящийся к минимаксному принципу. Мы знаем, что статическим оценкам следует доверять только до некоторой степени. Можно ли считать, что рабочие оценки являются более надежными, чем исходные статические оценки, из которых они получены? В книге Pearl (1984) собран ряд математических результатов, имеющих отношение к ответу на этот вопрос. Приведенные в этой книге результаты, касающиеся распространения ошибок по минимаксному дереву, объясняют, в каких случаях и почему минимаксный принцип оказывается полезным.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сборник статей Bramer (1983) охватывает несколько аспектов игрового программирования. Frey (1983) — хороший сборник статей по шахматным программам. Текущие разработки в области машинных шахмат регулярно освещаются в серии Advances in Computer Chess и в журнале ICCA.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод Языка Советов, позволяющий использовать знания о типовых ситуациях, был предложен Д. Мики. Дальнейшее развитие этого метода отражено в Bratko and Michi (1980 a, b) и Bratko (1982, 1984, 1985). Программа для игры в эндшпиле "король и ладья против короля", описанная в этой главе, совпадает с точностью до незначительных модификаций с таблицей советов, корректность которой была математически доказана в статье Bratko (1978). Ван Эмден также запрограммировал эту таблицу советов на Прологе (van Emden 1982).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Среди других интересных экспериментов в области машинных шахмат, преследующих цель повысить эффективность знаний (а не перебора), следует отметить Berliner (1977), Pitrat (1977) и Wilkins (1980).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Advances in Computer Chess Series\i0   (M.R.B. Clarke, ed). Edinburgh University Press (Vols. 1-2), Pergamon Press (Vol. 3).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Berliner M. A. (1977); A representation and some mechanisms for a problem solving chess program. In: \i Advances in Computer Chess 1\i0   (M.R.B. Clarke, ed). Edinburgh University Press.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bramer M. A; (1983, ed). \i Computer Game Playing: Theory and Practice.\i0   Ellis Horwood and John Wiley.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bratko I. (1978) Proving correctness of strategies in the AL1 assertional language. \i Information Processing Letters 7\i0  : 223-230.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bratko I. (1982). Knowledge-based problem solving in AL3. In: \i Machine Intelligence 10\i0   (J. Hayes, D. Michie, J. H. Pao, eds.). Ellis Horwood (an abbreviated version also appears in Bramer 1983).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bratko I. (1984). Advise and planning in chess end-games. In: \i Artificial and Human Intelligence\i0   (S. Amarel, A. Elithorn, R. Banerji, eds.). North-Holland.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bratko I. (1985). Symbolic derivation of chess patterns. In: \i Progress Artificial Intelligence\i0   (L. Steels, J. A. Campbell, eds.). Ellis Horwood and John Wiley.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bratko I. and Michie D. (1980a). A representation of pattern-knowledge in chess end-games. In: \i Advances in Computer Chess\i0   2 (M.R.B. Clarke, ed). Edinburgh University Press.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Bratko I. and Michie D. (1980b). An advice program for a complex chess programming task. \i Computer Journal\i0   \b 23\b0  : 353-359.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Frey P. W. (1983, ed.). \i Chess Skill in Man and Machine\i0   (second edition). Springer-Verlag.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Knuth D. E. and Moore R. W. (1975). An analysis of alpha-beta pruning. \i Artificial Intelligence\i0   \b 6\b0  : 93-326.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Pearl J. (1984). Heuristics: Intelligent Search Strategies for Computer Problem Solving. Addison-Wesley.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Pitrat J. (1977). A chess combination program which uses plans \i Artificial Intelligence\i0   \b 8\b0  : 275-321.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Shannon C.E. (1950). Programming a computer for playing chess. \i Philosophical Magazine\i0   \b 41\b0  : 256-275. [В сб. Шеннон К. Работы по теории информации и кибернетике. — М.: ИЛ., 1963.]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 van Emden M. (1982). Chess end-game advice: a case study in computer utilisation of knowledge. In: \i Machine Intelligence 10\i0   (J. Hayes, D. Michie, J.H. Pao, eds). Ellis Hordwood.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Wilkins D.E. (1980). Using patterns and plans in chess. \i Artificial Intelligence\i0   \b 14\b0  : 165-203. \par
\par
\par
\s3 \qc\snext0\i0\fs26\f0\b\fi0\li0\ri0 Глава 16\par
Программирование в терминах типовых конфигураций\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В этой главе мы будем заниматься системами, ориентированными на типовые конфигурации ("образцы"), рассматривая их как некоторый специальный подход к программированию. Языком, ориентированным на образцы, можно считать и сам Пролог. Мы реализуем небольшой интерпретатор для простых программ этого типа и постараемся передать дух такого "конфигурационной" программирования на нескольких примерах.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 16.1. Архитектура, ориентированная на типовые конфигурации \par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 16.1.1. Основные понятия\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Под \i системами, ориентированными на типовые конфигурации (образцы)\i0  , мы будем понимать программные системы специальной архитектуры. Для некоторых конкретных типов задач такая архитектура дает преимущества по сравнению с традиционным способом организации. Среди задач, которые естественным образом вписываются в этот вид архитектуры, находятся многие приложения искусственного интеллекта, в том числе экспертные системы. Основное различие между традиционными системами и системами, ориентированными на образцы, заключается в механизме запуска программных модулей. Традиционная архитектура предполагает, что модули системы обращаются друг к другу в соответствии с фиксированной, заранее заданной и явным образом сформулированной схемой. Каждый программный модуль сам принимает решение о том, какой из других модулей следует запустить в данный момент, причем в нем содержится \i явное\i0   обращение к этим модулям. Соответствующая временная структура передач управления от одних модулей к другим оказывается последовательной и детерминированной.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В противоположность этому организация, ориентированная на образцы, не предполагает прямого обращения из одних модулей к другим. Модули запускаются \i конфигурациями\i0  , возникающими в их "информационной среде". Такие программные модули называют модулями, \i управляемыми типовыми конфигурациями\i0   (или \i образцами\i0  ). Программа, управляемая образцами, представляет из себя набор модулей. Каждый модуль определяется\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) образцом, соответствующим предварительному условию запуска, и\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) тем действием, которое следует выполнить, если информационная среда согласуется с заданным образцом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Запуск модулей на выполнение происходит при появлении тех или иных конфигураций в информационной среде системы. Такую информационную среду обычно называют \i базой данных\i0  . Наглядное представление о системе рассматриваемого типа дает рис. 16.1.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 16.1.\b0   Система, управляемая типовыми конфигурациями (образцами)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Следует сделать несколько важных замечаний относительно рис. 16.1. Совокупность модулей не имеет иерархической структуры. Отсутствуют явные указания на то, какие модули могут обращаться к каким-либо другим модулям. Модули связаны скорее с базой данных, чем непосредственно друг с другом. В принципе такая структура допускает параллельное выполнение сразу нескольких модулей, поскольку текущее состояние базы данных может прийти в соответствие сразу с несколькими предварительными условиями, а следовательно, в принципе могут запуститься несколько модулей одновременно. В связи с этим, подобную организацию можно рассматривать как естественную модель параллельных вычислений, имея в виду, что каждый модуль физически реализован на отдельном процессоре.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Архитектура, ориентированная на образцы, обладает рядом достоинств. Одно из ее главных преимуществ состоит в том, что, разрабатывая подобную систему, мы не должны тщательно продумывать и заранее определять все связи между модулями. Следовательно, каждый модуль может быть разработан и реализован относительно автономно. Это придает системе высокую степень модульности, проявляющуюся, например, в том, что удаление из системы какого-либо модуля не обязательно приводит к фатальным последствиям. После удаления модуля система во многих случаях сохранит свою способность к решению задач, измениться может только \i способ\i0   их решения. Аналогичное соображение верно и в случае добавления новых модулей или изменения уже существующих. Заметим, что при введении подобных модификаций в традиционные системы потребовалось бы, как минимум, пересмотреть связи между модулями.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Высокая степень модульности особенно желательна в системах со сложными базами знаний, поскольку очень трудно предсказать заранее все возможные взаимодействия между отдельными фрагментами знаний. Архитектура, ориентированная на образцы, обеспечивает простое решение этой проблемы: каждый фрагмент знаний, представленный в виде "если-то"-правила, можно считать отдельным модулем, запускаемым своим собственным образцом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Перейдем теперь к более детальной проработке нашей базовой схемы для систем, ориентированных на образцы, и рассмотрим вопросы реализации. Как следует из рис. 16.1, параллельная реализация была бы для нашей системы наиболее естественным решением. Тем не менее предположим, что нам предстоит реализовать ее на традиционном последовательном процессоре. Тогда если в базе знаний окажется сразу несколько "пусковых" конфигураций, относящихся к нескольким модулям, то возникнет конфликтная ситуация: нам придется принять решение о том, какой из этих потенциально активных модулей будет запущен в действительности. Совокупность всех потенциально активных модулей назовем \i конфликтным множеством\i0  . Очевидно, что реализация схемы рис. 16.1 на последовательном процессоре потребует введения в систему дополнительного,  \i управляющего модуля\i0  . Задача управляющего модуля — выбрать и активизировать один из модулей конфликтного множества и тем самым разрешить конфликт. Одно из возможных простых правил разрешения конфликта может основываться, например, на предварительном упорядочивании множества модулей системы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Основной цикл работы системы, ориентированной на образцы, состоит, таким образом, из трех шагов:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) \i Сопоставление с образцами\i0  : найти в базе данных все конфигурации, сопоставимые с пусковыми образцами программных модулей. Результат — конфликтное множество.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) \i Разрешение конфликта\i0  : выбрать один из модулей, входящих в конфликтное множество.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) \i Выполнение\i0  : запустить модуль, выбранный на предыдущем шаге.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Этот принцип реализации показан в виде схемы на рис. 16.2.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 16.1.2. Прологовские программы как системы, управляемые образцами\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программы, написанные на Прологе, можно рассматривать как системы, управляемые образцами. Между пролог-программами и этими системами можно установить соответствие примерно следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Каждое предложение прологовской программы можно считать отдельным модулем со своим пусковым образцом. Голова предложения соответствует образцу, тело - тому действию, которое выполняет модуль.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • База данных системы — это текущий список целей, которые пролог-система пытается удовлетворить.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Предложение пролог-системы "запускается", если его голова сопоставима с целью, расположенной первой в базе данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Выполнить действие модуля (т.е. тело предложения) — это значит: поместить в базу данных вместо первой из целей весь список целей тела предложения (с соответствующей конкретизацией переменных).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Процесс активизации модулей (предложений) не детерминирован в том смысле, что с первой целью базы данных могут удачно сопоставить свою голову сразу несколько предложений, и, вообще говоря, любое из них может быть запущено. В Прологе этот недетерминизм реализован при помощи механизма возвратов.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 16.2.\b0   Основной цикл работы системы, управляемой образцами. В этом примере база данных согласуется с пусковыми образцами модулей 1, 3 и 4; для выполнения выбран модуль 3.\par
\par
\s5 \qc\snext0\i\fs24\f1\b\fi0\li0\ri0 16.1.3. Пример составления программы\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 С системами, управляемыми образцами, связан свой особый стиль программирования, требующий специфического программистского мышления. Мы говорим в этом случае о \i программировании в терминах образцов\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В качестве иллюстрации, рассмотрим элементарное упражнение по программированию — вычисление наибольшего общего делителя \i D\i0   двух целых чисел \i А\i0   и \i В\i0  . Рассмотрим классический алгоритм Евклида:\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600 Для того, чтобы вычислить наибольший общий делитель \i D\i0   чисел \i А\i0   и \i В\i0  , необходимо:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600  Повторять циклически, пока \i А\i0   и \i В\i0   не совпадут:\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600   если \i А > В\i0  , то заменить \i А\i0   на \i А - В\i0  ,\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600   иначе заменить \i В\i0   на \i В - А\i0  .\par
\s13 \qj\snext0\f1\fs22\b0\i0\li1134\ri600  После выхода из цикла \i А\i0   и \i В\i0   совпадают; наибольший общий делитель \i D\i0   равен \i А\i0   (или \i В\i0  ).\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Тот же самый процесс можно описать при помощи двух модулей, управляемых образцами:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Модуль 1\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Условие\i0   В базе данных существуют такие два числа \i X\i0   и \i Y\i0  , что \i X > Y\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Действие\i0   Заменить \i X\i0   на разность \i X - Y\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Модуль 2\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Условие\i0   В  базе данных имеется число \i X\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Действие\i0   Выдать результат \i X\i0   и остановиться.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Очевидно, что всегда, когда условие Модуля 1 удовлетворяется, удовлетворяется также и условие Модуля 2, и мы имеем конфликт. В нашем случае конфликт можно разрешить при помощи простого управляющего правила: всегда отдавать предпочтение Модулю 1. База данных первоначально содержит числа \i А\i0   и \i В\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь нас ждет приятный сюрприз: оказывается, что наша программа способна решать более общую задачу, а именно, она может вычислять наибольший общий делитель для любого количества чисел. Если в базу данных загрузить несколько целых чисел, то программа выведет их наибольший общий делитель. На рис. 16.3 показана возможная последовательность изменений, которые претерпевает база данных прежде, чем будет получен результат. Обратите внимание на то, что предварительные условия модулей могут удовлетворяться одновременно в нескольких местах базы данных.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 16.3.\b0   Процесс вычисления наибольшего общего делителя множества чисел. Первоначально база данных содержит числа 25, 10, 15 и 30. Вертикальная стрелка соединяет число с его "заменителем". Конечное состояние базы данных: 5, 5, 5, 5.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В данной главе мы реализуем интерпретатор простого языка для описания систем, управляемых образцами, и проиллюстрируем на примерах дух программирования в терминах образцов.\par
\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 16.2. Простой интерпретатор программ, управляемых образцами\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для описания модулей, управляемых образцами, мы применим следующую синтаксическую конструкцию:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ЧастьУсловия ---> ЧастьДействия\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Часть условия представляет собой список условий:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ Условие1, Условие2, Условие3, ...]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 где Условие1, Условие2 и т.д. — обычные прологовские цели. Предварительное условие запуска модуля считается выполненным, если все цели, содержащиеся в списке, достигнуты. Часть действия — это список действий:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ Действие1, Действие2, ...]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Каждое отдельное действие — это, как и раньше, прологовская цель. Для того, чтобы выполнить список действий, нужно выполнить все действия из списка. Другими словами, все соответствующие цели должны быть удовлетворены. Среди допустимых действий будут действия, соответствующие манипулированию базой данных: добавить, удалить или заменить те или иные объекты базы данных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 16.4 показано, как выглядит наша программа вычисления наибольшего общего делителя, записанная в соответствии с введенным нами синтаксисом.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Продукционные правила для нахождения наибольшего общего\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % делителя (алгоритм Евклида)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 300, fx, число).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ число X, число Y, X > Y ] --->\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ НовХ is X - Y, заменить( число X, число НовХ) ].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ число X ] ---> [ write( X), стоп ].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Начальное состояние базы данных\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 число 25.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 число 10.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 число 15.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 число 30.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 16.4.\b0   Программа, управляемая образцами, для получения наибольшего общего делителя множества чисел.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Самый простой способ реализации этого языка — использовать механизмы управления базой данных, встроенные в Пролог. Добавить объект в базу данных или удалить объект из базы данных можно, применяя встроенные процедуры\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 assert ( Объект)   retract( Объект)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Заменить один объект на другой также просто:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 заменить( Объект1, Объект2) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  retract( Объект1), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  assert( Объект2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь задача оператора отсечения — не допустить, чтобы оператор retract удалил из базы данных более чем один объект (при возвратах).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Простой интерпретатор для программ, управляемых образцами\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Работа с базой данных производится при помощи процедур\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % assert и retract\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 800, xfx, --->).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пуск :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Условие ---> Действие,          % правило\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  проверить( Условие),            % Условие выполнено?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выполнить( Действие).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 проверить( []).                  % Пустое условие\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 проверить( [Усл | Остальные]) :- % проверить конъюнкцию\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  call( Усл),                     % условий\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  проверить( Остальные).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выполнить( [ стоп] ) :- !. % Прекратить выполнение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выполнить( []) :-          % Пустое действие (цикл завершен)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  пуск.                     % Перейти к следующему циклу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 выполнить [Д | Остальные] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  саll( Д),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выполнить( Остальные).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 заменить( А, В) :-         % Заменить в базе данных А на В\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  retract( A), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  assert( В).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 16.5.\b0   Простой интерпретатор для программ, управляемых образцами.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Простой интерпретатор для программ, управляемых образцами, показан на рис. 16.5. Следует признать, что в интерпретаторе допущены значительные упрощения. Так, например, в него заложено чрезвычайно простое и жесткое правило разрешения конфликтов: всегда запускать \i первый\i0   из потенциально активных модулей (в соответствии с тем порядком, в котором модули записаны в программе). Таким образом, программисту предоставлено единственное средство управления процессом интерпретации — он может указать тот или иной порядок следования модулей. Начальное состояние базы данных задается в виде прологовских предложений, записанных в исходной программе. Запуск программы производится при помощи вопроса\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- пуск.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 16.3. Простая программа для автоматического доказательства теорем\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В настоящем разделе мы реализуем простую программу для автоматического доказательства теорем в виде системы, управляемой образцами. Эта программа будет основана на \i принципе резолюции\i0   — популярном методе, обычно используемом в машинном доказательстве теорем. Мы ограничимся случаем \i пропозициональной логики\i0  , поскольку нашей целью будет дать всего лишь простую иллюстрацию используемого принципа. На самом деле, принцип резолюции можно легко обобщить на случай исчисления высказываний первого порядка (с применением логических формул, содержащих переменные). Базовый Пролог можно рассматривать как частный случай системы доказательства теорем, основанной на принципе резолюции.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задачу доказательства теорем можно сформулировать так: дана формула, необходимо показать, что эта формула является теоремой, т.е. она верна всегда, независимо от интерпретации встречающихся в ней символов. Например, утверждение, записанное в виде формулы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i p\i0    v  \i ~ p\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и означающее "\i p\i0   или не \i p\i0  ", верно всегда, независимо от смысла утверждения \i p\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Мы будем использовать в качестве операторов следующие символы:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ~     отрицание, читается как  "не"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 &    конъюнкцию, читается как  "и"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 v    дизъюнкцию, читается как  "или"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 =>  импликацию, читается как  "следует"\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Согласно правилам предпочтения операторов, оператор "не" связывает утверждения сильнее, чем "и", "или" и "следует".\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Метод резолюции предполагает, что мы рассматриваем отрицание исходной формулы и пытаемся показать, что полученная формула противоречива. Если это действительно так, то исходная формула представляет собой тавтологию. Таким образом, основную идею можно сформулировать так: доказательство противоречивости формулы с отрицанием эквивалентно доказательству того, что исходная формула (без отрицания) есть теорема (т.е. верна всегда). Процесс, приводящий к искомому противоречию, состоит из отдельных шагов, на каждом из которых применяется резолюция.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Давайте проиллюстрируем этот принцип на примере. Предположим, что мы хотим доказать, что теоремой является следующая пропозициональная формула:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (\i а  =>  b\i0  ) & (\i b  =>  с\i0  ) => (\i а  =>  с\i0  )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Смысл этой формулы таков: если из \i а\i0   следует \i b\i0   и из \i b\i0   следует \i с\i0  , то из \i а\i0   следует \i с\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Прежде чем начать применять процесс резолюции ("резолюционный процесс"), необходимо представить отрицание нашей формулы в наиболее приспособленной для этого форме. Такой формой является \i конъюнктивная нормальная форма\i0  , имеющая вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (\i р\i0  \sub 1\nosupersub   v  \i p\i0  \sub 2\nosupersub   v  …)  &  (\i q\i0  \sub 1\nosupersub   v  \i q\i0  \sub 2\nosupersub   v  …)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       &  (\i r\i0  \sub 1\nosupersub   v  \i r\i0  \sub 2\nosupersub   v  …)  &  …\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь \i р\sub i\nosupersub \i0  , \i q\sub i\nosupersub \i0  , \i r\sub i\nosupersub \i0   — элементарные утверждения или их отрицания. Конъюнктивная нормальная форма есть конъюнкция членов, называемых \i дизъюнктами\i0  , например (\i p\i0  \sub 1\nosupersub  v \i p\i0  \sub 2\nosupersub  v …) — это дизъюнкт.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Любую пропозициональную формулу нетрудно преобразовать в такую форму. В нашем случае это делается следующим образом. У нас есть исходная формула\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (\i а  =>  b\i0  )  &  (\i b  =>  с\i0  )  =>  (\i а  =>  с\i0  )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ее отрицание имеет вид\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ~((\i а  =>  b\i0  ) & (\i b  =>  с\i0  ) => (\i а  =>  с\i0  ))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Для преобразования этой формулы в конъюнктивную нормальную форму можно использовать следующие известные правила:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (1) \i x => у\i0    эквивалентно  \i ~x\i0   v \i у\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (2) \i ~\i0  (\i x\i0   v \i y\i0  )  эквивалентно \i ~x\i0   & \i ~у\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (3) \i ~\i0  (\i x\i0   & \i у\i0  )  эквивалентно  \i ~x\i0   v \i ~у\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (4) \i ~\i0  (\i ~x\i0  )  эквивалентно  \i x\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Применяя правило 1, получаем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ~(~((\i a  =>  b\i0  )  &  (\i b  =>  с\i0  ))  v  (\i а  =>  с\i0  ))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Далее, правила 2 и 4 дают\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (\i а  =>  b\i0  )  &  (\i b  =>  с\i0  )  &  ~(\i а  =>  с\i0  )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Трижды применив правило 1, получаем\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (\i ~а\i0    v  \i b\i0  )  &  (\i ~b\i0    v  \i с\i0  )  &  \i ~\i0  (\i ~а\i0    v  \i с\i0  )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 И наконец, после применения правила 2 получаем искомую конъюнктивную нормальную форму\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (\i ~а\i0    v  \i b\i0  )  &  (\i ~b\i0    v  \i с\i0  )  &  \i а\i0    &  \i ~с\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 состоящую из четырех дизъюнктов. Теперь можно приступить к резолюционному процессу.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Элементарный шаг резолюции выполняется всегда, когда имеется два дизъюнкта, в одном из которых встретилось элементарное утверждение \i p\i0  , а в другом — \i ~p\i0  . Пусть этими двумя дизъюнктами будут\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i p\i0   v \i Y\i0    и  \i ~p\i0   v \i Z\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Шаг резолюции порождает третий дизъюнкт:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i Y\i0    v  \i Z\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нетрудно показать, что этот дизъюнкт логически следует из тех двух дизъюнктов, из которых он получен. Таким образом, добавив выражение (\i Y\i0   v \i Z\i0  ) к нашей исходной формуле, мы не изменим ее истинности. Резолюционный процесс порождает новые дизъюнкты. Появление "пустого дизъюнкта" (обычно записываемого как "nil") сигнализирует о противоречии. Действительно, пустой дизъюнкт \i nil\i0   порождается двумя дизъюнктами вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i x\i0    и  \i ~x\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 которые явно противоречат друг другу.\par
\qc\par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 16.6.\b0   Доказательство теоремы (\i а=>b\i0  )&(\i b=>с\i0  )=>(\i a=>с\i0  ) методом резолюции. Верхняя строка — отрицание теоремы в конъюнктивной нормальной форме. Пустой дизъюнкт внизу сигнализирует, что отрицание теоремы противоречиво.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 16.6 показан процесс применения резолюций, начинающийся с отрицания нашей предполагаемой теоремы и заканчивающийся пустым дизъюнктом.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На рис. 16.7 мы видим, как резолюционный процесс можно сформулировать в форме программы, управляемой образцами. Программа работает с дизъюнктами, записанными в базе данных. В терминах образцов принцип резолюции формулируется следующим образом:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i если\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  существуют два таких дизъюнкта \i C1\i0   и \i C2\i0  , что \i P\i0   является (дизъюнктивным) подвыражением \i C1\i0  , а \i ~P\i0   — подвыражением \i C2\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i то\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить \i P \i0  из \i C1 \i0  (результат — \i CA\i0  ), удалить \i ~P \i0  из \i C2 \i0  (результат — \i CB\i0  ) и добавить в базу данных новый дизъюнкт \i CA\i0   v \i CB\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 На нашем формальном языке это можно записать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ дизъюнкт( C1), удалить( P, C1, CA),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   дизъюнкт( C2), удалить( ~P, C2, CB) ] --->\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ assert( дизъюнкт( СА v СВ) ) ].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Это правило нуждается в небольшой доработке. Дело в том, что мы не должны допускать повторных взаимодействий между дизъюнктами, так как они порождают новые копии уже существующих формул. Для этого в программе рис. 16.7 предусматривается запись в базу данных информации об уже произведенных взаимодействиях в форме утверждений вида\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сделано( C1, C2, P)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В условных частях правил производится распознавание подобных утверждений и обход соответствующих повторных действий.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Правила, показанные на рис. 16.7, предусматривают также обработку специальных случаев, в которых требуется избежать явного представления пустого дизъюнкта. Кроме того, имеются два правила для упрощения дизъюнктов. Одно из них убирает избыточные подвыражения. Например, это правило превращает выражение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i a\i0    v  \i b\i0    v  \i a\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 в более простое выражение \i a\i0   v \i b\i0  . Другое правило распознает те дизъюнкты, которые всегда истинны, например,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i a\i0    v  \i b\i0    v  \i ~а\i0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 и удаляет их из базы данных, поскольку они бесполезны при поиске противоречия.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Продукционные правила для задачи автоматического\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % доказательства теорем\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Противоречие\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ дизъюнкт( X), дизъзюнкт( ~X) ] --->\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ write( 'Обнаружено противоречие'), стоп].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Удалить тривиально истинный дизъюнкт\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ дизъюнкт( С), внутри( P, С), внутри( ~P, С) ] --->\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ retract( С) ].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Упростить дизъюнкт\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ дизъюнкт( С), удалить( P, С, C1), внутри( P, C1) ] --->\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ заменить( дизъюнкт( С), дизъюнкт( C1) ) ].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Шаг резолюции, специальный случай\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ дизъюнкт( P), дизъюнкт( С), удалить( ~P, С, C1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   not сделано( P, С, P) ] --->\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ аssеrt( дизъюнкт( C1)), аssert( сделано( P, С, P))].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Шаг резолюции, специальный случай\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ дизъюнкт( ~P), дизъюнкт( С), удалить( P, С, C1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   not сделано( ~P, С, P) ] --->\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ assert( дизъюнкт( C1)), аssert( сделано( ~P, С, P))].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Шаг резолюции, общий случай\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [ дизъюнкт( C1), удалить( P, C1, CA),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   дизъюнкт( C2), удалить( ~P, C2, CB),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   not сделано( C1, C2, P) ] --->\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [ assert( дизъюнкт( CA v CB) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    assert( сделано( C1, C2, P) ) ].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Последнее правило: тупик\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 [] ---> [ write( 'Нет противоречия'), стоп ].\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % удалить( P, E, E1) означает, получить из выражения E\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % выражение E1, удалив из него подвыражение P\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( X, X v Y, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( X, Y v X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( X, Y v Z, Y v Z1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( X, Z, Z1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удалить( X, Y v Z, Y1 v Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( X, Y, Y1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % внутри( P, E) означает P есть дизъюнктивное подвыражение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % выражения E\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( X, Y, _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 16.7.\b0   Программа, управляемая образцами, для автоматического доказательства теорем.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Остается еще один вопрос: как преобразовать заданную пропозициональную формулу в конъюнктивную нормальную форму? Это несложное преобразование выполняется с помощью программы, показанной на рис. 16.8. Процедура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 транс( Формула)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 транслирует заданную формулу в множество дизъюнктов C1, C2 и т.д. и записывает их при помощи assert в базу данных в виде утверждений\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дизъюнкт( C1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 дизъюнкт( C2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ...\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Программа, управляемая образцами, для автоматического доказательства теорем запускается при помощи цели пуск. Таким образом, для того чтобы доказать при помощи этой программы некоторую теорему, мы транслируем ее отрицание в конъюнктивную нормальную форму, а затем запускаем резолюционный процесс. В нашем примере это можно сделать так:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 ?- транс(~(( а=>b) & ( b=>c) => ( а=>с)) ), пуск.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Ответ программы "Обнаружено противоречие" будет означать, что исходная формула является теоремой.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Преобразование пропозициональной формулы в множество\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % дизъюнктов с записью их в базу данных при помощи assert\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 100, fy, ~).           % Отрицание\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 110, xfy, &).          % Конъюнкция\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 120, xfy, v).          % Дизъюнкция\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 130, xfy, =>).         % Импликация\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 транс( F & G) :- !,     % Транслировать конъюнктивную формулу\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  транс( F),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  транс( G).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 транс( Формула) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  тр( Формула, НовФ), !, % Шаг трансформации\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  транс( НовФ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 транс( Формула) :-      % Дальнейшая трансформация невозможна\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  assert( дизъюнкт( Формула) ).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Правила трансформаций для пропозициональных формул\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тр( ~( ~X), X) :- !.          % Двойное отрицание\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тр( X => Y, ~X v Y) :- !.     % Устранение импликации\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тр( ~( X & Y), ~X v ~Y) :- !. % Закон де Моргана\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тр( ~( X v Y), ~X & ~Y) :- !. % Закон де Моргана\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тр( X & Y v Z, (X v Z) & (Y v Z) ) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Распределительный закон\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тр( X v Y & Z, (X v Y) & (X v Z) ) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Распределительный закон\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тр( X v Y, X1 v Y) :-         % Трансформация подвыражения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  тр( X, X1), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тр( X v Y, X v Y1) :-         % Трансформация подвыражения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  тр( Y, Y1), !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тр( ~X, ~Х1) :-               % Трансформация подвыражения\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  тр( X, X1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b Рис. 16.8.\b0   Преобразование пропозициональных формул в множество дизъюнктов с записью их в базу данных при помощи assert.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 16.4. Заключительные замечания\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Нашего простого интерпретатора было вполне достаточно для того, чтобы проиллюстрировать некоторые идеи, лежащие в основе программирования в терминах образцов. Применение этого интерпретатора для более сложных приложений потребовало бы его доработки в целом ряде направлений. Ниже приводится несколько критических замечаний, а также ряд конкретных предложений по усовершенствованию алгоритма интерпретации.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задача разрешения конфликтов была сведена в нашем интерпретаторе к введению заранее заданного фиксированного порядка рассмотрения модулей. Часто возникает необходимость в более гибких механизмах. Для обеспечения более тонкого управления интерпретацией следует подавать все обнаруженные потенциально активные модули на вход специального управляющего модуля, запрограммированного пользователем.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Когда база данных велика, а программа содержит большое количество модулей, процесс сопоставления с образцами становится крайне неэффективным. Неэффективность можно уменьшить, усложнив организацию базы данных. В частности, можно ввести индексирование информации, записанной в базе данных, или разбить эту информацию на отдельные "подбазы данных", или же разбить все множество модулей на отдельные подмножества. Идея разбиения — в каждый момент дать доступ только к некоторому \i подмножеству\i0   базы данных или набора модулей, ограничив тем самым сопоставление образцов только этим подмножеством. Разумеется, в этом случае механизм управления должен усложниться, поскольку он должен будет обеспечить переход от одних подмножеств к другим с целью их активизации либо деактивизации. Для этого можно применить специальные метаправила.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 К сожалению, наш интерпретатор запрограммирован таким образом, что он блокирует механизм автоматических возвратов, так как для манипулирования базой данных он использует процедуры assert и retract. Это положение можно исправить, применив другой способ реализации базы данных, не требующий обращения к этим встроенным процедурам. Например, все состоять базы данных можно представить одним прологовским термом, передаваемым в процедуру пуск в качестве аргумента. Простейший способ реализации этой идеи — организовать этот терм в виде списка объектов базы данных. Тогда верхний уровень базы данных примет вид:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 пуск( Состояние) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Условие ---> Действие,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  проверить( Условие, Состояние),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  выполнить( Действие, Состояние).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Задача процедуры выполнить — получить новое состояние базы данных и обратиться к процедуре пуск, подав на ее вход это новое состояние.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Проект\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Запрограммируйте интерпретатор, который, в соответствии с приведенным выше замечанием, реализует базу данных как аргумент пусковой процедуры и не использует для этого внутренней базы данных пролог-системы (т.е. обходится без assert и retract). Эта новая версия интерпретатора будет допускать автоматические возвраты. Попытайтесь разработать такое представление базы данных, которое облегчало бы сопоставление с образцами.\par
\par
\s4 \qc\snext0\lang1049\f1\fs26\b\fi0\li0\ri0 Резюме\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Архитектура, ориентированная на типовые конфигурации (образцы), хорошо приспособлена для решения многих задач искусственного интеллекта.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Программа, управляемая образцами, состоит из модулей, запускаемых при возникновении в базе данных тех или иных конфигураций.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Прологовские программы можно рассматривать как частный случай систем, управляемых образцами.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Параллельная реализация — наиболее естественный способ реализации систем, управляемых образцами. Реализация на последовательной машине требует разрешения конфликтов между модулями, содержащимися в конфликтном множестве.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • В этой главе был реализован простой интерпретатор для программ, управляемых образцами. Он был затем применен к задаче автоматического доказательства теорем пропозициональной логики.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 • Были рассмотрены следующие понятия:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    системы, управляемые образцами\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    архитектуры, ориентированные на образцы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    программирование в терминах образцов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    модули, управляемые образцами\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    конфликтное множество, разрешение конфликтов\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    принцип резолюции\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    автоматическое доказательство теорем на основе принципа резолюции\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Литература\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Waterman and Hayes-Roth (1978) — классическая книга по системам, управляемым образцами. В книге Nilsson (1980) можно найти фундаментальные понятия, относящиеся к задаче автоматического доказательства теорем, включая алгоритм преобразования логических формул в конъюнктивную нормальную форму. Прологовская программа для выполнения этого преобразования приведена в Clocksin and Mellish (1981).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Clocksin F. W. and Mellish С S. (1981). \i Programming in Prolog.\i0   Springer-Verlag. [Имеется перевод: Клоксин У., Мелиш К. Программирование на языке Пролог. — М.: Мир, 1987.]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Nilsson N. J. (1980). \i Principles of Artificial Intelligence.\i0   Tioga; Springer-Verlag.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Waterman D. A. and Hayes-Roth F. (1978, eds). \i Pattern-Directed Inference Systems.\i0   Academic Press.\par
\par
\par
\par
\s2 \qc\snext0\b\f0\fs28\fi0\li0\ri0 Ответы к некоторым упражнениям\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Глава 1\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.1\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) no\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) X = пат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) X = боб\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d) X = боб, Y = пат\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.2\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) ?- родитель( X, пат).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) ?- родитель( лиз, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) ?- родитель( Y, пат), родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.3\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) счастлив( X) :- \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     родитель( X, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) имеетдвухдетей( X) :- \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     родитель( X, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     сестра( Z, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.4\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внук( X, Z) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Y, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Z, Y).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.5\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 тетя( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  родитель( Z, Y),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сестра( X, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.6\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Да. (Определение верно)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 1.7\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) возвратов не будет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) возвратов не будет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) возвратов не будет\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d) возвраты будут\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Глава 2\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.1\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) переменная\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) атом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) атом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d) переменная\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (e) атом\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (f) структура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (g) число\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (h) синтаксически неправильное выражение\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (i) структура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (j) структура\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.3\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) успех\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) неуспех\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) неуспех\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d) D = 2, E = 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (e) P1 = точка(-1, 0) \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Р2 = точка( 1, 0)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Р3 = точка( 0, Y)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Такая конкретизация определяет семейство треугольников, у которых две вершины располагаются на оси \i x\i0   в точках 1 и -1, а третья — в произвольной точке оси \i у\i0  .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.4\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отр( точка( 5, Y1), точка( 5, Y2) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.5\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 регулярный( прямоугольник( точка( X1, Y1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  точка( Х2, Y1), точкa( X2, Y3),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  точка( X1, Y3) ) ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Здесь предполагается, что первая точка соответствует нижней левой вершине прямоугольника.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.6\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) А = два\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) no\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) С = один\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d) D = s(s(1));\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    D = s(s(s(s(s(1)))))\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.7\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 родственники( X, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( X, Y);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Y, X);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Z, X),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Z, Y);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( X, Z),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  предок( Y, Z).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.8\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобразовать( 1, один).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобразовать( 2, два).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобразовать( 3, три).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.9\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В случае, изображенном на рис. 2.10, пролог-система выполняет несколько больший объем работы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 2.10\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 В соответствии с определением сопоставления, приведенном в разд. 2.2, данное сопоставление будет успешным. X приобретает вид циклической структуры, в которой сам X присутствует в качестве одного из аргументов.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Глава 3\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.1\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) конк( L1, [ _, _, _ ], L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) конк( [ _, _, _ ], L1, L),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      % Удалить 3 первые элемента L\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     конк( L2, [ _, _, _ ], L1)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      % Удалить 3 последние элемента L1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Вот более короткий вариант, предложенный I. Tvrdy:\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конк( [ _, _, _ | L2], [ _, _, _ ], L)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.2\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (а) последний( Элемент, Список) :- \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    конк( _, [Элемент], Список).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) последний( Элемент, [Элемент]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    последний( Элемент, [Первый | Остальные]):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     последний( Элемент, Остальные). \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.3\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 четнаядлина( [] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 четнаядлина( [Первый | Остальные] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  нечетнаядлина( Остальные).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нечетнаядлина( [ _ ] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 нечетнаядлина( [Первый | Остальные] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  четнаядлина( Остальные).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.4\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обращение( [], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обращение( [Первый | Остальные], ОбращСпис): -\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обращение( Остальные, ОбращСписОстальных),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( О6ращСписОстальных, [Первый], ОбращСпис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.5\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Такой предикат легко определить при помощи отношения обратить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 палиндром( Список) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обратить( Список, Список).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Вот другое решение, не использующее обратить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 палиндром1( [] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 палиндром1( [ _ ] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 палиндром1 [Первый | Остальные] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Середина, [Первый], Остальные),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  палиндром1( Середина).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.6\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сдвиг( [Первый | Остальные], Сдвинут) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Остальные, [Первый], Сдвинут).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.7\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перевод( [], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 перевод( [Голова | Хвост], [Голова1 | Хвост1]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  означает( Голова, Голова1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  перевод( Хвост, Хвост1).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.8\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подмножество( [], [] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подмножество( [Первый | Остальные], [Первый | Подмн]):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Оставить первый элемент в подмножестве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  подмножество( Остальные, Подмн).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подмножество( [Первый | Остальные], Подмн) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Убрать первый элемент из подмножества\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  подмножество( Остальные, Подмн).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.9\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбиениесписка( [], [], []). % Разбивать нечего\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбиениесписка( [X], [X], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Разбиение одноэлементного списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбиениесписка( [X, Y | Список], [X | Список1],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [Y | Список2]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разбиениесписка( Список, Список1, Список2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.10\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можетзавладеть( состояние( _, _, _, имеет), [] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Ничего не надо делать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 можетзавладеть( Состояние, [Действие | Действия]):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ход( Состояние, Действие, НовоеСостояние),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Первое действие\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  можетзавладеть( НовоеСостояние, Действия).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Оставшиеся действия\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.11\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 линеаризация( [Голова | Хвост], ЛинейныйСписок ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Линеаризация непустого списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  линеаризация( Голова, ЛинейнаяГолова ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  линеаризация( Хвост, ЛинейныйХвост ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( ЛинейнаяГолова, ЛинейныйХвост,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ЛинейныйСписок ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 линеаризация( [], [] ). % Линеаризация пустого списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 линеаризация( X, [X] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  % Линеаризация объекта, не являющегося списком\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Замечание: при попытке получить от этой программы более\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % одного варианта решения выдается бессмыслица\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.12\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Терм1 = играет_в( джимми, и( футбол, сквош) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Терм2 = играет_в( сьюзан, и( теннис,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  и( баскетбол, волейбол) ) )\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.13\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 300, xfx, работает)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 200, xfx, в)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 100, xfx, нашем)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.14\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) А = 1 + 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) В = 1 + 1 + 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) С = 1 + 1 + 1 + 1 + 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d) D = 1 + 1 + 0 + 1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.15\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 100, xfx, входит_в)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 300, fx, конкатенация_списков)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 200, xfx, дает)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 100, xfx, и)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 300, fx, удаление_элемента)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 100, xfx, из_списка) % Принадлежность к списку\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Элемент входит_в [Элемент | Список].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Элемент входит_в [Первый | СписокОстальных] :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Элемент входит_в СписокОстальных.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Конкатенация списков\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конкатенация_списков [] и Список дает Список.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 конкатенация_списков [X | L1] и L2 дает [X | L3] :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конкатенация_списков L1 и L2 дает L3.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Удаление элемента из списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удаление_элемента Элемент из_списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [Элемент | ОстальныеЭлементы]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  дает ОстальныеЭлементы.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 удаление_элемента Элемент из_списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [Первый | ОстальныеЭлементы]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  дает [Первый | НовСписОстЭлементов] :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удаление_элемента Элемент из_списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ОстальныеЭлементы дает НовСписОстЭлементов.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.16\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 max( X, Y, X) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X >= Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 max( X, Y, Y) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X <Y.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.17\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 максспис( [X], X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Максимум в одноэлементном списке\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 максспис( [X, Y | Остальные], Мах) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % В списке есть по крайней мере два элемента?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 максспис( [Y | Остальные], МаксОстальные),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  mах( X, МаксОстальные, Мах).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Мах наибольшее из чисел X и МаксОстальные\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.18\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумспис( [], 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сумспис( [Первый | Остальные], Сумма) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сумспис( Остальные, СуммаОстальных),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Сумма is Первый + СуммаОстальных.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.19\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 упорядоченный ([]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Одноэлементный список является упорядоченным\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 упорядоченный( [X, Y | Остальные] :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X =< Y,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  упорядоченный( [Y | Остальные] ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.20\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подсумма( [], 0, []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подсумма( [N | Список], Сумма, [N | Подмн]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % N принадлежит подмножеству\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Сумма1 is Сумма - N,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  подсумма( Список, Сумма1, Подмн).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 подсумма( [N | Список], Сумма, Подмн) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % N не принадлежит подмножеству\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  подсумма( Список, Сумма, Подмн).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.21\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 между( N1, N2, N1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N1 =< N2.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 между( N1, N2, X) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N1 < N2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  HoвoeN1 is N1 + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  между( HoвoeN1, N2, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 3.22\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 900, fx, если).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 800, xfx, то).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 700, xfx, иначе).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 :- op( 600, xfx, :=).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если Вел1 > Вел2 то Перем := Вел3\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  иначе ЧтоУгодно :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Вел1 > Вел2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Перем = Вел3.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 если Вел1 > Вел2 то ЧтоУгодно\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  иначе Перем := Вел4 :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Вел1 =< Вел2,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Перем = Вел4.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Глава 4\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.1\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) ?- семья(членсемьи( _, Фамилия, _, _ ), _, []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) ?- ребенок( членсемьи( Имя, Фамилия, _, \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     работает( _, _ ) )).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) семья(членсемьи( _, Фамилия, _, неработает),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     членсемьи( _, _, _, работает( _, _ ) ),_ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (d) ?- семья( Муж, Жена, Дети),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     датарождения( Муж, дата( _, _, Год1) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     датарождения( Жена, дата( _, _, Год2) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ( Год1 - Год2 >= 15;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0       Год2 - Год1 >= 15 ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     принадлежит( Ребенок, Дети).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.2\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 близнецы( Ребенок1, Ребенок2) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  семья( _, _, Дети),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  удалить( Ребенок1, Дети, ДругиеДети),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Выделить первого ребенка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Ребенок2, ДругиеДети),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Ребенок1, Дата),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( Ребенок2, Дата).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.3\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i n\i0  _элемент( 1, [X | L], X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % X - первый элемент списка [X | L]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i n\i0  _элемент( N, [Y | L], X) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % X - n-й элемент [Y | L]\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  N1 is N - 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \i  n\i0  _элемент( N1, L, X).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.4\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Входная цепочка укорачивается на каждом неспонтанном цикле, а укорачиваться бесконечно она не может.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.5\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 допускается( S, [], _ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конечное( S).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 допускается( S, [X | Остальные], Макс_переходов) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Макс_переходов > 0,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  переход( S, X, S1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  НовыйМакс is Макс_переходов - 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  допускается( S1, Остальные, НовыйМакс).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 допускается( S, Цепочка, Макс_переходов) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Макс_переходов > 0,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  спонтанный( S, S1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  НовыйМакс is Макс_переходов - 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  допускается( S1, Цепочка, НовыйМакс).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 4.7\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (а) ходконя( X/Y, X1/Y1) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      % Ход коня с поля X/Y на поле X1/Y1\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ( dxy( DX, DY);\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      % Расстояния по направлениям X и Y\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     dxy( DY, DX) ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      % Или расстояния по направлениям Y и X\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     X1 is X + DX,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      % X1 расположен в пределах шахматной доски\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     надоске( X1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Y1 is Y + DY,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      % Y1 расположен в пределах шахматной доски\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     надоске( Y1).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    dxy( 2, 1).   % 2 поля вправо, 1 поле вперед\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    dxy( 2, -1).  % 2 поля вправо, 1 поле назад\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    dxy( -2, 1).  % 2 поля влево, 1 поле вперед\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    dxy( -2, -1). % 2 поля влево, 1 поле назад\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    надоске( Коорд) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0      % Координаты в пределах доски\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     0 < Коорд,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     Коорд < 9.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) путьконя( [ Поле]). % Конь стоит на поле Поле\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    путьконя( [S1, S2 | Остальные] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     ходконя( S1, S2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     путьконя( [S2 | Остальные]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) ?- путьконя( [2/1, R, 5/4, S, X/8] ).\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Глава 5\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.1\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (a) X = 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    X = 2\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (b) X = 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Y = 1;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    X = 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Y = 2;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    X = 2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Y = 1;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    X = 2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Y = 2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (c) X = 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Y = 1;\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    X = 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    Y = 2;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.2\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( Число, положительное) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Число > 0, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( 0, нуль) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 класс( Число, отрицательное).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.3\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбить( [], [], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбить( [X | L], [X | L1], L2) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  X >= 0, !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разбить( L, L1, L2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбить( [X | L], L1, [X | L2]) .\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разбить( L, L1, L2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.4\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( Некто, Кандидаты),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not принадлежит( Некто, Исключенные)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.5\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разность( [], _, []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разность( [X | L1], L2, L):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, L2), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разность( L1, L2, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разность( [X | L1], L2, [X | L]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разность( L1, L2, L).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 5.6\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 унифицируемые( [], _, []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 унифицируемые( [Первый | Остальные], Терм, Список) : -\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not( Первый = Терм), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  унифицируемые( Остальные, Терм, Список).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 унифицируемые( [Первый | Остальные], Терм,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  [Первый | Список] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  унифицируемые( Остальные, Терм, Список).\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Глава 6\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 6.1\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 найтитерм( Терм) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Пусть текущий входной поток - это файл f\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( Терм), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Текущий терм из f сопоставим с Терм'ом?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( Терм);      % Если да - вывести его на терминал\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   найтитерм( Терм). % В противном случае - обработать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 6.2\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 найтитермы( Терм) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  read( ТекущийТерм),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обработать( ТекущийТерм, Терм).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( end_of_file, _ ) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обработать( ТекущийТерм, Терм) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( not( ТекущийТерм = Терм), !;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     % Термы несопоставимы\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( ТекущийТерм), nl),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % В противном случае вывести текущий терм\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  найтивсетермы( Терм).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Обработать оставшуюся часть файла\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 6.4\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 начинается( Атом, Символ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  name( Символ, [ Код]),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  name( Атом, [Код | _ ]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 6.5\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 plural( Существительное, Существительные) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  name( Существительное, СписокКодов),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  name( s, КодS),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( СписокКодов, КодS, НовыйСписокКодов),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  name( Существительные, НовыйСписокКодов).\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Глава 7\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 7.2\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( Элемент, Список) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  var( Список), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Переменная Список представляет пустой список\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 Список = [Элемент | Хвост].\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить( Элемент, [ _ | Хвост]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  добавить( Элемент, Хвост).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, Список) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  var( Список), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Переменная Список представляет пустой список,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % поэтому X не может ему принадлежать\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  fail.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [X | Хвост]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, [ _ | Хвост] ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, Хвост).\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Глава 8\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 8.2\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 добавить_в_конец( L1-[Элемент | Z2], Элемент, L1 - Z2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 8.3\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обратить( А - Z, L - L) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Результатом является пустой список,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % если A-Z представляет пустой список\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  А == Z, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 обратить( [X | L] - Z, RL - RZ ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Непустой список\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  обратить( L - Z, RL - [X | RZ].\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Глава 9\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.1\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 список( []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 список( [ _ | Хвост]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  список( Хвост).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.2\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, X затем ЧтоУгодно).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 принадлежит( X, Y затем Спис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  принадлежит( X, Спис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.3\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобр( [ , ничего_не_делать).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобр( [Первый | Хвост], Первый затем Остальные):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  преобр( Хвост, Остальные).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.4\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобр( [ , ПустСпис, _, ПустСпис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Случай пустого списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 преобр( [Первый | Хвост], НовСпис, Функтор, Пустой) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  НовСпис =.. [Функтор, Первый, НовХвост],\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  преобр( Хвост, НовХвост, Функтор, Пустой).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.8\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сорт1( [], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сорт1( [X], [X]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 сорт1( Спис, УпорСпис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разбить( Спис, Спис1, Спис2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Разбить на 2 прибл. равных списка\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сорт1( Спис1, Упор1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  сорт1( Спис2, Упор2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  слить( Упор1, Упор2, УпорСпис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Слить отсортированные списки\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбить( [], [], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбить( [X], [X], []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 разбить( [X, Y | L], [X | L1], [Y | L2]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % X и Y помещаются в разные списки\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  разбить( L, L1, L2).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.9\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 (а) двдерево( nil).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0    двдерево( д( Лев, Кор, Прав) ) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     двдерево( Лев),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0     двдерево( Прав).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.10\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 глубина( пусто, 0).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 глубина( д( Лев, Кор, Прав), Г) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  глубина( Лев, ГЛ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  глубина( Прав, ГП),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  макс( ГЛ, ГП, МГ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Г is МГ + 1.\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 макс( А, В, А) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  А >= В, !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 макс( А, В, В).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.11\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 линеаризация( nil, []).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 линеаризация( д( Лев, Кор, Прав), Спис) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  линеаризация( Лев, Спис1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  линеаризация( Прав, Спис2),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  конк( Спис1, [Кор | Спис2], Спис).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.12\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 максэлемент( д( _, Кор, nil), Кор) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Корень - самый правый элемент\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 максэлемент( д( _, _, Прав,), Макс) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Правое поддерево непустое\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  максэлемент( Прав, Макс).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.13\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( Элем, д( _, Элем, _ ), [ Элем]).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( Элем, д( Лев, Кор, _ ), [Кор | Путь]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( Кор, Элем),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внутри( Элем, Лев, Путь).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( Элем,д( _, Кор, Прав), [Кор | Путь]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( Элем, Кор),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внутри( Элем, Прав, Путь).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 9.14\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Отображение двоичного дерева, растущего сверху вниз\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % Предполагается, что каждая вершина занимает при печати\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 % один символ\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 отобр( Дер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  уровни( Дер, 0, да).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Обработать все уровни\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 уровни( Дер, Уров, нет) :- !.\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Ниже уровня Уров больше нет вершин\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 уровни( Дер, Уров, да) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Обработать все уровни, начиная с Уров\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вывод( Дер, Уров, 0, Дальше), nl,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Вывести вершины уровня Уров\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Уров1 is Уров + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  уровни( Дер, Уров1, Дальше).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Обработать следующие уровни\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывод( nil, _, _, _, _ ).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вывод( д( Лев, X, Прав), Уров, ГлубХ, Дальше) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  Глуб1 is ГлубХ + 1,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вывод( Лев, Уров, Глуб1, Дальше),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Вывод левого поддерева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( Уров = ГлубХ, !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % X на нашем уровне?\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write( X), Дальше = да;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Вывести вершину, продолжить\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  write(' ') ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Иначе - оставить место\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вывод( Прав, Уров, Глуб1, Дальше).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Вывод левого поддерева\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Глава 10\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 10.1\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( Элем, л( Элем)). % Элемент найден в листе\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( Элем, в2( Д1, М, Д2) ):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Вершина имеет два поддерева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( М, Элем), !,    % Вершина не во втором поддереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внутри( Элем, Д1);      % Поиск в первом поддереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внутри( Элем, Д2).      % Иначе - во втором поддереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 внутри( Элем, в3( Д1, M2, Д2, М3, Д3) ):-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Вершина имеет три поддерева\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( M2, Элем), !,\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Элемент не во втором и не в третьем поддереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внутри( Элем, Д1);      % Поиск в первом поддереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  больше( M3, Элем), !,   % Элемент не в третьем поддереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внутри( Элем, Д2);      % Поиск во втором поддереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  внутри( Элем, Д3).      % Поиск в третьем поддереве\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 10.3\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 avl( Дер) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  аvl( Дер, Глуб).  % Дер является AVL-деревом глубины Глуб\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 avl( nil, 0).      % Пустое дерево - AVL -дерево глубины 0\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 avl( д( Лев, Кор, Прав), Г) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  avl( Лев, ГЛ),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  avl( Прав, ГП),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  ( ГЛ is ГП; ГЛ is ГП + 1; ГЛ is ГП - 1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % Глубины поддеревьев примерно совпадают\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  макс( ГЛ, ГП, Г).\par
\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 макс1( U, V, М) :- % М = 1 + макс( U, V)\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  U > V, !, М is U + 1;\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  М is V + 1.\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s6 \qc\snext0\s6\f1\b\fs24\fi0 Глава 11\par
\s0 \ql\snext0\f1\fs24\b0\i0\fi567\sb0\sa0\li0\ri0 \par\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 11.1\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вглубину1( [Верш | Путь], [Верш | Путь]) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  цель( Верш).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 вглубину1( [Верш | Путь], Решение) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  после( Верш, Верш1),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  not принадлежит( Верш1, Путь),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вглубину1( [ Верш1, Верш | Путь], Решение).\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 \b 11.6\b0  \par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0 решить( СтартМнож, Решение) :-\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   % СтартМнож - множество стартовых вершин\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  bagof( [Верш], принадлежит( Верш, СтартМнож),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0   Пути),\par
\s0 \qj\snext0\f1\fs24\b0\i0\fi567\li0\ri0  вширину( Пути, Решение).\par
\par

\s0 \f0\qc\fi0\li0\ri0 Спасибо, что скачали книгу в 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru" }}{\fldrslt \ul бесплатной электронной библиотеке Royallib.ru}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru/comment/bratko_ivan/programmirovanie_na_yazike_prolog_dlya_iskusstvennogo_intellekta.html" }}{\fldrslt \ul Оставить отзыв о книге}}
\par

\s0 \f0\qc\fi0\li0\ri0 
{\field{\*\fldinst{HYPERLINK "http://royallib.ru/author/bratko_ivan.html" }}{\fldrslt \ul Все книги автора}}
\par

}
